/* @preserve: WARNING: This javascript file in the base1 package is deprecated */
console.warn("Deprecated: " + (new Error().fileName || "This javascript file").split("/").reverse()[0] + " in the Cockpit base1 package is deprecated");

/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */
/*global define: false Mustache: true*/
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */
/*global define: false Mustache: true*/
(function e(t, r) {
    if (typeof exports === "object" && exports && typeof exports.nodeName !== "string") {
        r(exports);
 // CommonJS
        } else if (typeof define === "function" && define.amd) {
        define([ "exports" ], r);
 // AMD
        } else {
        t.Mustache = {};
        r(t.Mustache);
 // script, wsh, asp
        }
})(this, function e(x) {
    var r = Object.prototype.toString;
    var m = Array.isArray || function e(t) {
        return r.call(t) === "[object Array]";
    };
    function c(e) {
        return typeof e === "function";
    }
    /**
   * More correct typeof string handling array
   * which normally returns typeof 'object'
   */    function s(e) {
        return m(e) ? "array" : typeof e;
    }
    function E(e) {
        return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    /**
   * Null safe way of checking whether or not an object,
   * including its prototype, has a given property
   */    function l(e, t) {
        return e != null && typeof e === "object" && t in e;
    }
    /**
   * Safe way of detecting whether or not the given thing is a primitive and
   * whether it has the given property
   */    function f(e, t) {
        return e != null && typeof e !== "object" && e.hasOwnProperty && e.hasOwnProperty(t);
    }
    // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
    // See https://github.com/janl/mustache.js/issues/189
        var n = RegExp.prototype.test;
    function t(e, t) {
        return n.call(e, t);
    }
    var i = /\S/;
    function U(e) {
        return !t(i, e);
    }
    var a = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
        "`": "&#x60;",
        "=": "&#x3D;"
    };
    function o(e) {
        return String(e).replace(/[&<>"'`=\/]/g, function e(t) {
            return a[t];
        });
    }
    var T = /\s*/;
    var j = /\s+/;
    var C = /\s*=/;
    var S = /\s*\}/;
    var V = /#|\^|\/|>|\{|&|=|!/;
    /**
   * Breaks up the given `template` string into a tree of tokens. If the `tags`
   * argument is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
   * course, the default is to use mustaches (i.e. mustache.tags).
   *
   * A token is an array with at least 4 elements. The first element is the
   * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
   * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
   * all text that appears outside a symbol this element is "text".
   *
   * The second element of a token is its "value". For mustache tags this is
   * whatever else was inside the tag besides the opening symbol. For text tokens
   * this is the text itself.
   *
   * The third and fourth elements of the token are the start and end indices,
   * respectively, of the token in the original template.
   *
   * Tokens that are the root node of a subtree contain two more elements: 1) an
   * array of tokens in the subtree and 2) the index in the original template at
   * which the closing tag for that section begins.
   */    function u(e, t) {
        if (!e) return [];
        var r = [];
 // Stack to hold section tokens
                var n = [];
 // Buffer to hold the tokens
                var i = [];
 // Indices of whitespace tokens on the current line
                var s = false;
 // Is there a {{tag}} on the current line?
                var a = false;
 // Is there a non-space char on the current line?
        // Strips all whitespace tokens array for the current line
        // if there was a {{#tag}} on it and otherwise only space.
                function o() {
            if (s && !a) {
                while (i.length) delete n[i.pop()];
            } else {
                i = [];
            }
            s = false;
            a = false;
        }
        var u, l, f;
        function c(e) {
            if (typeof e === "string") e = e.split(j, 2);
            if (!m(e) || e.length !== 2) throw new Error("Invalid tags: " + e);
            u = new RegExp(E(e[0]) + "\\s*");
            l = new RegExp("\\s*" + E(e[1]));
            f = new RegExp("\\s*" + E("}" + e[1]));
        }
        c(t || x.tags);
        var p = new A(e);
        var h, v, d, g, w, y;
        while (!p.eos()) {
            h = p.pos;
            // Match any text between tags.
                        d = p.scanUntil(u);
            if (d) {
                for (var k = 0, b = d.length; k < b; ++k) {
                    g = d.charAt(k);
                    if (U(g)) {
                        i.push(n.length);
                    } else {
                        a = true;
                    }
                    n.push([ "text", g, h, h + 1 ]);
                    h += 1;
                    // Check for whitespace on the current line.
                                        if (g === "\n") o();
                }
            }
            // Match the opening tag.
                        if (!p.scan(u)) break;
            s = true;
            // Get the tag type.
                        v = p.scan(V) || "name";
            p.scan(T);
            // Get the tag value.
                        if (v === "=") {
                d = p.scanUntil(C);
                p.scan(C);
                p.scanUntil(l);
            } else if (v === "{") {
                d = p.scanUntil(f);
                p.scan(S);
                p.scanUntil(l);
                v = "&";
            } else {
                d = p.scanUntil(l);
            }
            // Match the closing tag.
                        if (!p.scan(l)) throw new Error("Unclosed tag at " + p.pos);
            w = [ v, d, h, p.pos ];
            n.push(w);
            if (v === "#" || v === "^") {
                r.push(w);
            } else if (v === "/") {
                // Check section nesting.
                y = r.pop();
                if (!y) throw new Error('Unopened section "' + d + '" at ' + h);
                if (y[1] !== d) throw new Error('Unclosed section "' + y[1] + '" at ' + h);
            } else if (v === "name" || v === "{" || v === "&") {
                a = true;
            } else if (v === "=") {
                // Set the tags for the next time around.
                c(d);
            }
        }
        // Make sure there are no open sections when we're done.
                y = r.pop();
        if (y) throw new Error('Unclosed section "' + y[1] + '" at ' + p.pos);
        return P(O(n));
    }
    /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */    function O(e) {
        var t = [];
        var r, n;
        for (var i = 0, s = e.length; i < s; ++i) {
            r = e[i];
            if (r) {
                if (r[0] === "text" && n && n[0] === "text") {
                    n[1] += r[1];
                    n[3] = r[3];
                } else {
                    t.push(r);
                    n = r;
                }
            }
        }
        return t;
    }
    /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */    function P(e) {
        var t = [];
        var r = t;
        var n = [];
        var i, s;
        for (var a = 0, o = e.length; a < o; ++a) {
            i = e[a];
            switch (i[0]) {
              case "#":
              case "^":
                r.push(i);
                n.push(i);
                r = i[4] = [];
                break;

              case "/":
                s = n.pop();
                s[5] = i[2];
                r = n.length > 0 ? n[n.length - 1][4] : t;
                break;

              default:
                r.push(i);
            }
        }
        return t;
    }
    /**
   * A simple string scanner that is used by the template parser to find
   * tokens in template strings.
   */    function A(e) {
        this.string = e;
        this.tail = e;
        this.pos = 0;
    }
    /**
   * Returns `true` if the tail is empty (end of string).
   */    A.prototype.eos = function e() {
        return this.tail === "";
    };
    /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */    A.prototype.scan = function e(t) {
        var r = this.tail.match(t);
        if (!r || r.index !== 0) return "";
        var n = r[0];
        this.tail = this.tail.substring(n.length);
        this.pos += n.length;
        return n;
    };
    /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */    A.prototype.scanUntil = function e(t) {
        var r = this.tail.search(t), n;
        switch (r) {
          case -1:
            n = this.tail;
            this.tail = "";
            break;

          case 0:
            n = "";
            break;

          default:
            n = this.tail.substring(0, r);
            this.tail = this.tail.substring(r);
        }
        this.pos += n.length;
        return n;
    };
    /**
   * Represents a rendering context by wrapping a view object and
   * maintaining a reference to the parent context.
   */    function p(e, t) {
        this.view = e;
        this.cache = {
            ".": this.view
        };
        this.parent = t;
    }
    /**
   * Creates a new context using the given view with this context
   * as the parent.
   */    p.prototype.push = function e(t) {
        return new p(t, this);
    };
    /**
   * Returns the value of the given name in this context, traversing
   * up the context hierarchy if the value is absent in this context's view.
   */    p.prototype.lookup = function e(t) {
        var r = this.cache;
        var n;
        if (r.hasOwnProperty(t)) {
            n = r[t];
        } else {
            var i = this, s, a, o, u = false;
            while (i) {
                if (t.indexOf(".") > 0) {
                    s = i.view;
                    a = t.split(".");
                    o = 0;
                    /**
           * Using the dot notion path in `name`, we descend through the
           * nested objects.
           *
           * To be certain that the lookup has been successful, we have to
           * check if the last object in the path actually has the property
           * we are looking for. We store the result in `lookupHit`.
           *
           * This is specially necessary for when the value has been set to
           * `undefined` and we want to avoid looking up parent contexts.
           *
           * In the case where dot notation is used, we consider the lookup
           * to be successful even if the last "object" in the path is
           * not actually an object but a primitive (e.g., a string, or an
           * integer), because it is sometimes useful to access a property
           * of an autoboxed primitive, such as the length of a string.
           **/                    while (s != null && o < a.length) {
                        if (o === a.length - 1) u = l(s, a[o]) || f(s, a[o]);
                        s = s[a[o++]];
                    }
                } else {
                    s = i.view[t];
                    /**
           * Only checking against `hasProperty`, which always returns `false` if
           * `context.view` is not an object. Deliberately omitting the check
           * against `primitiveHasOwnProperty` if dot notation is not used.
           *
           * Consider this example:
           * ```
           * Mustache.render("The length of a football field is {{#length}}{{length}}{{/length}}.", {length: "100 yards"})
           * ```
           *
           * If we were to check also against `primitiveHasOwnProperty`, as we do
           * in the dot notation case, then render call would return:
           *
           * "The length of a football field is 9."
           *
           * rather than the expected:
           *
           * "The length of a football field is 100 yards."
           **/                    u = l(i.view, t);
                }
                if (u) {
                    n = s;
                    break;
                }
                i = i.parent;
            }
            r[t] = n;
        }
        if (c(n)) n = n.call(this.view);
        return n;
    };
    /**
   * A Writer knows how to take a stream of tokens and render them to a
   * string, given a context. It also maintains a cache of templates to
   * avoid the need to parse the same template twice.
   */    function h() {
        this.cache = {};
    }
    /**
   * Clears all cached templates in this writer.
   */    h.prototype.clearCache = function e() {
        this.cache = {};
    };
    /**
   * Parses and caches the given `template` according to the given `tags` or
   * `mustache.tags` if `tags` is omitted,  and returns the array of tokens
   * that is generated from the parse.
   */    h.prototype.parse = function e(t, r) {
        var n = this.cache;
        var i = t + ":" + (r || x.tags).join(":");
        var s = n[i];
        if (s == null) s = n[i] = u(t, r);
        return s;
    };
    /**
   * High-level method that is used to render the given `template` with
   * the given `view`.
   *
   * The optional `partials` argument may be an object that contains the
   * names and templates of partials that are used in the template. It may
   * also be a function that is used to load partial templates on the fly
   * that takes a single argument: the name of the partial.
   *
   * If the optional `tags` argument is given here it must be an array with two
   * string values: the opening and closing tags used in the template (e.g.
   * [ "<%", "%>" ]). The default is to mustache.tags.
   */    h.prototype.render = function e(t, r, n, i) {
        var s = this.parse(t, i);
        var a = r instanceof p ? r : new p(r);
        return this.renderTokens(s, a, n, t, i);
    };
    /**
   * Low-level method that renders the given array of `tokens` using
   * the given `context` and `partials`.
   *
   * Note: The `originalTemplate` is only ever used to extract the portion
   * of the original template that was contained in a higher-order section.
   * If the template doesn't use higher-order sections, this argument may
   * be omitted.
   */    h.prototype.renderTokens = function e(t, r, n, i, s) {
        var a = "";
        var o, u, l;
        for (var f = 0, c = t.length; f < c; ++f) {
            l = undefined;
            o = t[f];
            u = o[0];
            if (u === "#") l = this.renderSection(o, r, n, i); else if (u === "^") l = this.renderInverted(o, r, n, i); else if (u === ">") l = this.renderPartial(o, r, n, s); else if (u === "&") l = this.unescapedValue(o, r); else if (u === "name") l = this.escapedValue(o, r); else if (u === "text") l = this.rawValue(o);
            if (l !== undefined) a += l;
        }
        return a;
    };
    h.prototype.renderSection = function e(t, r, n, i) {
        var s = this;
        var a = "";
        var o = r.lookup(t[1]);
        // This function is used to render an arbitrary template
        // in the current context by higher-order sections.
                function u(e) {
            return s.render(e, r, n);
        }
        if (!o) return;
        if (m(o)) {
            for (var l = 0, f = o.length; l < f; ++l) {
                a += this.renderTokens(t[4], r.push(o[l]), n, i);
            }
        } else if (typeof o === "object" || typeof o === "string" || typeof o === "number") {
            a += this.renderTokens(t[4], r.push(o), n, i);
        } else if (c(o)) {
            if (typeof i !== "string") throw new Error("Cannot use higher-order sections without the original template");
            // Extract the portion of the original template that the section contains.
                        o = o.call(r.view, i.slice(t[3], t[5]), u);
            if (o != null) a += o;
        } else {
            a += this.renderTokens(t[4], r, n, i);
        }
        return a;
    };
    h.prototype.renderInverted = function e(t, r, n, i) {
        var s = r.lookup(t[1]);
        // Use JavaScript's definition of falsy. Include empty arrays.
        // See https://github.com/janl/mustache.js/issues/186
                if (!s || m(s) && s.length === 0) return this.renderTokens(t[4], r, n, i);
    };
    h.prototype.renderPartial = function e(t, r, n, i) {
        if (!n) return;
        var s = c(n) ? n(t[1]) : n[t[1]];
        if (s != null) return this.renderTokens(this.parse(s, i), r, n, s);
    };
    h.prototype.unescapedValue = function e(t, r) {
        var n = r.lookup(t[1]);
        if (n != null) return n;
    };
    h.prototype.escapedValue = function e(t, r) {
        var n = r.lookup(t[1]);
        if (n != null) return x.escape(n);
    };
    h.prototype.rawValue = function e(t) {
        return t[1];
    };
    x.name = "mustache.js";
    x.version = "3.0.1";
    x.tags = [ "{{", "}}" ];
    // All high-level mustache.* functions use this writer.
        var v = new h();
    /**
   * Clears all cached templates in the default writer.
   */    x.clearCache = function e() {
        return v.clearCache();
    };
    /**
   * Parses and caches the given template in the default writer and returns the
   * array of tokens it contains. Doing this ahead of time avoids the need to
   * parse templates on the fly as they are rendered.
   */    x.parse = function e(t, r) {
        return v.parse(t, r);
    };
    /**
   * Renders the `template` with the given `view` and `partials` using the
   * default writer. If the optional `tags` argument is given here it must be an
   * array with two string values: the opening and closing tags used in the
   * template (e.g. [ "<%", "%>" ]). The default is to mustache.tags.
   */    x.render = function e(t, r, n, i) {
        if (typeof t !== "string") {
            throw new TypeError('Invalid template! Template should be a "string" ' + 'but "' + s(t) + '" was given as the first ' + "argument for mustache#render(template, view, partials)");
        }
        return v.render(t, r, n, i);
    };
    // This is here for backwards compatibility with 0.4.x.,
    /*eslint-disable */ // eslint wants camel cased function name
        x.to_html = function e(t, r, n, i) {
        /*eslint-enable*/
        var s = x.render(t, r, n);
        if (c(i)) {
            i(s);
        } else {
            return s;
        }
    };
    // Export the escaping function so that the user may override it.
    // See https://github.com/janl/mustache.js/issues/244
        x.escape = o;
    // Export these mainly for testing, but also for advanced usage.
        x.Scanner = A;
    x.Context = p;
    x.Writer = h;
    return x;
});
//# sourceMappingURL=mustache.min.js.map