!function(e) {
    function t(o) {
        if (n[o]) return n[o].exports;
        var r = n[o] = {
            exports: {},
            id: o,
            loaded: !1
        };
        return e[o].call(r.exports, r, r.exports, t), r.loaded = !0, r.exports;
    }
    var n = {};
    return t.m = e, t.c = n, t.p = "", t(0);
}([ function(e, t, n) {
    "use strict";
    var o = n(20), r = n(2), i = o, s = n(15), u = [ "# top comment", "", "foo bar", " indented value", "", "will disappear", "key value #comment" ].join("\n"), a = [ "# top comment", "", "foo moo", "indented value", "", "#key value #comment", "hooray value" ].join("\n");
    o.asyncTest("config_update", function() {
        i.expect(10);
        var e, t = r.defer(), n = function(n, o) {
            i.equal(o.foo.value, "moo", "value changed correctly"), i.equal("key" in o, !1, "setting with comment deleted correctly"), 
            i.equal("will" in o, !1, "setting without comment deleted correctly"), i.equal(o.hooray.value, "value", "value added correctly"), 
            i.equal(e._rawContent, a, "raw text for changed config is correct"), t.resolve();
        }, l = "cockpit_config_read", c = r.file(l);
        c.replace(u).always(function() {
            i.equal(this.state(), "resolved", "writing initial config didn't fail"), i.equal(c.path, l, "file has correct path"), 
            e = new s.ConfigFile(l), e.wait().always(function() {
                i.equal(this.state(), "resolved", "waiting for config didn't fail"), e.settings.foo.value = "moo", 
                delete e.settings.key, delete e.settings.will, e.settings.hooray = {
                    value: "value"
                }, e.addEventListener("kdumpConfigChanged", n), e.write(e.settings).always(function() {
                    i.equal(this.state(), "resolved", "writing to config didn't fail"), t.promise().done(function() {
                        i.equal(this.state(), "resolved", "waiting for config change didn't fail"), o.start();
                    });
                });
            });
        });
    }), window.setTimeout(function() {
        o.start();
    });
}, , function(e, t) {
    e.exports = cockpit;
}, , , , , , , , , , , , , function(e, t, n) {
    "use strict";
    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        };
    }
    function r(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var i = function() {
        function e(e, t) {
            for (var n = 0; n < t.length; n++) {
                var o = t[n];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), 
                Object.defineProperty(e, o.key, o);
            }
        }
        return function(t, n, o) {
            return n && e(t.prototype, n), o && e(t, o), t;
        };
    }(), s = n(2), u = o(s), a = function() {
        function e(t) {
            var n = this, o = !(arguments.length <= 1 || void 0 === arguments[1]) && arguments[1];
            r(this, e), this.filename = t, this._rawContent = void 0, this._lines = [], this._originalSettings = {}, 
            this._dataAvailable = u.default.defer(), this.settings = {}, u.default.event_target(this), 
            this._fileHandle = u.default.file(t, {
                superuser: o
            }), this._fileHandle.watch(function(e) {
                n._parseText(e);
            });
        }
        return i(e, [ {
            key: "close",
            value: function() {
                this._fileHandle && (this._fileHandle.remove(), this._fileHandle = void 0);
            }
        }, {
            key: "wait",
            value: function() {
                return this._dataAvailable.promise();
            }
        }, {
            key: "_parseText",
            value: function(e) {
                var t = this, n = !(arguments.length <= 1 || void 0 === arguments[1]) && arguments[1];
                return this._dataAvailable && this._dataAvailable.resolve(), e ? void (e != this._rawContent && (this._rawContent = e, 
                this._lines = e.split(/\r?\n/), this.settings = {}, this._lines.forEach(function(e, n) {
                    var o = e.trimLeft();
                    if (0 !== o.indexOf("#") && 0 !== o.length) {
                        var r = o.indexOf(" ");
                        if (r !== -1) {
                            var i = o.substring(0, r), s = o.substring(r + 1).trim(), u = s.indexOf("#"), a = void 0;
                            u !== -1 && (a = s.substring(u).trim(), s = s.substring(0, u).trim()), t.settings[i] = {
                                index: n,
                                value: s,
                                origLine: e,
                                comment: a
                            };
                        }
                    }
                }), this._originalSettings = {}, Object.keys(this.settings).forEach(function(e) {
                    t._originalSettings[e] = u.default.extend({}, t.settings[e]);
                }), n || this.dispatchEvent("kdumpConfigChanged", this.settings))) : (this._originalSettings = null, 
                this.settings = null, void (n || this.dispatchEvent("kdumpConfigChanged", this.settings)));
            }
        }, {
            key: "_generateConfig",
            value: function(e) {
                var t = this, n = this._lines.slice(0), o = [];
                return Object.keys(this._originalSettings).forEach(function(r) {
                    if (!(r in e)) {
                        var i = t._originalSettings[r];
                        void 0 !== i.comment ? n[i.index] = "#" + i.origLine : o.push(i.index);
                    }
                }), Object.keys(e).forEach(function(o) {
                    var r = e[o], i = o + " " + r.value;
                    if (r.comment && (i = i + " " + r.comment), !(o in t._originalSettings)) return void n.push(i);
                    var s = t._originalSettings[o];
                    n[s.index] = i;
                }), o.sort().reverse().forEach(function(e) {
                    n.splice(e, 1);
                }), n.join("\n");
            }
        }, {
            key: "write",
            value: function(e) {
                var t = this;
                return this._fileHandle.modify(function(n) {
                    return t._parseText(n, !0), t._generateConfig(e);
                });
            }
        } ]), e;
    }();
    t.ConfigFile = a;
}, , , , , function(e, t, n) {
    "use strict";
    !function() {
        window.QUnit = n(21), window.qunitTap = n(23), n(24), n(26), e.exports = window.QUnit;
    }();
}, function(e, t, n) {
    (function(t) {
        /*!
	 * QUnit 1.14.0
	 * http://qunitjs.com/
	 *
	 * Copyright 2013 jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2014-01-31T16:40Z
	 */
        !function(t) {
            function n() {
                k.autorun = !0, k.previousModule && y("moduleDone", q, {
                    name: k.previousModule,
                    failed: k.moduleStats.bad,
                    passed: k.moduleStats.all - k.moduleStats.bad,
                    total: k.moduleStats.all
                }), delete k.previousModule;
                var e, n, o = b("qunit-banner"), r = b("qunit-tests"), i = +new L() - k.started, s = k.stats.all - k.stats.bad, u = [ "Tests completed in ", i, " milliseconds.<br/>", "<span class='passed'>", s, "</span> assertions of <span class='total'>", k.stats.all, "</span> passed, <span class='failed'>", k.stats.bad, "</span> failed." ].join("");
                if (o && (o.className = k.stats.bad ? "qunit-fail" : "qunit-pass"), r && (b("qunit-testresult").innerHTML = u), 
                k.altertitle && U.document && document.title && (document.title = [ k.stats.bad ? "✖" : "✔", document.title.replace(/^[\u2714\u2716] /i, "") ].join(" ")), 
                k.reorder && U.sessionStorage && 0 === k.stats.bad) for (e = 0; e < sessionStorage.length; e++) n = sessionStorage.key(e++), 
                0 === n.indexOf("qunit-test-") && sessionStorage.removeItem(n);
                k.scrolltop && t.scrollTo && t.scrollTo(0, 0), y("done", q, {
                    failed: k.stats.bad,
                    passed: s,
                    total: k.stats.all,
                    runtime: i
                });
            }
            function o(e) {
                var t, n = k.filter && k.filter.toLowerCase(), r = k.module && k.module.toLowerCase(), i = (e.module + ": " + e.testName).toLowerCase();
                return e.callback && e.callback.validTest === o ? (delete e.callback.validTest, 
                !0) : !(k.testNumber.length > 0 && x(e.testNumber, k.testNumber) < 0) && (!(r && (!e.module || e.module.toLowerCase() !== r)) && (!n || (t = "!" !== n.charAt(0), 
                t || (n = n.slice(1)), i.indexOf(n) !== -1 ? t : !t)));
            }
            function r(e, t) {
                t = void 0 === t ? 3 : t;
                var n, o, r;
                if (e.stacktrace) return e.stacktrace.split("\n")[t + 3];
                if (e.stack) {
                    if (n = e.stack.split("\n"), /^error$/i.test(n[0]) && n.shift(), C) {
                        for (o = [], r = t; r < n.length && n[r].indexOf(C) === -1; r++) o.push(n[r]);
                        if (o.length) return o.join("\n");
                    }
                    return n[t];
                }
                if (e.sourceURL) {
                    if (/qunit.js$/.test(e.sourceURL)) return;
                    return e.sourceURL + ":" + e.line;
                }
            }
            function i(e) {
                try {
                    throw new Error();
                } catch (t) {
                    return r(t, e);
                }
            }
            function s(e) {
                return e ? (e += "", e.replace(/['"<>&]/g, function(e) {
                    switch (e) {
                      case "'":
                        return "&#039;";

                      case '"':
                        return "&quot;";

                      case "<":
                        return "&lt;";

                      case ">":
                        return "&gt;";

                      case "&":
                        return "&amp;";
                    }
                })) : "";
            }
            function u(e, t) {
                k.queue.push(e), k.autorun && !k.blocking && a(t);
            }
            function a(e) {
                function t() {
                    a(e);
                }
                var o = new L().getTime();
                for (k.depth = k.depth ? k.depth + 1 : 1; k.queue.length && !k.blocking; ) {
                    if (!(!U.setTimeout || k.updateRate <= 0 || new L().getTime() - o < k.updateRate)) {
                        M(t, 13);
                        break;
                    }
                    k.queue.shift()();
                }
                k.depth--, !e || k.blocking || k.queue.length || 0 !== k.depth || n();
            }
            function l() {
                if (k.pollution = [], k.noglobals) for (var e in t) if (O.call(t, e)) {
                    if (/^qunit-test-output/.test(e)) continue;
                    k.pollution.push(e);
                }
            }
            function c() {
                var e, t, n = k.pollution;
                l(), e = d(k.pollution, n), e.length > 0 && q.pushFailure("Introduced global variable(s): " + e.join(", ")), 
                t = d(n, k.pollution), t.length > 0 && q.pushFailure("Deleted global variable(s): " + t.join(", "));
            }
            function d(e, t) {
                var n, o, r = e.slice();
                for (n = 0; n < r.length; n++) for (o = 0; o < t.length; o++) if (r[n] === t[o]) {
                    r.splice(n, 1), n--;
                    break;
                }
                return r;
            }
            function f(e, n) {
                for (var o in n) O.call(n, o) && ("constructor" === o && e === t || (void 0 === n[o] ? delete e[o] : e[o] = n[o]));
                return e;
            }
            function p(e, t, n) {
                if (e.addEventListener) e.addEventListener(t, n, !1); else {
                    if (!e.attachEvent) throw new Error("addEvent() was called in a context without event listener support");
                    e.attachEvent("on" + t, n);
                }
            }
            function h(e, t, n) {
                for (var o = e.length; o--; ) p(e[o], t, n);
            }
            function m(e, t) {
                return (" " + e.className + " ").indexOf(" " + t + " ") > -1;
            }
            function g(e, t) {
                m(e, t) || (e.className += (e.className ? " " : "") + t);
            }
            function v(e, t) {
                for (var n = " " + e.className + " "; n.indexOf(" " + t + " ") > -1; ) n = n.replace(" " + t + " ", " ");
                e.className = "function" == typeof n.trim ? n.trim() : n.replace(/^\s+|\s+$/g, "");
            }
            function b(e) {
                return U.document && document.getElementById && document.getElementById(e);
            }
            function w(e) {
                return function(t) {
                    k[e].push(t);
                };
            }
            function y(e, t, n) {
                var o, r;
                if (q.hasOwnProperty(e)) q[e].call(t, n); else for (r = k[e], o = 0; o < r.length; o++) r[o].call(t, n);
            }
            function x(e, t) {
                if (t.indexOf) return t.indexOf(e);
                for (var n = 0, o = t.length; n < o; n++) if (t[n] === e) return n;
                return -1;
            }
            function T(e) {
                f(this, e), this.assertions = [], this.testNumber = ++T.count;
            }
            var q, E, k, N, S = 0, C = (i(0) || "").replace(/(:\d+)+\)?/, "").replace(/.+\//, ""), j = Object.prototype.toString, O = Object.prototype.hasOwnProperty, L = t.Date, M = t.setTimeout, _ = t.clearTimeout, U = {
                document: "undefined" != typeof t.document,
                setTimeout: "undefined" != typeof t.setTimeout,
                sessionStorage: function() {
                    var e = "qunit-test-string";
                    try {
                        return sessionStorage.setItem(e, e), sessionStorage.removeItem(e), !0;
                    } catch (e) {
                        return !1;
                    }
                }()
            }, H = function(e) {
                var t, n, o = e.toString();
                return "[object" === o.substring(0, 7) ? (t = e.name ? e.name.toString() : "Error", 
                n = e.message ? e.message.toString() : "", t && n ? t + ": " + n : t ? t : n ? n : "Error") : o;
            }, D = function(e) {
                var t, n, o = q.is("array", e) ? [] : {};
                for (t in e) O.call(e, t) && (n = e[t], o[t] = n === Object(n) ? D(n) : n);
                return o;
            };
            q = {
                module: function(e, t) {
                    k.currentModule = e, k.currentModuleTestEnvironment = t, k.modules[e] = !0;
                },
                asyncTest: function(e, t, n) {
                    2 === arguments.length && (n = t, t = null), q.test(e, t, n, !0);
                },
                test: function(e, t, n, r) {
                    var u, a = "<span class='test-name'>" + s(e) + "</span>";
                    2 === arguments.length && (n = t, t = null), k.currentModule && (a = "<span class='module-name'>" + s(k.currentModule) + "</span>: " + a), 
                    u = new T({
                        nameHtml: a,
                        testName: e,
                        expected: t,
                        async: r,
                        callback: n,
                        module: k.currentModule,
                        moduleTestEnvironment: k.currentModuleTestEnvironment,
                        stack: i(2)
                    }), o(u) && u.queue();
                },
                expect: function(e) {
                    return 1 !== arguments.length ? k.current.expected : void (k.current.expected = e);
                },
                start: function(e) {
                    return void 0 === k.semaphore ? void q.begin(function() {
                        M(function() {
                            q.start(e);
                        });
                    }) : (k.semaphore -= e || 1, k.semaphore > 0 ? void 0 : k.semaphore < 0 ? (k.semaphore = 0, 
                    void q.pushFailure("Called start() while already started (QUnit.config.semaphore was 0 already)", null, i(2))) : void (U.setTimeout ? M(function() {
                        k.semaphore > 0 || (k.timeout && _(k.timeout), k.blocking = !1, a(!0));
                    }, 13) : (k.blocking = !1, a(!0))));
                },
                stop: function(e) {
                    k.semaphore += e || 1, k.blocking = !0, k.testTimeout && U.setTimeout && (_(k.timeout), 
                    k.timeout = M(function() {
                        q.ok(!1, "Test timed out"), k.semaphore = 1, q.start();
                    }, k.testTimeout));
                }
            }, function() {
                function e() {}
                e.prototype = q, q = new e(), q.constructor = e;
            }(), k = {
                queue: [],
                blocking: !0,
                hidepassed: !1,
                reorder: !0,
                altertitle: !0,
                scrolltop: !0,
                requireExpects: !1,
                urlConfig: [ {
                    id: "noglobals",
                    label: "Check for Globals",
                    tooltip: "Enabling this will test if any test introduces new properties on the `window` object. Stored as query-strings."
                }, {
                    id: "notrycatch",
                    label: "No try-catch",
                    tooltip: "Enabling this will run tests outside of a try-catch block. Makes debugging exceptions in IE reasonable. Stored as query-strings."
                } ],
                modules: {},
                begin: [],
                done: [],
                log: [],
                testStart: [],
                testDone: [],
                moduleStart: [],
                moduleDone: []
            }, function() {
                var e, n, o = t.location || {
                    search: "",
                    protocol: "file:"
                }, r = o.search.slice(1).split("&"), i = r.length, s = {};
                if (r[0]) for (e = 0; e < i; e++) n = r[e].split("="), n[0] = decodeURIComponent(n[0]), 
                n[1] = !n[1] || decodeURIComponent(n[1]), s[n[0]] ? s[n[0]] = [].concat(s[n[0]], n[1]) : s[n[0]] = n[1];
                if (q.urlParams = s, k.filter = s.filter, k.module = s.module, k.testNumber = [], 
                s.testNumber) for (s.testNumber = [].concat(s.testNumber), e = 0; e < s.testNumber.length; e++) n = s.testNumber[e], 
                k.testNumber.push(parseInt(n, 10));
                q.isLocal = "file:" === o.protocol;
            }(), f(q, {
                config: k,
                init: function() {
                    f(k, {
                        stats: {
                            all: 0,
                            bad: 0
                        },
                        moduleStats: {
                            all: 0,
                            bad: 0
                        },
                        started: +new L(),
                        updateRate: 1e3,
                        blocking: !1,
                        autostart: !0,
                        autorun: !1,
                        filter: "",
                        queue: [],
                        semaphore: 1
                    });
                    var e, t, n, o = b("qunit");
                    o && (o.innerHTML = "<h1 id='qunit-header'>" + s(document.title) + "</h1><h2 id='qunit-banner'></h2><div id='qunit-testrunner-toolbar'></div><h2 id='qunit-userAgent'></h2><ol id='qunit-tests'></ol>"), 
                    e = b("qunit-tests"), t = b("qunit-banner"), n = b("qunit-testresult"), e && (e.innerHTML = ""), 
                    t && (t.className = ""), n && n.parentNode.removeChild(n), e && (n = document.createElement("p"), 
                    n.id = "qunit-testresult", n.className = "result", e.parentNode.insertBefore(n, e), 
                    n.innerHTML = "Running...<br/>&nbsp;");
                },
                reset: function() {
                    var e = b("qunit-fixture");
                    e && (e.innerHTML = k.fixture);
                },
                is: function(e, t) {
                    return q.objectType(t) === e;
                },
                objectType: function(e) {
                    if ("undefined" == typeof e) return "undefined";
                    if (null === e) return "null";
                    var t = j.call(e).match(/^\[object\s(.*)\]$/), n = t && t[1] || "";
                    switch (n) {
                      case "Number":
                        return isNaN(e) ? "nan" : "number";

                      case "String":
                      case "Boolean":
                      case "Array":
                      case "Date":
                      case "RegExp":
                      case "Function":
                        return n.toLowerCase();
                    }
                    return "object" == typeof e ? "object" : void 0;
                },
                push: function(e, t, n, o) {
                    if (!k.current) throw new Error("assertion outside test context, was " + i());
                    var r, u, a = {
                        module: k.current.module,
                        name: k.current.testName,
                        result: e,
                        message: o,
                        actual: t,
                        expected: n
                    };
                    o = s(o) || (e ? "okay" : "failed"), o = "<span class='test-message'>" + o + "</span>", 
                    r = o, e || (n = s(q.jsDump.parse(n)), t = s(q.jsDump.parse(t)), r += "<table><tr class='test-expected'><th>Expected: </th><td><pre>" + n + "</pre></td></tr>", 
                    t !== n && (r += "<tr class='test-actual'><th>Result: </th><td><pre>" + t + "</pre></td></tr>", 
                    r += "<tr class='test-diff'><th>Diff: </th><td><pre>" + q.diff(n, t) + "</pre></td></tr>"), 
                    u = i(), u && (a.source = u, r += "<tr class='test-source'><th>Source: </th><td><pre>" + s(u) + "</pre></td></tr>"), 
                    r += "</table>"), y("log", q, a), k.current.assertions.push({
                        result: !!e,
                        message: r
                    });
                },
                pushFailure: function(e, t, n) {
                    if (!k.current) throw new Error("pushFailure() assertion outside test context, was " + i(2));
                    var o, r = {
                        module: k.current.module,
                        name: k.current.testName,
                        result: !1,
                        message: e
                    };
                    e = s(e) || "error", e = "<span class='test-message'>" + e + "</span>", o = e, o += "<table>", 
                    n && (o += "<tr class='test-actual'><th>Result: </th><td><pre>" + s(n) + "</pre></td></tr>"), 
                    t && (r.source = t, o += "<tr class='test-source'><th>Source: </th><td><pre>" + s(t) + "</pre></td></tr>"), 
                    o += "</table>", y("log", q, r), k.current.assertions.push({
                        result: !1,
                        message: o
                    });
                },
                url: function(e) {
                    e = f(f({}, q.urlParams), e);
                    var n, o = "?";
                    for (n in e) O.call(e, n) && (o += encodeURIComponent(n) + "=" + encodeURIComponent(e[n]) + "&");
                    return t.location.protocol + "//" + t.location.host + t.location.pathname + o.slice(0, -1);
                },
                extend: f,
                id: b,
                addEvent: p,
                addClass: g,
                hasClass: m,
                removeClass: v
            }), f(q.constructor.prototype, {
                begin: w("begin"),
                done: w("done"),
                log: w("log"),
                testStart: w("testStart"),
                testDone: w("testDone"),
                moduleStart: w("moduleStart"),
                moduleDone: w("moduleDone")
            }), U.document && "complete" !== document.readyState || (k.autorun = !0), q.load = function() {
                y("begin", q, {});
                var e, n, o, r, i, u, a, l, c, d, m, g, v, w, x = 0, T = [], E = "", N = "", S = f({}, k);
                for (q.init(), f(k, S), k.blocking = !1, u = k.urlConfig.length, o = 0; o < u; o++) if (d = k.urlConfig[o], 
                "string" == typeof d && (d = {
                    id: d,
                    label: d
                }), k[d.id] = q.urlParams[d.id], d.value && "string" != typeof d.value) {
                    if (N += "<label for='qunit-urlconfig-" + s(d.id) + "' title='" + s(d.tooltip) + "'>" + d.label + ": </label><select id='qunit-urlconfig-" + s(d.id) + "' name='" + s(d.id) + "' title='" + s(d.tooltip) + "'><option></option>", 
                    m = !1, q.is("array", d.value)) for (r = 0; r < d.value.length; r++) N += "<option value='" + s(d.value[r]) + "'" + (k[d.id] === d.value[r] ? (m = !0) && " selected='selected'" : "") + ">" + s(d.value[r]) + "</option>"; else for (r in d.value) O.call(d.value, r) && (N += "<option value='" + s(r) + "'" + (k[d.id] === r ? (m = !0) && " selected='selected'" : "") + ">" + s(d.value[r]) + "</option>");
                    k[d.id] && !m && (N += "<option value='" + s(k[d.id]) + "' selected='selected' disabled='disabled'>" + s(k[d.id]) + "</option>"), 
                    N += "</select>";
                } else N += "<input id='qunit-urlconfig-" + s(d.id) + "' name='" + s(d.id) + "' type='checkbox'" + (d.value ? " value='" + s(d.value) + "'" : "") + (k[d.id] ? " checked='checked'" : "") + " title='" + s(d.tooltip) + "'><label for='qunit-urlconfig-" + s(d.id) + "' title='" + s(d.tooltip) + "'>" + d.label + "</label>";
                for (o in k.modules) k.modules.hasOwnProperty(o) && T.push(o);
                for (x = T.length, T.sort(function(e, t) {
                    return e.localeCompare(t);
                }), E += "<label for='qunit-modulefilter'>Module: </label><select id='qunit-modulefilter' name='modulefilter'><option value='' " + (void 0 === k.module ? "selected='selected'" : "") + ">< All Modules ></option>", 
                o = 0; o < x; o++) E += "<option value='" + s(encodeURIComponent(T[o])) + "' " + (k.module === T[o] ? "selected='selected'" : "") + ">" + s(T[o]) + "</option>";
                E += "</select>", w = b("qunit-userAgent"), w && (w.innerHTML = navigator.userAgent), 
                e = b("qunit-header"), e && (e.innerHTML = "<a href='" + q.url({
                    filter: void 0,
                    module: void 0,
                    testNumber: void 0
                }) + "'>" + e.innerHTML + "</a> "), c = b("qunit-testrunner-toolbar"), c && (n = document.createElement("input"), 
                n.type = "checkbox", n.id = "qunit-filter-pass", p(n, "click", function() {
                    var e, t = b("qunit-tests");
                    n.checked ? t.className = t.className + " hidepass" : (e = " " + t.className.replace(/[\n\t\r]/g, " ") + " ", 
                    t.className = e.replace(/ hidepass /, " ")), U.sessionStorage && (n.checked ? sessionStorage.setItem("qunit-filter-passed-tests", "true") : sessionStorage.removeItem("qunit-filter-passed-tests"));
                }), (k.hidepassed || U.sessionStorage && sessionStorage.getItem("qunit-filter-passed-tests")) && (n.checked = !0, 
                l = b("qunit-tests"), l.className = l.className + " hidepass"), c.appendChild(n), 
                i = document.createElement("label"), i.setAttribute("for", "qunit-filter-pass"), 
                i.setAttribute("title", "Only show tests and assertions that fail. Stored in sessionStorage."), 
                i.innerHTML = "Hide passed tests", c.appendChild(i), g = document.createElement("span"), 
                g.innerHTML = N, h(g.getElementsByTagName("input"), "click", function(e) {
                    var n = {}, o = e.target || e.srcElement;
                    n[o.name] = o.checked ? o.defaultValue || !0 : void 0, t.location = q.url(n);
                }), h(g.getElementsByTagName("select"), "change", function(e) {
                    var n = {}, o = e.target || e.srcElement;
                    n[o.name] = o.options[o.selectedIndex].value || void 0, t.location = q.url(n);
                }), c.appendChild(g), x > 1 && (v = document.createElement("span"), v.setAttribute("id", "qunit-modulefilter-container"), 
                v.innerHTML = E, p(v.lastChild, "change", function() {
                    var e = v.getElementsByTagName("select")[0], n = decodeURIComponent(e.options[e.selectedIndex].value);
                    t.location = q.url({
                        module: "" === n ? void 0 : n,
                        filter: void 0,
                        testNumber: void 0
                    });
                }), c.appendChild(v))), a = b("qunit-fixture"), a && (k.fixture = a.innerHTML), 
                k.autostart && q.start();
            }, U.document && p(t, "load", q.load), N = t.onerror, t.onerror = function(e, t, n) {
                var r = !1;
                if (N && (r = N(e, t, n)), r !== !0) {
                    if (q.config.current) {
                        if (q.config.current.ignoreGlobalErrors) return !0;
                        q.pushFailure(e, t + ":" + n);
                    } else q.test("global failure", f(function() {
                        q.pushFailure(e, t + ":" + n);
                    }, {
                        validTest: o
                    }));
                    return !1;
                }
                return r;
            }, T.count = 0, T.prototype = {
                init: function() {
                    var e, t, n, o = b("qunit-tests");
                    o && (t = document.createElement("strong"), t.innerHTML = this.nameHtml, e = document.createElement("a"), 
                    e.innerHTML = "Rerun", e.href = q.url({
                        testNumber: this.testNumber
                    }), n = document.createElement("li"), n.appendChild(t), n.appendChild(e), n.className = "running", 
                    n.id = this.id = "qunit-test-output" + S++, o.appendChild(n));
                },
                setup: function() {
                    if (this.module === k.previousModule && O.call(k, "previousModule") || (O.call(k, "previousModule") && y("moduleDone", q, {
                        name: k.previousModule,
                        failed: k.moduleStats.bad,
                        passed: k.moduleStats.all - k.moduleStats.bad,
                        total: k.moduleStats.all
                    }), k.previousModule = this.module, k.moduleStats = {
                        all: 0,
                        bad: 0
                    }, y("moduleStart", q, {
                        name: this.module
                    })), k.current = this, this.testEnvironment = f({
                        setup: function() {},
                        teardown: function() {}
                    }, this.moduleTestEnvironment), this.started = +new L(), y("testStart", q, {
                        name: this.testName,
                        module: this.module
                    }), q.current_testEnvironment = this.testEnvironment, k.pollution || l(), k.notrycatch) return void this.testEnvironment.setup.call(this.testEnvironment, q.assert);
                    try {
                        this.testEnvironment.setup.call(this.testEnvironment, q.assert);
                    } catch (e) {
                        q.pushFailure("Setup failed on " + this.testName + ": " + (e.message || e), r(e, 1));
                    }
                },
                run: function() {
                    k.current = this;
                    var e = b("qunit-testresult");
                    if (e && (e.innerHTML = "Running: <br/>" + this.nameHtml), this.async && q.stop(), 
                    this.callbackStarted = +new L(), k.notrycatch) return this.callback.call(this.testEnvironment, q.assert), 
                    void (this.callbackRuntime = +new L() - this.callbackStarted);
                    try {
                        this.callback.call(this.testEnvironment, q.assert), this.callbackRuntime = +new L() - this.callbackStarted;
                    } catch (e) {
                        this.callbackRuntime = +new L() - this.callbackStarted, q.pushFailure("Died on test #" + (this.assertions.length + 1) + " " + this.stack + ": " + (e.message || e), r(e, 0)), 
                        l(), k.blocking && q.start();
                    }
                },
                teardown: function() {
                    if (k.current = this, k.notrycatch) return "undefined" == typeof this.callbackRuntime && (this.callbackRuntime = +new L() - this.callbackStarted), 
                    void this.testEnvironment.teardown.call(this.testEnvironment, q.assert);
                    try {
                        this.testEnvironment.teardown.call(this.testEnvironment, q.assert);
                    } catch (e) {
                        q.pushFailure("Teardown failed on " + this.testName + ": " + (e.message || e), r(e, 1));
                    }
                    c();
                },
                finish: function() {
                    k.current = this, k.requireExpects && null === this.expected ? q.pushFailure("Expected number of assertions to be defined, but expect() was not called.", this.stack) : null !== this.expected && this.expected !== this.assertions.length ? q.pushFailure("Expected " + this.expected + " assertions, but " + this.assertions.length + " were run", this.stack) : null !== this.expected || this.assertions.length || q.pushFailure("Expected at least one assertion, but none were run - call expect(0) to accept zero assertions.", this.stack);
                    var e, n, o, r, i, s, u, a = this, l = 0, c = 0, d = b("qunit-tests");
                    if (this.runtime = +new L() - this.started, k.stats.all += this.assertions.length, 
                    k.moduleStats.all += this.assertions.length, d) {
                        for (u = document.createElement("ol"), u.className = "qunit-assert-list", e = 0; e < this.assertions.length; e++) n = this.assertions[e], 
                        s = document.createElement("li"), s.className = n.result ? "pass" : "fail", s.innerHTML = n.message || (n.result ? "okay" : "failed"), 
                        u.appendChild(s), n.result ? l++ : (c++, k.stats.bad++, k.moduleStats.bad++);
                        q.config.reorder && U.sessionStorage && (c ? sessionStorage.setItem("qunit-test-" + this.module + "-" + this.testName, c) : sessionStorage.removeItem("qunit-test-" + this.module + "-" + this.testName)), 
                        0 === c && g(u, "qunit-collapsed"), r = document.createElement("strong"), r.innerHTML = this.nameHtml + " <b class='counts'>(<b class='failed'>" + c + "</b>, <b class='passed'>" + l + "</b>, " + this.assertions.length + ")</b>", 
                        p(r, "click", function() {
                            var e = r.parentNode.lastChild, t = m(e, "qunit-collapsed");
                            (t ? v : g)(e, "qunit-collapsed");
                        }), p(r, "dblclick", function(e) {
                            var n = e && e.target ? e.target : t.event.srcElement;
                            "span" !== n.nodeName.toLowerCase() && "b" !== n.nodeName.toLowerCase() || (n = n.parentNode), 
                            t.location && "strong" === n.nodeName.toLowerCase() && (t.location = q.url({
                                testNumber: a.testNumber
                            }));
                        }), i = document.createElement("span"), i.className = "runtime", i.innerHTML = this.runtime + " ms", 
                        s = b(this.id), s.className = c ? "fail" : "pass", s.removeChild(s.firstChild), 
                        o = s.firstChild, s.appendChild(r), s.appendChild(o), s.appendChild(i), s.appendChild(u);
                    } else for (e = 0; e < this.assertions.length; e++) this.assertions[e].result || (c++, 
                    k.stats.bad++, k.moduleStats.bad++);
                    y("testDone", q, {
                        name: this.testName,
                        module: this.module,
                        failed: c,
                        passed: this.assertions.length - c,
                        total: this.assertions.length,
                        runtime: this.runtime,
                        duration: this.runtime
                    }), q.reset(), k.current = void 0;
                },
                queue: function() {
                    function e() {
                        u(function() {
                            n.setup();
                        }), u(function() {
                            n.run();
                        }), u(function() {
                            n.teardown();
                        }), u(function() {
                            n.finish();
                        });
                    }
                    var t, n = this;
                    u(function() {
                        n.init();
                    }), t = q.config.reorder && U.sessionStorage && +sessionStorage.getItem("qunit-test-" + this.module + "-" + this.testName), 
                    t ? e() : u(e, !0);
                }
            }, E = q.assert = {
                ok: function(e, t) {
                    if (!k.current) throw new Error("ok() assertion outside test context, was " + i(2));
                    e = !!e, t = t || (e ? "okay" : "failed");
                    var n, o = {
                        module: k.current.module,
                        name: k.current.testName,
                        result: e,
                        message: t
                    };
                    t = "<span class='test-message'>" + s(t) + "</span>", e || (n = i(2), n && (o.source = n, 
                    t += "<table><tr class='test-source'><th>Source: </th><td><pre>" + s(n) + "</pre></td></tr></table>")), 
                    y("log", q, o), k.current.assertions.push({
                        result: e,
                        message: t
                    });
                },
                equal: function(e, t, n) {
                    q.push(t == e, e, t, n);
                },
                notEqual: function(e, t, n) {
                    q.push(t != e, e, t, n);
                },
                propEqual: function(e, t, n) {
                    e = D(e), t = D(t), q.push(q.equiv(e, t), e, t, n);
                },
                notPropEqual: function(e, t, n) {
                    e = D(e), t = D(t), q.push(!q.equiv(e, t), e, t, n);
                },
                deepEqual: function(e, t, n) {
                    q.push(q.equiv(e, t), e, t, n);
                },
                notDeepEqual: function(e, t, n) {
                    q.push(!q.equiv(e, t), e, t, n);
                },
                strictEqual: function(e, t, n) {
                    q.push(t === e, e, t, n);
                },
                notStrictEqual: function(e, t, n) {
                    q.push(t !== e, e, t, n);
                },
                throws: function(e, t, n) {
                    var o, r = t, i = !1;
                    n || "string" != typeof t || (n = t, t = null), k.current.ignoreGlobalErrors = !0;
                    try {
                        e.call(k.current.testEnvironment);
                    } catch (e) {
                        o = e;
                    }
                    k.current.ignoreGlobalErrors = !1, o ? (t ? t instanceof Error ? i = o instanceof Error && o.name === t.name && o.message === t.message : "regexp" === q.objectType(t) ? i = t.test(H(o)) : "string" === q.objectType(t) ? i = t === H(o) : o instanceof t ? i = !0 : t.call({}, o) === !0 && (r = null, 
                    i = !0) : (i = !0, r = null), q.push(i, o, r, n)) : q.pushFailure(n, null, "No exception was thrown.");
                }
            }, f(q.constructor.prototype, E), q.constructor.prototype.raises = function() {
                q.push(!1, !1, !1, "QUnit.raises has been deprecated since 2012 (fad3c1ea), use QUnit.throws instead");
            }, q.constructor.prototype.equals = function() {
                q.push(!1, !1, !1, "QUnit.equals has been deprecated since 2009 (e88049a0), use QUnit.equal instead");
            }, q.constructor.prototype.same = function() {
                q.push(!1, !1, !1, "QUnit.same has been deprecated since 2009 (e88049a0), use QUnit.deepEqual instead");
            }, q.equiv = function() {
                function e(e, t, n) {
                    var o = q.objectType(e);
                    if (o) return "function" === q.objectType(t[o]) ? t[o].apply(t, n) : t[o];
                }
                var t, n = [], o = [], r = [], i = Object.getPrototypeOf || function(e) {
                    return e.__proto__;
                }, s = function() {
                    function e(e, t) {
                        return e instanceof t.constructor || t instanceof e.constructor ? t == e : t === e;
                    }
                    return {
                        string: e,
                        boolean: e,
                        number: e,
                        null: e,
                        undefined: e,
                        nan: function(e) {
                            return isNaN(e);
                        },
                        date: function(e, t) {
                            return "date" === q.objectType(e) && t.valueOf() === e.valueOf();
                        },
                        regexp: function(e, t) {
                            return "regexp" === q.objectType(e) && t.source === e.source && t.global === e.global && t.ignoreCase === e.ignoreCase && t.multiline === e.multiline && t.sticky === e.sticky;
                        },
                        function: function() {
                            var e = n[n.length - 1];
                            return e !== Object && "undefined" != typeof e;
                        },
                        array: function(e, n) {
                            var i, s, u, a, l, c;
                            if ("array" !== q.objectType(e)) return !1;
                            if (u = n.length, u !== e.length) return !1;
                            for (o.push(n), r.push(e), i = 0; i < u; i++) {
                                for (a = !1, s = 0; s < o.length; s++) if (l = o[s] === n[i], c = r[s] === e[i], 
                                l || c) {
                                    if (!(n[i] === e[i] || l && c)) return o.pop(), r.pop(), !1;
                                    a = !0;
                                }
                                if (!a && !t(n[i], e[i])) return o.pop(), r.pop(), !1;
                            }
                            return o.pop(), r.pop(), !0;
                        },
                        object: function(e, s) {
                            var u, a, l, c, d, f = !0, p = [], h = [];
                            if (s.constructor !== e.constructor && !(null === i(s) && i(e) === Object.prototype || null === i(e) && i(s) === Object.prototype)) return !1;
                            n.push(s.constructor), o.push(s), r.push(e);
                            for (u in s) {
                                for (l = !1, a = 0; a < o.length; a++) if (c = o[a] === s[u], d = r[a] === e[u], 
                                c || d) {
                                    if (!(s[u] === e[u] || c && d)) {
                                        f = !1;
                                        break;
                                    }
                                    l = !0;
                                }
                                if (p.push(u), !l && !t(s[u], e[u])) {
                                    f = !1;
                                    break;
                                }
                            }
                            o.pop(), r.pop(), n.pop();
                            for (u in e) h.push(u);
                            return f && t(p.sort(), h.sort());
                        }
                    };
                }();
                return t = function() {
                    var n = [].slice.apply(arguments);
                    return n.length < 2 || function(t, n) {
                        return t === n || null !== t && null !== n && "undefined" != typeof t && "undefined" != typeof n && q.objectType(t) === q.objectType(n) && e(t, s, [ n, t ]);
                    }(n[0], n[1]) && t.apply(this, n.splice(1, n.length - 1));
                };
            }(), q.jsDump = function() {
                function e(e) {
                    return '"' + e.toString().replace(/"/g, '\\"') + '"';
                }
                function t(e) {
                    return e + "";
                }
                function n(e, t, n) {
                    var o = i.separator(), r = i.indent(), s = i.indent(1);
                    return t.join && (t = t.join("," + o + s)), t ? [ e, s + t, r + n ].join(o) : e + n;
                }
                function o(e, t) {
                    var o = e.length, r = new Array(o);
                    for (this.up(); o--; ) r[o] = this.parse(e[o], void 0, t);
                    return this.down(), n("[", r, "]");
                }
                var r = /^function (\w+)/, i = {
                    parse: function(e, t, n) {
                        n = n || [];
                        var o, r, i = this.parsers[t || this.typeOf(e)];
                        return t = typeof i, o = x(e, n), o !== -1 ? "recursion(" + (o - n.length) + ")" : "function" === t ? (n.push(e), 
                        r = i.call(this, e, n), n.pop(), r) : "string" === t ? i : this.parsers.error;
                    },
                    typeOf: function(e) {
                        var t;
                        return t = null === e ? "null" : "undefined" == typeof e ? "undefined" : q.is("regexp", e) ? "regexp" : q.is("date", e) ? "date" : q.is("function", e) ? "function" : void 0 !== typeof e.setInterval && "undefined" != typeof e.document && "undefined" == typeof e.nodeType ? "window" : 9 === e.nodeType ? "document" : e.nodeType ? "node" : "[object Array]" === j.call(e) || "number" == typeof e.length && "undefined" != typeof e.item && (e.length ? e.item(0) === e[0] : null === e.item(0) && "undefined" == typeof e[0]) ? "array" : e.constructor === Error.prototype.constructor ? "error" : typeof e;
                    },
                    separator: function() {
                        return this.multiline ? this.HTML ? "<br />" : "\n" : this.HTML ? "&nbsp;" : " ";
                    },
                    indent: function(e) {
                        if (!this.multiline) return "";
                        var t = this.indentChar;
                        return this.HTML && (t = t.replace(/\t/g, "   ").replace(/ /g, "&nbsp;")), new Array(this.depth + (e || 0)).join(t);
                    },
                    up: function(e) {
                        this.depth += e || 1;
                    },
                    down: function(e) {
                        this.depth -= e || 1;
                    },
                    setParser: function(e, t) {
                        this.parsers[e] = t;
                    },
                    quote: e,
                    literal: t,
                    join: n,
                    depth: 1,
                    parsers: {
                        window: "[Window]",
                        document: "[Document]",
                        error: function(e) {
                            return 'Error("' + e.message + '")';
                        },
                        unknown: "[Unknown]",
                        null: "null",
                        undefined: "undefined",
                        function: function(e) {
                            var t = "function", o = "name" in e ? e.name : (r.exec(e) || [])[1];
                            return o && (t += " " + o), t += "( ", t = [ t, q.jsDump.parse(e, "functionArgs"), "){" ].join(""), 
                            n(t, q.jsDump.parse(e, "functionCode"), "}");
                        },
                        array: o,
                        nodelist: o,
                        arguments: o,
                        object: function(e, t) {
                            var o, r, i, s, u = [];
                            q.jsDump.up(), o = [];
                            for (r in e) o.push(r);
                            for (o.sort(), s = 0; s < o.length; s++) r = o[s], i = e[r], u.push(q.jsDump.parse(r, "key") + ": " + q.jsDump.parse(i, void 0, t));
                            return q.jsDump.down(), n("{", u, "}");
                        },
                        node: function(e) {
                            var t, n, o, r = q.jsDump.HTML ? "&lt;" : "<", i = q.jsDump.HTML ? "&gt;" : ">", s = e.nodeName.toLowerCase(), u = r + s, a = e.attributes;
                            if (a) for (n = 0, t = a.length; n < t; n++) o = a[n].nodeValue, o && "inherit" !== o && (u += " " + a[n].nodeName + "=" + q.jsDump.parse(o, "attribute"));
                            return u += i, 3 !== e.nodeType && 4 !== e.nodeType || (u += e.nodeValue), u + r + "/" + s + i;
                        },
                        functionArgs: function(e) {
                            var t, n = e.length;
                            if (!n) return "";
                            for (t = new Array(n); n--; ) t[n] = String.fromCharCode(97 + n);
                            return " " + t.join(", ") + " ";
                        },
                        key: e,
                        functionCode: "[code]",
                        attribute: e,
                        string: e,
                        date: e,
                        regexp: t,
                        number: t,
                        boolean: t
                    },
                    HTML: !1,
                    indentChar: "  ",
                    multiline: !0
                };
                return i;
            }(), q.diff = function() {
                function e(e, t) {
                    var n, o = {}, r = {};
                    for (n = 0; n < t.length; n++) O.call(o, t[n]) || (o[t[n]] = {
                        rows: [],
                        o: null
                    }), o[t[n]].rows.push(n);
                    for (n = 0; n < e.length; n++) O.call(r, e[n]) || (r[e[n]] = {
                        rows: [],
                        n: null
                    }), r[e[n]].rows.push(n);
                    for (n in o) O.call(o, n) && 1 === o[n].rows.length && O.call(r, n) && 1 === r[n].rows.length && (t[o[n].rows[0]] = {
                        text: t[o[n].rows[0]],
                        row: r[n].rows[0]
                    }, e[r[n].rows[0]] = {
                        text: e[r[n].rows[0]],
                        row: o[n].rows[0]
                    });
                    for (n = 0; n < t.length - 1; n++) null != t[n].text && null == t[n + 1].text && t[n].row + 1 < e.length && null == e[t[n].row + 1].text && t[n + 1] == e[t[n].row + 1] && (t[n + 1] = {
                        text: t[n + 1],
                        row: t[n].row + 1
                    }, e[t[n].row + 1] = {
                        text: e[t[n].row + 1],
                        row: n + 1
                    });
                    for (n = t.length - 1; n > 0; n--) null != t[n].text && null == t[n - 1].text && t[n].row > 0 && null == e[t[n].row - 1].text && t[n - 1] == e[t[n].row - 1] && (t[n - 1] = {
                        text: t[n - 1],
                        row: t[n].row - 1
                    }, e[t[n].row - 1] = {
                        text: e[t[n].row - 1],
                        row: n - 1
                    });
                    return {
                        o: e,
                        n: t
                    };
                }
                return function(t, n) {
                    t = t.replace(/\s+$/, ""), n = n.replace(/\s+$/, "");
                    var o, r, i = "", s = e("" === t ? [] : t.split(/\s+/), "" === n ? [] : n.split(/\s+/)), u = t.match(/\s+/g), a = n.match(/\s+/g);
                    if (null == u ? u = [ " " ] : u.push(" "), null == a ? a = [ " " ] : a.push(" "), 
                    0 === s.n.length) for (o = 0; o < s.o.length; o++) i += "<del>" + s.o[o] + u[o] + "</del>"; else {
                        if (null == s.n[0].text) for (n = 0; n < s.o.length && null == s.o[n].text; n++) i += "<del>" + s.o[n] + u[n] + "</del>";
                        for (o = 0; o < s.n.length; o++) if (null == s.n[o].text) i += "<ins>" + s.n[o] + a[o] + "</ins>"; else {
                            for (r = "", n = s.n[o].row + 1; n < s.o.length && null == s.o[n].text; n++) r += "<del>" + s.o[n] + u[n] + "</del>";
                            i += " " + s.n[o].text + a[o] + r;
                        }
                    }
                    return i;
                };
            }(), "undefined" != typeof t && (f(t, q.constructor.prototype), t.QUnit = q), "undefined" != typeof e && e.exports && (e.exports = q);
        }(function() {
            return this;
        }());
    }).call(t, n(22));
}, function(e, t) {
    "use strict";
    function n() {
        throw new Error("setTimeout has not been defined");
    }
    function o() {
        throw new Error("clearTimeout has not been defined");
    }
    function r(e) {
        if (c === setTimeout) return setTimeout(e, 0);
        if ((c === n || !c) && setTimeout) return c = setTimeout, setTimeout(e, 0);
        try {
            return c(e, 0);
        } catch (t) {
            try {
                return c.call(null, e, 0);
            } catch (t) {
                return c.call(this, e, 0);
            }
        }
    }
    function i(e) {
        if (d === clearTimeout) return clearTimeout(e);
        if ((d === o || !d) && clearTimeout) return d = clearTimeout, clearTimeout(e);
        try {
            return d(e);
        } catch (t) {
            try {
                return d.call(null, e);
            } catch (t) {
                return d.call(this, e);
            }
        }
    }
    function s() {
        m && p && (m = !1, p.length ? h = p.concat(h) : g = -1, h.length && u());
    }
    function u() {
        if (!m) {
            var e = r(s);
            m = !0;
            for (var t = h.length; t; ) {
                for (p = h, h = []; ++g < t; ) p && p[g].run();
                g = -1, t = h.length;
            }
            p = null, m = !1, i(e);
        }
    }
    function a(e, t) {
        this.fun = e, this.array = t;
    }
    function l() {}
    var c, d, f = e.exports = {};
    !function() {
        try {
            c = "function" == typeof setTimeout ? setTimeout : n;
        } catch (e) {
            c = n;
        }
        try {
            d = "function" == typeof clearTimeout ? clearTimeout : o;
        } catch (e) {
            d = o;
        }
    }();
    var p, h = [], m = !1, g = -1;
    f.nextTick = function(e) {
        var t = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
        h.push(new a(e, t)), 1 !== h.length || m || r(u);
    }, a.prototype.run = function() {
        this.fun.apply(null, this.array);
    }, f.title = "browser", f.browser = !0, f.env = {}, f.argv = [], f.version = "", 
    f.versions = {}, f.on = l, f.addListener = l, f.once = l, f.off = l, f.removeListener = l, 
    f.removeAllListeners = l, f.emit = l, f.binding = function(e) {
        throw new Error("process.binding is not supported");
    }, f.cwd = function() {
        return "/";
    }, f.chdir = function(e) {
        throw new Error("process.chdir is not supported");
    }, f.umask = function() {
        return 0;
    };
}, function(e, t, n) {
    var o, r;
    !function(i, s) {
        "use strict";
        o = s, r = "function" == typeof o ? o.call(t, n, t, e) : o, !(void 0 !== r && (e.exports = r));
    }(this, function() {
        "use strict";
        function e(e, t) {
            var n;
            for (n in t) t.hasOwnProperty(n) && ("undefined" == typeof t[n] ? delete e[n] : e[n] = t[n]);
            return e;
        }
        function t(e, t) {
            var n;
            for (n = 0; n < e.length; n += 1) if (e[n] === t) return n;
            return -1;
        }
        function n(e, n) {
            var o = t(e, n);
            return o !== -1 ? e.splice(o, 1) : [];
        }
        function o(e) {
            return "undefined" != typeof e && "undefined" != typeof e.requireExpects && e.requireExpects;
        }
        function r(e) {
            return !!e.result;
        }
        function i(e) {
            return !r(e);
        }
        function s(e) {
            return i(e) && "undefined" == typeof e.expected && "undefined" == typeof e.actual;
        }
        function u(e) {
            return e.replace(/(\r?\n)/g, "$&# ");
        }
        function a(e) {
            return e.replace(/^\s+/, "");
        }
        function l(e) {
            return e;
        }
        function c(e, t, n, o) {
            e.push(t + ": " + o(n));
        }
        function d(e, t, n, o, r) {
            e && "undefined" != typeof o && c(t, n, o, r);
        }
        function f(e, t) {
            return t ? e + " - " + u(t) : e;
        }
        function p(p, v, b) {
            function w(e) {
                return k.config[e];
            }
            function y(e) {
                if (r(e)) return e.message;
                var t = [];
                return e.message && t.push(e.message), w("showExpectationOnFailure") && !s(e) && (c(t, "expected", e.expected, S), 
                c(t, "got", e.actual, S)), d(w("showTestNameOnFailure"), t, "test", e.name, l), 
                d(w("showModuleNameOnFailure"), t, "module", e.module, l), d(w("showSourceOnFailure"), t, "source", e.source, a), 
                t.join(", ");
            }
            function x(e) {
                k.puts(k.config.initialCount + ".." + e);
            }
            function T(e) {
                var o;
                t(j, e) !== -1 && (o = E.config[e], "undefined" != typeof o && n(o, O[e]));
            }
            function q(e) {
                var t;
                for (t = 0; t < e.length; t += 1) T(e[t]);
            }
            if (!p) throw new Error('should pass QUnit object reference. Please check QUnit\'s "require" path if you are using Node.js (or any CommonJS env).');
            if ("function" != typeof v) throw new Error("should pass print-like function");
            var E = p, k = {}, N = "undefined" != typeof E.jsDump && "function" == typeof E.jsDump.parse, S = N ? function(e) {
                return E.jsDump.parse(e);
            } : l, C = function(e, t) {
                b && "object" == typeof b && "undefined" != typeof b[e] && (v('# WARNING: Option "' + e + '" is deprecated and will be removed in future version.'), 
                t(b[e]));
            }, j = [ "moduleStart", "testStart", "log", "testDone", "done" ], O = {};
            return k.config = e({
                initialCount: 1,
                showModuleNameOnFailure: !0,
                showTestNameOnFailure: !0,
                showExpectationOnFailure: !0,
                showSourceOnFailure: !0
            }, b), C("noPlan", function(e) {
                v('# Now QUnit-TAP works as with "noPlan: true" by default. If you want to delare plan explicitly, please use "QUnit.config.requireExpects" option instead.'), 
                k.config.noPlan = e;
            }), C("count", function(e) {
                k.config.initialCount = e + 1;
            }), C("showDetailsOnFailure", function(e) {
                k.config.showModuleNameOnFailure = e, k.config.showTestNameOnFailure = e, k.config.showExpectationOnFailure = e, 
                k.config.showSourceOnFailure = e;
            }), k.VERSION = h, k.puts = v, k.count = k.config.initialCount - 1, k.expectedCount = k.config.initialCount - 1, 
            k.explain = S, k.note = function(e) {
                k.puts(u("# " + e));
            }, k.diag = function(e) {
                return k.note(e), !1;
            }, k.moduleStart = function(e) {
                var t = "string" == typeof e ? e : e.name;
                k.note("module: " + t);
            }, k.testStart = function(e) {
                var t = "string" == typeof e ? e : e.name;
                k.note("test: " + t);
            }, k.log = function(e) {
                var t = "";
                k.count += 1, i(e) && (t += "not "), t += "ok " + k.count, k.puts(f(t, y(e)));
            }, k.testDone = function() {
                o(E.config) && (k.expectedCount += E.config.current.expected);
            }, k.done = function() {
                ("undefined" == typeof k.config.noPlan || k.config.noPlan) && x(o(E.config) ? k.expectedCount : k.count);
            }, k.unsubscribe = function() {
                "undefined" != typeof E.config && q(0 === arguments.length ? j : m.apply(arguments));
            }, function() {
                var e, t, n, o = g(E);
                for (t = 0; t < j.length; t += 1) e = j[t], n = o(E, k, e), O[e] = n;
            }(), k;
        }
        var h = "1.5.0", m = Array.prototype.slice, g = function(e) {
            return function(e, t, n) {
                var o = e[n], r = function() {
                    t[n].apply(t, m.apply(arguments));
                };
                return o(r), r;
            };
        };
        return p.qunitTap = function() {
            throw new Error('[BC BREAK] Since 1.4.0, QUnit-TAP exports single qunitTap function as module.exports. Therefore, require("qunit-tap") returns qunitTap function itself. Please fix your code if you are using Node.js (or any CommonJS env).');
        }, p;
    });
}, function(e, t, n) {
    (function(e) {
        "use strict";
        var t = !1;
        QUnit.config.autostart = !1;
        var n = window.onerror;
        window.onerror = null, QUnit.begin(function() {
            window.onerror = function(e, t, o) {
                var r = !1;
                return n && (r = n(e, t, o)), QUnit.config.current && QUnit.config.current.async && QUnit.start(), 
                r;
            };
        }), QUnit.moduleStart(function() {
            t = !0;
        }), QUnit.done(function() {
            console.log("phantom-tap-done"), window.onerror = null;
        });
        var o = /^((not )?ok [0-9]+ (- )?)(.*)$/;
        qunitTap(QUnit, function() {
            if (1 == arguments.length && QUnit.config.current) {
                var e = o.exec(arguments[0]);
                if (e) return void console.log(e[1] + QUnit.config.current.testName + ": " + e[4]);
            }
            console.log.apply(console, arguments);
        }), window.setTimeout(function() {
            t || (console.log("QUnit not started by test"), console.log("phantom-tap-error"));
        }, 2e4), window.tests_included = !0, e && e.exports && (e.exports = QUnit);
    }).call(t, n(25)(e));
}, function(e, t) {
    "use strict";
    e.exports = function(e) {
        return e.webpackPolyfill || (e.deprecate = function() {}, e.paths = [], e.children = [], 
        e.webpackPolyfill = 1), e;
    };
}, function(e, t) {} ]);
//# sourceMappingURL=test-config-client.min.js.map