{"version":3,"sources":["webpack:///kdump/test-config-client.min.js","webpack:///webpack/bootstrap fa79fae7f7d7178e37c4?2600","webpack:///../pkg/kdump/test-config-client.js","webpack:///external \"cockpit\"?478e","webpack:///../pkg/kdump/config-client.es6?0751","webpack:///../pkg/lib/qunit-tests.js","webpack:///../bower_components/qunit/qunit/qunit.js","webpack:///../~/process/browser.js","webpack:///../bower_components/qunit-tap/lib/qunit-tap.js","webpack:///../pkg/lib/qunit-config.js","webpack:///../~/webpack/buildin/module.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","QUnit","cockpit","assert","kdump","basicConfig","join","changedConfig","asyncTest","expect","config","dataWasChanged","defer","configChanged","event","settings","equal","value","_rawContent","resolve","filename","configFile","file","replace","always","this","state","path","ConfigFile","wait","addEventListener","write","promise","done","start","window","setTimeout","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_cockpit","_cockpit2","_this","superuser","arguments","undefined","_lines","_originalSettings","_dataAvailable","event_target","_fileHandle","watch","rawContent","_parseText","remove","_this2","skipNotify","split","forEach","line","index","trimmed","trimLeft","indexOf","separatorIndex","substring","trim","commentIndex","comment","origLine","keys","extend","dispatchEvent","_this3","lines","slice","linesToDelete","origEntry","push","entry","sort","reverse","lineIndex","splice","_this4","modify","oldContent","_generateConfig","qunitTap","process","autorun","previousModule","runLoggingCallbacks","name","failed","moduleStats","bad","passed","all","total","banner","tests","runtime","Date","started","stats","html","className","innerHTML","altertitle","defined","document","title","reorder","sessionStorage","removeItem","scrolltop","scrollTo","validTest","test","include","filter","toLowerCase","fullName","testName","callback","testNumber","inArray","charAt","extractStacktrace","e","offset","stack","stacktrace","shift","fileName","sourceURL","sourceFromStacktrace","Error","escapeText","s","synchronize","last","queue","blocking","next","getTime","depth","updateRate","saveGlobal","pollution","noglobals","hasOwn","checkPollution","newGlobals","deletedGlobals","old","diff","pushFailure","a","b","j","result","prop","addEvent","elem","type","fn","attachEvent","addEvents","elems","hasClass","addClass","removeClass","set","getElementById","registerLoggingCallback","scope","args","callbacks","hasOwnProperty","array","Test","assertions","count","onErrorFnPrev","testId","toString","clearTimeout","x","setItem","errorString","error","message","objectValues","val","vals","is","testEnvironment","currentModule","currentModuleTestEnvironment","expected","async","nameHtml","moduleTestEnvironment","asserts","current","semaphore","begin","timeout","stop","testTimeout","ok","F","constructor","hidepassed","requireExpects","urlConfig","label","tooltip","log","testStart","testDone","moduleStart","moduleDone","location","search","protocol","params","urlParams","decodeURIComponent","concat","parseInt","isLocal","init","autostart","qunit","parentNode","removeChild","createElement","insertBefore","reset","fixture","objectType","match","isNaN","actual","output","source","details","jsDump","parse","url","querystring","encodeURIComponent","host","pathname","readyState","load","len","main","ol","toolbar","selection","urlConfigContainer","moduleFilter","userAgent","numModules","moduleNames","moduleFilterHtml","urlConfigHtml","oldconfig","localeCompare","navigator","tmp","checked","getItem","appendChild","setAttribute","getElementsByTagName","srcElement","defaultValue","options","selectedIndex","lastChild","selectBox","selectedModule","onerror","filePath","linerNr","ret","ignoreGlobalErrors","li","href","setup","teardown","current_testEnvironment","notrycatch","run","running","callbackStarted","callbackRuntime","finish","assertion","time","good","collapsed","nodeName","firstChild","duration","msg","notEqual","propEqual","equiv","notPropEqual","deepEqual","notDeepEqual","strictEqual","notStrictEqual","throws","block","expectedOutput","raises","equals","same","bindCallbacks","o","apply","innerEquiv","callers","parents","parentsB","getProto","getPrototypeOf","__proto__","useStrictEquality","string","boolean","number","null","nan","date","valueOf","regexp","global","ignoreCase","multiline","sticky","function","caller","loop","aCircular","bCircular","pop","object","eq","aProperties","bProperties","quote","str","literal","pre","arr","post","separator","base","indent","inner","Array","up","down","reName","inStack","res","parser","parsers","typeOf","setInterval","nodeType","item","HTML","extra","chr","indentChar","setParser","unknown","exec","nodelist","map","node","open","close","tag","attrs","attributes","nodeValue","functionArgs","l","String","fromCharCode","functionCode","attribute","n","ns","os","rows","text","row","out","oSpace","nSpace","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queueIndex","drainQueue","Item","noop","nextTick","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","ary","element","removeElement","isPlanRequired","conf","isPassed","isFailed","isAssertOkFailed","escapeLineEndings","ltrim","render","desc","fieldName","fieldValue","formatter","renderIf","shouldRender","formatTestLine","testLine","rest","qunitObject","printLikeFunction","isEnabled","configName","tap","formatDetails","explain","printPlanLine","toCount","puts","initialCount","unsubscribeEvent","eventName","listeners","targetEvents","qu","registeredCallbacks","unsubscribeEvents","eventNames","jsDumpExists","deprecateOption","optionName","fallback","showModuleNameOnFailure","showTestNameOnFailure","showExpectationOnFailure","showSourceOnFailure","flag","noPlan","VERSION","qunitTapVersion","expectedCount","note","diag","arg","unsubscribe","appendCallback","createCallbackAppenderFor","subject","observer","originalLoggingCallback","qunit_started","qunit_onerror","console","tap_regex","tests_included","webpackPolyfill","deprecate","paths","children"],"mappings":"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","file":"kdump/test-config-client.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\n\t * This file is part of Cockpit.\n\t *\n\t * Copyright (C) 2016 Red Hat, Inc.\n\t *\n\t * Cockpit is free software; you can redistribute it and/or modify it\n\t * under the terms of the GNU Lesser General Public License as published by\n\t * the Free Software Foundation; either version 2.1 of the License, or\n\t * (at your option) any later version.\n\t *\n\t * Cockpit is distributed in the hope that it will be useful, but\n\t * WITHOUT ANY WARRANTY; without even the implied warranty of\n\t * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n\t * Lesser General Public License for more details.\n\t *\n\t * You should have received a copy of the GNU Lesser General Public License\n\t * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n\t */\n\t\n\tvar QUnit = __webpack_require__(20);\n\tvar cockpit = __webpack_require__(2);\n\tvar assert = QUnit;\n\t\n\tvar kdump = __webpack_require__(15);\n\t\n\tvar basicConfig = [\n\t    \"# top comment\",\n\t    \"\",\n\t    \"foo bar\",\n\t    \" indented value\",\n\t    \"\",\n\t    \"will disappear\",\n\t    \"key value #comment\"\n\t].join(\"\\n\");\n\t\n\tvar changedConfig = [\n\t    \"# top comment\",\n\t    \"\",\n\t    \"foo moo\",\n\t    \"indented value\",\n\t    \"\",\n\t    \"#key value #comment\",\n\t    \"hooray value\"\n\t].join(\"\\n\");\n\t\n\tQUnit.asyncTest(\"config_update\", function() {\n\t    assert.expect(10);\n\t    var dataWasChanged = cockpit.defer();\n\t    var config;\n\t    var configChanged = function(event, settings) {\n\t        assert.equal(settings[\"foo\"].value, \"moo\", \"value changed correctly\");\n\t        assert.equal(\"key\" in settings, false, \"setting with comment deleted correctly\");\n\t        assert.equal(\"will\" in settings, false, \"setting without comment deleted correctly\");\n\t        assert.equal(settings[\"hooray\"].value, \"value\", \"value added correctly\");\n\t        assert.equal(config._rawContent, changedConfig, \"raw text for changed config is correct\");\n\t        dataWasChanged.resolve();\n\t    };\n\t\n\t    var filename = \"cockpit_config_read\";\n\t    var configFile = cockpit.file(filename);\n\t    configFile\n\t        .replace(basicConfig)\n\t        .always(function() {\n\t            assert.equal(this.state(), \"resolved\", \"writing initial config didn't fail\");\n\t            assert.equal(configFile.path, filename, \"file has correct path\");\n\t            config = new kdump.ConfigFile(filename);\n\t            config.wait().always(function() {\n\t                assert.equal(this.state(), \"resolved\", \"waiting for config didn't fail\");\n\t                config.settings[\"foo\"].value = \"moo\";\n\t                delete config.settings[\"key\"];\n\t                delete config.settings[\"will\"];\n\t                config.settings[\"hooray\"] = { value: \"value\" };\n\t                config.addEventListener('kdumpConfigChanged', configChanged);\n\t                config.write(config.settings)\n\t                    .always(function() {\n\t                        assert.equal(this.state(), \"resolved\", \"writing to config didn't fail\");\n\t                        dataWasChanged.promise().done(function() {\n\t                            assert.equal(this.state(), \"resolved\", \"waiting for config change didn't fail\");\n\t                            QUnit.start();\n\t                        });\n\t                    });\n\t            });\n\t        });\n\t});\n\t\n\twindow.setTimeout(function() {\n\t    QUnit.start();\n\t});\n\n\n/***/ },\n/* 1 */,\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = cockpit;\n\n/***/ },\n/* 3 */,\n/* 4 */,\n/* 5 */,\n/* 6 */,\n/* 7 */,\n/* 8 */,\n/* 9 */,\n/* 10 */,\n/* 11 */,\n/* 12 */,\n/* 13 */,\n/* 14 */,\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * This file is part of Cockpit.\n\t *\n\t * Copyright (C) 2016 Red Hat, Inc.\n\t *\n\t * Cockpit is free software; you can redistribute it and/or modify it\n\t * under the terms of the GNU Lesser General Public License as published by\n\t * the Free Software Foundation; either version 2.1 of the License, or\n\t * (at your option) any later version.\n\t *\n\t * Cockpit is distributed in the hope that it will be useful, but\n\t * WITHOUT ANY WARRANTY; without even the implied warranty of\n\t * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n\t * Lesser General Public License for more details.\n\t *\n\t * You should have received a copy of the GNU Lesser General Public License\n\t * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n\t */\n\t\n\t/* jshint esversion:6 */\n\t\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar _cockpit = __webpack_require__(2);\n\t\n\tvar _cockpit2 = _interopRequireDefault(_cockpit);\n\t\n\t/* Parse an ini-style config file\n\t * and monitor it for changes\n\t */\n\t\n\tvar ConfigFile = (function () {\n\t    function ConfigFile(filename) {\n\t        var _this = this;\n\t\n\t        var superuser = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\t\n\t        _classCallCheck(this, ConfigFile);\n\t\n\t        this.filename = filename;\n\t        this._rawContent = undefined;\n\t        this._lines = [];\n\t        this._originalSettings = {};\n\t        this._dataAvailable = _cockpit2[\"default\"].defer();\n\t        this.settings = {};\n\t\n\t        _cockpit2[\"default\"].event_target(this);\n\t\n\t        this._fileHandle = _cockpit2[\"default\"].file(filename, { superuser: superuser });\n\t        this._fileHandle.watch(function (rawContent) {\n\t            _this._parseText(rawContent);\n\t        });\n\t    }\n\t\n\t    _createClass(ConfigFile, [{\n\t        key: \"close\",\n\t        value: function close() {\n\t            if (this._fileHandle) {\n\t                this._fileHandle.remove();\n\t                this._fileHandle = undefined;\n\t            }\n\t        }\n\t\n\t        // wait for data to have been read at least once\n\t    }, {\n\t        key: \"wait\",\n\t        value: function wait() {\n\t            return this._dataAvailable.promise();\n\t        }\n\t\n\t        /* parse lines of the config file\n\t         * if a line has a valid config key, use that as key\n\t         * and also store original line, line index, value and whether the line contains a comment\n\t         * we care about the comment since we don't want to overwrite a user comment when changing a value\n\t         * e.g. for line \"someKey foo # comment\"\n\t         * outputObject[\"someKey\"] = { index: 0, value: \"foo\", origLine: \"someKey foo # comment\", hasComment: true }\n\t         * skipNotify: Don't notify about changes, e.g.to avoid multiple updates when writing a file\n\t         */\n\t    }, {\n\t        key: \"_parseText\",\n\t        value: function _parseText(rawContent) {\n\t            var _this2 = this;\n\t\n\t            var skipNotify = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\t\n\t            if (this._dataAvailable) this._dataAvailable.resolve();\n\t\n\t            // if nothing changed, don't bother parsing the content\n\t            // do proceed if the content is empty, it might be our initial read\n\t            if (!rawContent) {\n\t                this._originalSettings = null;\n\t                this.settings = null;\n\t                if (!skipNotify) this.dispatchEvent(\"kdumpConfigChanged\", this.settings);\n\t                return;\n\t            }\n\t\n\t            if (rawContent == this._rawContent) return;\n\t\n\t            //if (skipNotify === undefined)\n\t            //    skipNotify = false;\n\t\n\t            this._rawContent = rawContent;\n\t            // parse the config file\n\t            this._lines = rawContent.split(/\\r?\\n/);\n\t\n\t            this.settings = {};\n\t            this._lines.forEach(function (line, index) {\n\t                var trimmed = line.trimLeft();\n\t                // if the line is empty or only a comment, skip\n\t                if (trimmed.indexOf(\"#\") === 0 || trimmed.length === 0) return;\n\t\n\t                // we need to have a space between key and value\n\t                var separatorIndex = trimmed.indexOf(\" \");\n\t                if (separatorIndex === -1) return;\n\t                var key = trimmed.substring(0, separatorIndex);\n\t                var value = trimmed.substring(separatorIndex + 1).trim();\n\t\n\t                // value might have a comment at the end\n\t                var commentIndex = value.indexOf(\"#\");\n\t                var comment = undefined;\n\t                if (commentIndex !== -1) {\n\t                    comment = value.substring(commentIndex).trim();\n\t                    value = value.substring(0, commentIndex).trim();\n\t                }\n\t                _this2.settings[key] = {\n\t                    index: index,\n\t                    value: value,\n\t                    origLine: line,\n\t                    comment: comment\n\t                };\n\t            });\n\t\n\t            // make sure we copy the original keys so we overwrite the correct lines when saving\n\t            this._originalSettings = {};\n\t            Object.keys(this.settings).forEach(function (key) {\n\t                _this2._originalSettings[key] = _cockpit2[\"default\"].extend({}, _this2.settings[key]);\n\t            });\n\t            if (!skipNotify) this.dispatchEvent(\"kdumpConfigChanged\", this.settings);\n\t        }\n\t\n\t        /* generate the config file from raw text and settings\n\t         */\n\t    }, {\n\t        key: \"_generateConfig\",\n\t        value: function _generateConfig(settings) {\n\t            var _this3 = this;\n\t\n\t            var lines = this._lines.slice(0);\n\t            var linesToDelete = [];\n\t            // first find the settings lines that have been disabled/deleted\n\t            Object.keys(this._originalSettings).forEach(function (key) {\n\t                if (!(key in settings)) {\n\t                    var origEntry = _this3._originalSettings[key];\n\t                    // if the line had a comment, keep it, otherwise delete\n\t                    if (origEntry.comment !== undefined) lines[origEntry.index] = \"#\" + origEntry.origLine;else linesToDelete.push(origEntry.index);\n\t                }\n\t            });\n\t            // we take the lines from our last read operation and modify them with the new settings\n\t            Object.keys(settings).forEach(function (key) {\n\t                var entry = settings[key];\n\t                var line = key + \" \" + entry.value;\n\t                if (entry.comment) line = line + \" \" + entry.comment;\n\t                // this might be a new entry\n\t                if (!(key in _this3._originalSettings)) {\n\t                    lines.push(line);\n\t                    return;\n\t                }\n\t                // otherwise edit the old line\n\t                var origEntry = _this3._originalSettings[key];\n\t                lines[origEntry.index] = line;\n\t            });\n\t            // now delete the rows we want to delete\n\t            linesToDelete.sort().reverse().forEach(function (lineIndex) {\n\t                lines.splice(lineIndex, 1);\n\t            });\n\t\n\t            return lines.join(\"\\n\");\n\t        }\n\t\n\t        /* write settings back to file\n\t         * new settings that don't have a corresponding entry already have an undefined or null index\n\t         * returns a promise for the file operation (cockpit File)\n\t         */\n\t    }, {\n\t        key: \"write\",\n\t        value: function write(settings) {\n\t            var _this4 = this;\n\t\n\t            return this._fileHandle.modify(function (oldContent) {\n\t                _this4._parseText(oldContent, true);\n\t                return _this4._generateConfig(settings);\n\t            });\n\t        }\n\t    }]);\n\t\n\t    return ConfigFile;\n\t})();\n\n\texports.ConfigFile = ConfigFile;\n\n/***/ },\n/* 16 */,\n/* 17 */,\n/* 18 */,\n/* 19 */,\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\n\t * This file is part of Cockpit.\n\t *\n\t * Copyright (C) 2014 Red Hat, Inc.\n\t *\n\t * Cockpit is free software; you can redistribute it and/or modify it\n\t * under the terms of the GNU Lesser General Public License as published by\n\t * the Free Software Foundation; either version 2.1 of the License, or\n\t * (at your option) any later version.\n\t *\n\t * Cockpit is distributed in the hope that it will be useful, but\n\t * WITHOUT ANY WARRANTY; without even the implied warranty of\n\t * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n\t * Lesser General Public License for more details.\n\t *\n\t * You should have received a copy of the GNU Lesser General Public License\n\t * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n\t */\n\t\n\t(function() {\n\t    \"use strict\";\n\t\n\t    /* QUnit needs to have 'window' as 'this' in order to load */\n\t    window.QUnit = __webpack_require__(21);\n\t    window.qunitTap = __webpack_require__(23);\n\t\n\t    __webpack_require__(24);\n\t\n\t    __webpack_require__(26);\n\t\n\t    module.exports = window.QUnit;\n\t\n\t}());\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {/*!\n\t * QUnit 1.14.0\n\t * http://qunitjs.com/\n\t *\n\t * Copyright 2013 jQuery Foundation and other contributors\n\t * Released under the MIT license\n\t * http://jquery.org/license\n\t *\n\t * Date: 2014-01-31T16:40Z\n\t */\n\t\n\t(function( window ) {\n\t\n\tvar QUnit,\n\t\tassert,\n\t\tconfig,\n\t\tonErrorFnPrev,\n\t\ttestId = 0,\n\t\tfileName = (sourceFromStacktrace( 0 ) || \"\" ).replace(/(:\\d+)+\\)?/, \"\").replace(/.+\\//, \"\"),\n\t\ttoString = Object.prototype.toString,\n\t\thasOwn = Object.prototype.hasOwnProperty,\n\t\t// Keep a local reference to Date (GH-283)\n\t\tDate = window.Date,\n\t\tsetTimeout = window.setTimeout,\n\t\tclearTimeout = window.clearTimeout,\n\t\tdefined = {\n\t\t\tdocument: typeof window.document !== \"undefined\",\n\t\t\tsetTimeout: typeof window.setTimeout !== \"undefined\",\n\t\t\tsessionStorage: (function() {\n\t\t\t\tvar x = \"qunit-test-string\";\n\t\t\t\ttry {\n\t\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\t\treturn true;\n\t\t\t\t} catch( e ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}())\n\t\t},\n\t\t/**\n\t\t * Provides a normalized error string, correcting an issue\n\t\t * with IE 7 (and prior) where Error.prototype.toString is\n\t\t * not properly implemented\n\t\t *\n\t\t * Based on http://es5.github.com/#x15.11.4.4\n\t\t *\n\t\t * @param {String|Error} error\n\t\t * @return {String} error message\n\t\t */\n\t\terrorString = function( error ) {\n\t\t\tvar name, message,\n\t\t\t\terrorString = error.toString();\n\t\t\tif ( errorString.substring( 0, 7 ) === \"[object\" ) {\n\t\t\t\tname = error.name ? error.name.toString() : \"Error\";\n\t\t\t\tmessage = error.message ? error.message.toString() : \"\";\n\t\t\t\tif ( name && message ) {\n\t\t\t\t\treturn name + \": \" + message;\n\t\t\t\t} else if ( name ) {\n\t\t\t\t\treturn name;\n\t\t\t\t} else if ( message ) {\n\t\t\t\t\treturn message;\n\t\t\t\t} else {\n\t\t\t\t\treturn \"Error\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn errorString;\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Makes a clone of an object using only Array or Object as base,\n\t\t * and copies over the own enumerable properties.\n\t\t *\n\t\t * @param {Object} obj\n\t\t * @return {Object} New object with only the own properties (recursively).\n\t\t */\n\t\tobjectValues = function( obj ) {\n\t\t\t// Grunt 0.3.x uses an older version of jshint that still has jshint/jshint#392.\n\t\t\t/*jshint newcap: false */\n\t\t\tvar key, val,\n\t\t\t\tvals = QUnit.is( \"array\", obj ) ? [] : {};\n\t\t\tfor ( key in obj ) {\n\t\t\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\t\t\tval = obj[key];\n\t\t\t\t\tvals[key] = val === Object(val) ? objectValues(val) : val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn vals;\n\t\t};\n\t\n\t\n\t// Root QUnit object.\n\t// `QUnit` initialized at top of scope\n\tQUnit = {\n\t\n\t\t// call on start of module test to prepend name to all tests\n\t\tmodule: function( name, testEnvironment ) {\n\t\t\tconfig.currentModule = name;\n\t\t\tconfig.currentModuleTestEnvironment = testEnvironment;\n\t\t\tconfig.modules[name] = true;\n\t\t},\n\t\n\t\tasyncTest: function( testName, expected, callback ) {\n\t\t\tif ( arguments.length === 2 ) {\n\t\t\t\tcallback = expected;\n\t\t\t\texpected = null;\n\t\t\t}\n\t\n\t\t\tQUnit.test( testName, expected, callback, true );\n\t\t},\n\t\n\t\ttest: function( testName, expected, callback, async ) {\n\t\t\tvar test,\n\t\t\t\tnameHtml = \"<span class='test-name'>\" + escapeText( testName ) + \"</span>\";\n\t\n\t\t\tif ( arguments.length === 2 ) {\n\t\t\t\tcallback = expected;\n\t\t\t\texpected = null;\n\t\t\t}\n\t\n\t\t\tif ( config.currentModule ) {\n\t\t\t\tnameHtml = \"<span class='module-name'>\" + escapeText( config.currentModule ) + \"</span>: \" + nameHtml;\n\t\t\t}\n\t\n\t\t\ttest = new Test({\n\t\t\t\tnameHtml: nameHtml,\n\t\t\t\ttestName: testName,\n\t\t\t\texpected: expected,\n\t\t\t\tasync: async,\n\t\t\t\tcallback: callback,\n\t\t\t\tmodule: config.currentModule,\n\t\t\t\tmoduleTestEnvironment: config.currentModuleTestEnvironment,\n\t\t\t\tstack: sourceFromStacktrace( 2 )\n\t\t\t});\n\t\n\t\t\tif ( !validTest( test ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\ttest.queue();\n\t\t},\n\t\n\t\t// Specify the number of expected assertions to guarantee that failed test (no assertions are run at all) don't slip through.\n\t\texpect: function( asserts ) {\n\t\t\tif (arguments.length === 1) {\n\t\t\t\tconfig.current.expected = asserts;\n\t\t\t} else {\n\t\t\t\treturn config.current.expected;\n\t\t\t}\n\t\t},\n\t\n\t\tstart: function( count ) {\n\t\t\t// QUnit hasn't been initialized yet.\n\t\t\t// Note: RequireJS (et al) may delay onLoad\n\t\t\tif ( config.semaphore === undefined ) {\n\t\t\t\tQUnit.begin(function() {\n\t\t\t\t\t// This is triggered at the top of QUnit.load, push start() to the event loop, to allow QUnit.load to finish first\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tQUnit.start( count );\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tconfig.semaphore -= count || 1;\n\t\t\t// don't start until equal number of stop-calls\n\t\t\tif ( config.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// ignore if start is called more often then stop\n\t\t\tif ( config.semaphore < 0 ) {\n\t\t\t\tconfig.semaphore = 0;\n\t\t\t\tQUnit.pushFailure( \"Called start() while already started (QUnit.config.semaphore was 0 already)\", null, sourceFromStacktrace(2) );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// A slight delay, to avoid any current callbacks\n\t\t\tif ( defined.setTimeout ) {\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tif ( config.semaphore > 0 ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( config.timeout ) {\n\t\t\t\t\t\tclearTimeout( config.timeout );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tconfig.blocking = false;\n\t\t\t\t\tprocess( true );\n\t\t\t\t}, 13);\n\t\t\t} else {\n\t\t\t\tconfig.blocking = false;\n\t\t\t\tprocess( true );\n\t\t\t}\n\t\t},\n\t\n\t\tstop: function( count ) {\n\t\t\tconfig.semaphore += count || 1;\n\t\t\tconfig.blocking = true;\n\t\n\t\t\tif ( config.testTimeout && defined.setTimeout ) {\n\t\t\t\tclearTimeout( config.timeout );\n\t\t\t\tconfig.timeout = setTimeout(function() {\n\t\t\t\t\tQUnit.ok( false, \"Test timed out\" );\n\t\t\t\t\tconfig.semaphore = 1;\n\t\t\t\t\tQUnit.start();\n\t\t\t\t}, config.testTimeout );\n\t\t\t}\n\t\t}\n\t};\n\t\n\t// We use the prototype to distinguish between properties that should\n\t// be exposed as globals (and in exports) and those that shouldn't\n\t(function() {\n\t\tfunction F() {}\n\t\tF.prototype = QUnit;\n\t\tQUnit = new F();\n\t\t// Make F QUnit's constructor so that we can add to the prototype later\n\t\tQUnit.constructor = F;\n\t}());\n\t\n\t/**\n\t * Config object: Maintain internal state\n\t * Later exposed as QUnit.config\n\t * `config` initialized at top of scope\n\t */\n\tconfig = {\n\t\t// The queue of tests to run\n\t\tqueue: [],\n\t\n\t\t// block until document ready\n\t\tblocking: true,\n\t\n\t\t// when enabled, show only failing tests\n\t\t// gets persisted through sessionStorage and can be changed in UI via checkbox\n\t\thidepassed: false,\n\t\n\t\t// by default, run previously failed tests first\n\t\t// very useful in combination with \"Hide passed tests\" checked\n\t\treorder: true,\n\t\n\t\t// by default, modify document.title when suite is done\n\t\taltertitle: true,\n\t\n\t\t// by default, scroll to top of the page when suite is done\n\t\tscrolltop: true,\n\t\n\t\t// when enabled, all tests must call expect()\n\t\trequireExpects: false,\n\t\n\t\t// add checkboxes that are persisted in the query-string\n\t\t// when enabled, the id is set to `true` as a `QUnit.config` property\n\t\turlConfig: [\n\t\t\t{\n\t\t\t\tid: \"noglobals\",\n\t\t\t\tlabel: \"Check for Globals\",\n\t\t\t\ttooltip: \"Enabling this will test if any test introduces new properties on the `window` object. Stored as query-strings.\"\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"notrycatch\",\n\t\t\t\tlabel: \"No try-catch\",\n\t\t\t\ttooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging exceptions in IE reasonable. Stored as query-strings.\"\n\t\t\t}\n\t\t],\n\t\n\t\t// Set of all modules.\n\t\tmodules: {},\n\t\n\t\t// logging callback queues\n\t\tbegin: [],\n\t\tdone: [],\n\t\tlog: [],\n\t\ttestStart: [],\n\t\ttestDone: [],\n\t\tmoduleStart: [],\n\t\tmoduleDone: []\n\t};\n\t\n\t// Initialize more QUnit.config and QUnit.urlParams\n\t(function() {\n\t\tvar i, current,\n\t\t\tlocation = window.location || { search: \"\", protocol: \"file:\" },\n\t\t\tparams = location.search.slice( 1 ).split( \"&\" ),\n\t\t\tlength = params.length,\n\t\t\turlParams = {};\n\t\n\t\tif ( params[ 0 ] ) {\n\t\t\tfor ( i = 0; i < length; i++ ) {\n\t\t\t\tcurrent = params[ i ].split( \"=\" );\n\t\t\t\tcurrent[ 0 ] = decodeURIComponent( current[ 0 ] );\n\t\n\t\t\t\t// allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\t\tcurrent[ 1 ] = current[ 1 ] ? decodeURIComponent( current[ 1 ] ) : true;\n\t\t\t\tif ( urlParams[ current[ 0 ] ] ) {\n\t\t\t\t\turlParams[ current[ 0 ] ] = [].concat( urlParams[ current[ 0 ] ], current[ 1 ] );\n\t\t\t\t} else {\n\t\t\t\t\turlParams[ current[ 0 ] ] = current[ 1 ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tQUnit.urlParams = urlParams;\n\t\n\t\t// String search anywhere in moduleName+testName\n\t\tconfig.filter = urlParams.filter;\n\t\n\t\t// Exact match of the module name\n\t\tconfig.module = urlParams.module;\n\t\n\t\tconfig.testNumber = [];\n\t\tif ( urlParams.testNumber ) {\n\t\n\t\t\t// Ensure that urlParams.testNumber is an array\n\t\t\turlParams.testNumber = [].concat( urlParams.testNumber );\n\t\t\tfor ( i = 0; i < urlParams.testNumber.length; i++ ) {\n\t\t\t\tcurrent = urlParams.testNumber[ i ];\n\t\t\t\tconfig.testNumber.push( parseInt( current, 10 ) );\n\t\t\t}\n\t\t}\n\t\n\t\t// Figure out if we're running the tests from a server or not\n\t\tQUnit.isLocal = location.protocol === \"file:\";\n\t}());\n\t\n\textend( QUnit, {\n\t\n\t\tconfig: config,\n\t\n\t\t// Initialize the configuration options\n\t\tinit: function() {\n\t\t\textend( config, {\n\t\t\t\tstats: { all: 0, bad: 0 },\n\t\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\t\tstarted: +new Date(),\n\t\t\t\tupdateRate: 1000,\n\t\t\t\tblocking: false,\n\t\t\t\tautostart: true,\n\t\t\t\tautorun: false,\n\t\t\t\tfilter: \"\",\n\t\t\t\tqueue: [],\n\t\t\t\tsemaphore: 1\n\t\t\t});\n\t\n\t\t\tvar tests, banner, result,\n\t\t\t\tqunit = id( \"qunit\" );\n\t\n\t\t\tif ( qunit ) {\n\t\t\t\tqunit.innerHTML =\n\t\t\t\t\t\"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +\n\t\t\t\t\t\"<h2 id='qunit-banner'></h2>\" +\n\t\t\t\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +\n\t\t\t\t\t\"<h2 id='qunit-userAgent'></h2>\" +\n\t\t\t\t\t\"<ol id='qunit-tests'></ol>\";\n\t\t\t}\n\t\n\t\t\ttests = id( \"qunit-tests\" );\n\t\t\tbanner = id( \"qunit-banner\" );\n\t\t\tresult = id( \"qunit-testresult\" );\n\t\n\t\t\tif ( tests ) {\n\t\t\t\ttests.innerHTML = \"\";\n\t\t\t}\n\t\n\t\t\tif ( banner ) {\n\t\t\t\tbanner.className = \"\";\n\t\t\t}\n\t\n\t\t\tif ( result ) {\n\t\t\t\tresult.parentNode.removeChild( result );\n\t\t\t}\n\t\n\t\t\tif ( tests ) {\n\t\t\t\tresult = document.createElement( \"p\" );\n\t\t\t\tresult.id = \"qunit-testresult\";\n\t\t\t\tresult.className = \"result\";\n\t\t\t\ttests.parentNode.insertBefore( result, tests );\n\t\t\t\tresult.innerHTML = \"Running...<br/>&nbsp;\";\n\t\t\t}\n\t\t},\n\t\n\t\t// Resets the test setup. Useful for tests that modify the DOM.\n\t\t/*\n\t\tDEPRECATED: Use multiple tests instead of resetting inside a test.\n\t\tUse testStart or testDone for custom cleanup.\n\t\tThis method will throw an error in 2.0, and will be removed in 2.1\n\t\t*/\n\t\treset: function() {\n\t\t\tvar fixture = id( \"qunit-fixture\" );\n\t\t\tif ( fixture ) {\n\t\t\t\tfixture.innerHTML = config.fixture;\n\t\t\t}\n\t\t},\n\t\n\t\t// Safe object type checking\n\t\tis: function( type, obj ) {\n\t\t\treturn QUnit.objectType( obj ) === type;\n\t\t},\n\t\n\t\tobjectType: function( obj ) {\n\t\t\tif ( typeof obj === \"undefined\" ) {\n\t\t\t\treturn \"undefined\";\n\t\t\t}\n\t\n\t\t\t// Consider: typeof null === object\n\t\t\tif ( obj === null ) {\n\t\t\t\treturn \"null\";\n\t\t\t}\n\t\n\t\t\tvar match = toString.call( obj ).match(/^\\[object\\s(.*)\\]$/),\n\t\t\t\ttype = match && match[1] || \"\";\n\t\n\t\t\tswitch ( type ) {\n\t\t\t\tcase \"Number\":\n\t\t\t\t\tif ( isNaN(obj) ) {\n\t\t\t\t\t\treturn \"nan\";\n\t\t\t\t\t}\n\t\t\t\t\treturn \"number\";\n\t\t\t\tcase \"String\":\n\t\t\t\tcase \"Boolean\":\n\t\t\t\tcase \"Array\":\n\t\t\t\tcase \"Date\":\n\t\t\t\tcase \"RegExp\":\n\t\t\t\tcase \"Function\":\n\t\t\t\t\treturn type.toLowerCase();\n\t\t\t}\n\t\t\tif ( typeof obj === \"object\" ) {\n\t\t\t\treturn \"object\";\n\t\t\t}\n\t\t\treturn undefined;\n\t\t},\n\t\n\t\tpush: function( result, actual, expected, message ) {\n\t\t\tif ( !config.current ) {\n\t\t\t\tthrow new Error( \"assertion outside test context, was \" + sourceFromStacktrace() );\n\t\t\t}\n\t\n\t\t\tvar output, source,\n\t\t\t\tdetails = {\n\t\t\t\t\tmodule: config.current.module,\n\t\t\t\t\tname: config.current.testName,\n\t\t\t\t\tresult: result,\n\t\t\t\t\tmessage: message,\n\t\t\t\t\tactual: actual,\n\t\t\t\t\texpected: expected\n\t\t\t\t};\n\t\n\t\t\tmessage = escapeText( message ) || ( result ? \"okay\" : \"failed\" );\n\t\t\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\n\t\t\toutput = message;\n\t\n\t\t\tif ( !result ) {\n\t\t\t\texpected = escapeText( QUnit.jsDump.parse(expected) );\n\t\t\t\tactual = escapeText( QUnit.jsDump.parse(actual) );\n\t\t\t\toutput += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" + expected + \"</pre></td></tr>\";\n\t\n\t\t\t\tif ( actual !== expected ) {\n\t\t\t\t\toutput += \"<tr class='test-actual'><th>Result: </th><td><pre>\" + actual + \"</pre></td></tr>\";\n\t\t\t\t\toutput += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" + QUnit.diff( expected, actual ) + \"</pre></td></tr>\";\n\t\t\t\t}\n\t\n\t\t\t\tsource = sourceFromStacktrace();\n\t\n\t\t\t\tif ( source ) {\n\t\t\t\t\tdetails.source = source;\n\t\t\t\t\toutput += \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText( source ) + \"</pre></td></tr>\";\n\t\t\t\t}\n\t\n\t\t\t\toutput += \"</table>\";\n\t\t\t}\n\t\n\t\t\trunLoggingCallbacks( \"log\", QUnit, details );\n\t\n\t\t\tconfig.current.assertions.push({\n\t\t\t\tresult: !!result,\n\t\t\t\tmessage: output\n\t\t\t});\n\t\t},\n\t\n\t\tpushFailure: function( message, source, actual ) {\n\t\t\tif ( !config.current ) {\n\t\t\t\tthrow new Error( \"pushFailure() assertion outside test context, was \" + sourceFromStacktrace(2) );\n\t\t\t}\n\t\n\t\t\tvar output,\n\t\t\t\tdetails = {\n\t\t\t\t\tmodule: config.current.module,\n\t\t\t\t\tname: config.current.testName,\n\t\t\t\t\tresult: false,\n\t\t\t\t\tmessage: message\n\t\t\t\t};\n\t\n\t\t\tmessage = escapeText( message ) || \"error\";\n\t\t\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\n\t\t\toutput = message;\n\t\n\t\t\toutput += \"<table>\";\n\t\n\t\t\tif ( actual ) {\n\t\t\t\toutput += \"<tr class='test-actual'><th>Result: </th><td><pre>\" + escapeText( actual ) + \"</pre></td></tr>\";\n\t\t\t}\n\t\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t\toutput += \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText( source ) + \"</pre></td></tr>\";\n\t\t\t}\n\t\n\t\t\toutput += \"</table>\";\n\t\n\t\t\trunLoggingCallbacks( \"log\", QUnit, details );\n\t\n\t\t\tconfig.current.assertions.push({\n\t\t\t\tresult: false,\n\t\t\t\tmessage: output\n\t\t\t});\n\t\t},\n\t\n\t\turl: function( params ) {\n\t\t\tparams = extend( extend( {}, QUnit.urlParams ), params );\n\t\t\tvar key,\n\t\t\t\tquerystring = \"?\";\n\t\n\t\t\tfor ( key in params ) {\n\t\t\t\tif ( hasOwn.call( params, key ) ) {\n\t\t\t\t\tquerystring += encodeURIComponent( key ) + \"=\" +\n\t\t\t\t\t\tencodeURIComponent( params[ key ] ) + \"&\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn window.location.protocol + \"//\" + window.location.host +\n\t\t\t\twindow.location.pathname + querystring.slice( 0, -1 );\n\t\t},\n\t\n\t\textend: extend,\n\t\tid: id,\n\t\taddEvent: addEvent,\n\t\taddClass: addClass,\n\t\thasClass: hasClass,\n\t\tremoveClass: removeClass\n\t\t// load, equiv, jsDump, diff: Attached later\n\t});\n\t\n\t/**\n\t * @deprecated: Created for backwards compatibility with test runner that set the hook function\n\t * into QUnit.{hook}, instead of invoking it and passing the hook function.\n\t * QUnit.constructor is set to the empty F() above so that we can add to it's prototype here.\n\t * Doing this allows us to tell if the following methods have been overwritten on the actual\n\t * QUnit object.\n\t */\n\textend( QUnit.constructor.prototype, {\n\t\n\t\t// Logging callbacks; all receive a single argument with the listed properties\n\t\t// run test/logs.html for any related changes\n\t\tbegin: registerLoggingCallback( \"begin\" ),\n\t\n\t\t// done: { failed, passed, total, runtime }\n\t\tdone: registerLoggingCallback( \"done\" ),\n\t\n\t\t// log: { result, actual, expected, message }\n\t\tlog: registerLoggingCallback( \"log\" ),\n\t\n\t\t// testStart: { name }\n\t\ttestStart: registerLoggingCallback( \"testStart\" ),\n\t\n\t\t// testDone: { name, failed, passed, total, runtime }\n\t\ttestDone: registerLoggingCallback( \"testDone\" ),\n\t\n\t\t// moduleStart: { name }\n\t\tmoduleStart: registerLoggingCallback( \"moduleStart\" ),\n\t\n\t\t// moduleDone: { name, failed, passed, total }\n\t\tmoduleDone: registerLoggingCallback( \"moduleDone\" )\n\t});\n\t\n\tif ( !defined.document || document.readyState === \"complete\" ) {\n\t\tconfig.autorun = true;\n\t}\n\t\n\tQUnit.load = function() {\n\t\trunLoggingCallbacks( \"begin\", QUnit, {} );\n\t\n\t\t// Initialize the config, saving the execution queue\n\t\tvar banner, filter, i, j, label, len, main, ol, toolbar, val, selection,\n\t\t\turlConfigContainer, moduleFilter, userAgent,\n\t\t\tnumModules = 0,\n\t\t\tmoduleNames = [],\n\t\t\tmoduleFilterHtml = \"\",\n\t\t\turlConfigHtml = \"\",\n\t\t\toldconfig = extend( {}, config );\n\t\n\t\tQUnit.init();\n\t\textend(config, oldconfig);\n\t\n\t\tconfig.blocking = false;\n\t\n\t\tlen = config.urlConfig.length;\n\t\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tval = config.urlConfig[i];\n\t\t\tif ( typeof val === \"string\" ) {\n\t\t\t\tval = {\n\t\t\t\t\tid: val,\n\t\t\t\t\tlabel: val\n\t\t\t\t};\n\t\t\t}\n\t\t\tconfig[ val.id ] = QUnit.urlParams[ val.id ];\n\t\t\tif ( !val.value || typeof val.value === \"string\" ) {\n\t\t\t\turlConfigHtml += \"<input id='qunit-urlconfig-\" + escapeText( val.id ) +\n\t\t\t\t\t\"' name='\" + escapeText( val.id ) +\n\t\t\t\t\t\"' type='checkbox'\" +\n\t\t\t\t\t( val.value ? \" value='\" + escapeText( val.value ) + \"'\" : \"\" ) +\n\t\t\t\t\t( config[ val.id ] ? \" checked='checked'\" : \"\" ) +\n\t\t\t\t\t\" title='\" + escapeText( val.tooltip ) +\n\t\t\t\t\t\"'><label for='qunit-urlconfig-\" + escapeText( val.id ) +\n\t\t\t\t\t\"' title='\" + escapeText( val.tooltip ) + \"'>\" + val.label + \"</label>\";\n\t\t\t} else {\n\t\t\t\turlConfigHtml += \"<label for='qunit-urlconfig-\" + escapeText( val.id ) +\n\t\t\t\t\t\"' title='\" + escapeText( val.tooltip ) +\n\t\t\t\t\t\"'>\" + val.label +\n\t\t\t\t\t\": </label><select id='qunit-urlconfig-\" + escapeText( val.id ) +\n\t\t\t\t\t\"' name='\" + escapeText( val.id ) +\n\t\t\t\t\t\"' title='\" + escapeText( val.tooltip ) +\n\t\t\t\t\t\"'><option></option>\";\n\t\t\t\tselection = false;\n\t\t\t\tif ( QUnit.is( \"array\", val.value ) ) {\n\t\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {\n\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( val.value[j] ) + \"'\" +\n\t\t\t\t\t\t\t( config[ val.id ] === val.value[j] ?\n\t\t\t\t\t\t\t\t(selection = true) && \" selected='selected'\" :\n\t\t\t\t\t\t\t\t\"\" ) +\n\t\t\t\t\t\t\t\">\" + escapeText( val.value[j] ) + \"</option>\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( j in val.value ) {\n\t\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {\n\t\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( j ) + \"'\" +\n\t\t\t\t\t\t\t\t( config[ val.id ] === j ?\n\t\t\t\t\t\t\t\t\t(selection = true) && \" selected='selected'\" :\n\t\t\t\t\t\t\t\t\t\"\" ) +\n\t\t\t\t\t\t\t\t\">\" + escapeText( val.value[j] ) + \"</option>\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( config[ val.id ] && !selection ) {\n\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( config[ val.id ] ) +\n\t\t\t\t\t\t\"' selected='selected' disabled='disabled'>\" +\n\t\t\t\t\t\tescapeText( config[ val.id ] ) +\n\t\t\t\t\t\t\"</option>\";\n\t\t\t\t}\n\t\t\t\turlConfigHtml += \"</select>\";\n\t\t\t}\n\t\t}\n\t\tfor ( i in config.modules ) {\n\t\t\tif ( config.modules.hasOwnProperty( i ) ) {\n\t\t\t\tmoduleNames.push(i);\n\t\t\t}\n\t\t}\n\t\tnumModules = moduleNames.length;\n\t\tmoduleNames.sort( function( a, b ) {\n\t\t\treturn a.localeCompare( b );\n\t\t});\n\t\tmoduleFilterHtml += \"<label for='qunit-modulefilter'>Module: </label><select id='qunit-modulefilter' name='modulefilter'><option value='' \" +\n\t\t\t( config.module === undefined  ? \"selected='selected'\" : \"\" ) +\n\t\t\t\">< All Modules ></option>\";\n\t\n\t\n\t\tfor ( i = 0; i < numModules; i++) {\n\t\t\t\tmoduleFilterHtml += \"<option value='\" + escapeText( encodeURIComponent(moduleNames[i]) ) + \"' \" +\n\t\t\t\t\t( config.module === moduleNames[i] ? \"selected='selected'\" : \"\" ) +\n\t\t\t\t\t\">\" + escapeText(moduleNames[i]) + \"</option>\";\n\t\t}\n\t\tmoduleFilterHtml += \"</select>\";\n\t\n\t\t// `userAgent` initialized at top of scope\n\t\tuserAgent = id( \"qunit-userAgent\" );\n\t\tif ( userAgent ) {\n\t\t\tuserAgent.innerHTML = navigator.userAgent;\n\t\t}\n\t\n\t\t// `banner` initialized at top of scope\n\t\tbanner = id( \"qunit-header\" );\n\t\tif ( banner ) {\n\t\t\tbanner.innerHTML = \"<a href='\" + QUnit.url({ filter: undefined, module: undefined, testNumber: undefined }) + \"'>\" + banner.innerHTML + \"</a> \";\n\t\t}\n\t\n\t\t// `toolbar` initialized at top of scope\n\t\ttoolbar = id( \"qunit-testrunner-toolbar\" );\n\t\tif ( toolbar ) {\n\t\t\t// `filter` initialized at top of scope\n\t\t\tfilter = document.createElement( \"input\" );\n\t\t\tfilter.type = \"checkbox\";\n\t\t\tfilter.id = \"qunit-filter-pass\";\n\t\n\t\t\taddEvent( filter, \"click\", function() {\n\t\t\t\tvar tmp,\n\t\t\t\t\tol = id( \"qunit-tests\" );\n\t\n\t\t\t\tif ( filter.checked ) {\n\t\t\t\t\tol.className = ol.className + \" hidepass\";\n\t\t\t\t} else {\n\t\t\t\t\ttmp = \" \" + ol.className.replace( /[\\n\\t\\r]/g, \" \" ) + \" \";\n\t\t\t\t\tol.className = tmp.replace( / hidepass /, \" \" );\n\t\t\t\t}\n\t\t\t\tif ( defined.sessionStorage ) {\n\t\t\t\t\tif (filter.checked) {\n\t\t\t\t\t\tsessionStorage.setItem( \"qunit-filter-passed-tests\", \"true\" );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsessionStorage.removeItem( \"qunit-filter-passed-tests\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tif ( config.hidepassed || defined.sessionStorage && sessionStorage.getItem( \"qunit-filter-passed-tests\" ) ) {\n\t\t\t\tfilter.checked = true;\n\t\t\t\t// `ol` initialized at top of scope\n\t\t\t\tol = id( \"qunit-tests\" );\n\t\t\t\tol.className = ol.className + \" hidepass\";\n\t\t\t}\n\t\t\ttoolbar.appendChild( filter );\n\t\n\t\t\t// `label` initialized at top of scope\n\t\t\tlabel = document.createElement( \"label\" );\n\t\t\tlabel.setAttribute( \"for\", \"qunit-filter-pass\" );\n\t\t\tlabel.setAttribute( \"title\", \"Only show tests and assertions that fail. Stored in sessionStorage.\" );\n\t\t\tlabel.innerHTML = \"Hide passed tests\";\n\t\t\ttoolbar.appendChild( label );\n\t\n\t\t\turlConfigContainer = document.createElement(\"span\");\n\t\t\turlConfigContainer.innerHTML = urlConfigHtml;\n\t\t\t// For oldIE support:\n\t\t\t// * Add handlers to the individual elements instead of the container\n\t\t\t// * Use \"click\" instead of \"change\" for checkboxes\n\t\t\t// * Fallback from event.target to event.srcElement\n\t\t\taddEvents( urlConfigContainer.getElementsByTagName(\"input\"), \"click\", function( event ) {\n\t\t\t\tvar params = {},\n\t\t\t\t\ttarget = event.target || event.srcElement;\n\t\t\t\tparams[ target.name ] = target.checked ?\n\t\t\t\t\ttarget.defaultValue || true :\n\t\t\t\t\tundefined;\n\t\t\t\twindow.location = QUnit.url( params );\n\t\t\t});\n\t\t\taddEvents( urlConfigContainer.getElementsByTagName(\"select\"), \"change\", function( event ) {\n\t\t\t\tvar params = {},\n\t\t\t\t\ttarget = event.target || event.srcElement;\n\t\t\t\tparams[ target.name ] = target.options[ target.selectedIndex ].value || undefined;\n\t\t\t\twindow.location = QUnit.url( params );\n\t\t\t});\n\t\t\ttoolbar.appendChild( urlConfigContainer );\n\t\n\t\t\tif (numModules > 1) {\n\t\t\t\tmoduleFilter = document.createElement( \"span\" );\n\t\t\t\tmoduleFilter.setAttribute( \"id\", \"qunit-modulefilter-container\" );\n\t\t\t\tmoduleFilter.innerHTML = moduleFilterHtml;\n\t\t\t\taddEvent( moduleFilter.lastChild, \"change\", function() {\n\t\t\t\t\tvar selectBox = moduleFilter.getElementsByTagName(\"select\")[0],\n\t\t\t\t\t\tselectedModule = decodeURIComponent(selectBox.options[selectBox.selectedIndex].value);\n\t\n\t\t\t\t\twindow.location = QUnit.url({\n\t\t\t\t\t\tmodule: ( selectedModule === \"\" ) ? undefined : selectedModule,\n\t\t\t\t\t\t// Remove any existing filters\n\t\t\t\t\t\tfilter: undefined,\n\t\t\t\t\t\ttestNumber: undefined\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\ttoolbar.appendChild(moduleFilter);\n\t\t\t}\n\t\t}\n\t\n\t\t// `main` initialized at top of scope\n\t\tmain = id( \"qunit-fixture\" );\n\t\tif ( main ) {\n\t\t\tconfig.fixture = main.innerHTML;\n\t\t}\n\t\n\t\tif ( config.autostart ) {\n\t\t\tQUnit.start();\n\t\t}\n\t};\n\t\n\tif ( defined.document ) {\n\t\taddEvent( window, \"load\", QUnit.load );\n\t}\n\t\n\t// `onErrorFnPrev` initialized at top of scope\n\t// Preserve other handlers\n\tonErrorFnPrev = window.onerror;\n\t\n\t// Cover uncaught exceptions\n\t// Returning true will suppress the default browser handler,\n\t// returning false will let it run.\n\twindow.onerror = function ( error, filePath, linerNr ) {\n\t\tvar ret = false;\n\t\tif ( onErrorFnPrev ) {\n\t\t\tret = onErrorFnPrev( error, filePath, linerNr );\n\t\t}\n\t\n\t\t// Treat return value as window.onerror itself does,\n\t\t// Only do our handling if not suppressed.\n\t\tif ( ret !== true ) {\n\t\t\tif ( QUnit.config.current ) {\n\t\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t} else {\n\t\t\t\tQUnit.test( \"global failure\", extend( function() {\n\t\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t\t}, { validTest: validTest } ) );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\n\t\treturn ret;\n\t};\n\t\n\tfunction done() {\n\t\tconfig.autorun = true;\n\t\n\t\t// Log the last module results\n\t\tif ( config.previousModule ) {\n\t\t\trunLoggingCallbacks( \"moduleDone\", QUnit, {\n\t\t\t\tname: config.previousModule,\n\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\ttotal: config.moduleStats.all\n\t\t\t});\n\t\t}\n\t\tdelete config.previousModule;\n\t\n\t\tvar i, key,\n\t\t\tbanner = id( \"qunit-banner\" ),\n\t\t\ttests = id( \"qunit-tests\" ),\n\t\t\truntime = +new Date() - config.started,\n\t\t\tpassed = config.stats.all - config.stats.bad,\n\t\t\thtml = [\n\t\t\t\t\"Tests completed in \",\n\t\t\t\truntime,\n\t\t\t\t\" milliseconds.<br/>\",\n\t\t\t\t\"<span class='passed'>\",\n\t\t\t\tpassed,\n\t\t\t\t\"</span> assertions of <span class='total'>\",\n\t\t\t\tconfig.stats.all,\n\t\t\t\t\"</span> passed, <span class='failed'>\",\n\t\t\t\tconfig.stats.bad,\n\t\t\t\t\"</span> failed.\"\n\t\t\t].join( \"\" );\n\t\n\t\tif ( banner ) {\n\t\t\tbanner.className = ( config.stats.bad ? \"qunit-fail\" : \"qunit-pass\" );\n\t\t}\n\t\n\t\tif ( tests ) {\n\t\t\tid( \"qunit-testresult\" ).innerHTML = html;\n\t\t}\n\t\n\t\tif ( config.altertitle && defined.document && document.title ) {\n\t\t\t// show  for good,  for bad suite result in title\n\t\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\t\tdocument.title = [\n\t\t\t\t( config.stats.bad ? \"\\u2716\" : \"\\u2714\" ),\n\t\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, \"\" )\n\t\t\t].join( \" \" );\n\t\t}\n\t\n\t\t// clear own sessionStorage items if all tests passed\n\t\tif ( config.reorder && defined.sessionStorage && config.stats.bad === 0 ) {\n\t\t\t// `key` & `i` initialized at top of scope\n\t\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\n\t\t\t\tkey = sessionStorage.key( i++ );\n\t\t\t\tif ( key.indexOf( \"qunit-test-\" ) === 0 ) {\n\t\t\t\t\tsessionStorage.removeItem( key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// scroll back to top to show results\n\t\tif ( config.scrolltop && window.scrollTo ) {\n\t\t\twindow.scrollTo(0, 0);\n\t\t}\n\t\n\t\trunLoggingCallbacks( \"done\", QUnit, {\n\t\t\tfailed: config.stats.bad,\n\t\t\tpassed: passed,\n\t\t\ttotal: config.stats.all,\n\t\t\truntime: runtime\n\t\t});\n\t}\n\t\n\t/** @return Boolean: true if this test should be ran */\n\tfunction validTest( test ) {\n\t\tvar include,\n\t\t\tfilter = config.filter && config.filter.toLowerCase(),\n\t\t\tmodule = config.module && config.module.toLowerCase(),\n\t\t\tfullName = ( test.module + \": \" + test.testName ).toLowerCase();\n\t\n\t\t// Internally-generated tests are always valid\n\t\tif ( test.callback && test.callback.validTest === validTest ) {\n\t\t\tdelete test.callback.validTest;\n\t\t\treturn true;\n\t\t}\n\t\n\t\tif ( config.testNumber.length > 0 ) {\n\t\t\tif ( inArray( test.testNumber, config.testNumber ) < 0 ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\n\t\tif ( module && ( !test.module || test.module.toLowerCase() !== module ) ) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tif ( !filter ) {\n\t\t\treturn true;\n\t\t}\n\t\n\t\tinclude = filter.charAt( 0 ) !== \"!\";\n\t\tif ( !include ) {\n\t\t\tfilter = filter.slice( 1 );\n\t\t}\n\t\n\t\t// If the filter matches, we need to honour include\n\t\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\t\treturn include;\n\t\t}\n\t\n\t\t// Otherwise, do the opposite\n\t\treturn !include;\n\t}\n\t\n\t// so far supports only Firefox, Chrome and Opera (buggy), Safari (for real exceptions)\n\t// Later Safari and IE10 are supposed to support error.stack as well\n\t// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\n\tfunction extractStacktrace( e, offset ) {\n\t\toffset = offset === undefined ? 3 : offset;\n\t\n\t\tvar stack, include, i;\n\t\n\t\tif ( e.stacktrace ) {\n\t\t\t// Opera\n\t\t\treturn e.stacktrace.split( \"\\n\" )[ offset + 3 ];\n\t\t} else if ( e.stack ) {\n\t\t\t// Firefox, Chrome\n\t\t\tstack = e.stack.split( \"\\n\" );\n\t\t\tif (/^error$/i.test( stack[0] ) ) {\n\t\t\t\tstack.shift();\n\t\t\t}\n\t\t\tif ( fileName ) {\n\t\t\t\tinclude = [];\n\t\t\t\tfor ( i = offset; i < stack.length; i++ ) {\n\t\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tinclude.push( stack[ i ] );\n\t\t\t\t}\n\t\t\t\tif ( include.length ) {\n\t\t\t\t\treturn include.join( \"\\n\" );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stack[ offset ];\n\t\t} else if ( e.sourceURL ) {\n\t\t\t// Safari, PhantomJS\n\t\t\t// hopefully one day Safari provides actual stacktraces\n\t\t\t// exclude useless self-reference for generated Error objects\n\t\t\tif ( /qunit.js$/.test( e.sourceURL ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// for actual exceptions, this is useful\n\t\t\treturn e.sourceURL + \":\" + e.line;\n\t\t}\n\t}\n\tfunction sourceFromStacktrace( offset ) {\n\t\ttry {\n\t\t\tthrow new Error();\n\t\t} catch ( e ) {\n\t\t\treturn extractStacktrace( e, offset );\n\t\t}\n\t}\n\t\n\t/**\n\t * Escape text for attribute or text content.\n\t */\n\tfunction escapeText( s ) {\n\t\tif ( !s ) {\n\t\t\treturn \"\";\n\t\t}\n\t\ts = s + \"\";\n\t\t// Both single quotes and double quotes (for attributes)\n\t\treturn s.replace( /['\"<>&]/g, function( s ) {\n\t\t\tswitch( s ) {\n\t\t\t\tcase \"'\":\n\t\t\t\t\treturn \"&#039;\";\n\t\t\t\tcase \"\\\"\":\n\t\t\t\t\treturn \"&quot;\";\n\t\t\t\tcase \"<\":\n\t\t\t\t\treturn \"&lt;\";\n\t\t\t\tcase \">\":\n\t\t\t\t\treturn \"&gt;\";\n\t\t\t\tcase \"&\":\n\t\t\t\t\treturn \"&amp;\";\n\t\t\t}\n\t\t});\n\t}\n\t\n\tfunction synchronize( callback, last ) {\n\t\tconfig.queue.push( callback );\n\t\n\t\tif ( config.autorun && !config.blocking ) {\n\t\t\tprocess( last );\n\t\t}\n\t}\n\t\n\tfunction process( last ) {\n\t\tfunction next() {\n\t\t\tprocess( last );\n\t\t}\n\t\tvar start = new Date().getTime();\n\t\tconfig.depth = config.depth ? config.depth + 1 : 1;\n\t\n\t\twhile ( config.queue.length && !config.blocking ) {\n\t\t\tif ( !defined.setTimeout || config.updateRate <= 0 || ( ( new Date().getTime() - start ) < config.updateRate ) ) {\n\t\t\t\tconfig.queue.shift()();\n\t\t\t} else {\n\t\t\t\tsetTimeout( next, 13 );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconfig.depth--;\n\t\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\t\tdone();\n\t\t}\n\t}\n\t\n\tfunction saveGlobal() {\n\t\tconfig.pollution = [];\n\t\n\t\tif ( config.noglobals ) {\n\t\t\tfor ( var key in window ) {\n\t\t\t\tif ( hasOwn.call( window, key ) ) {\n\t\t\t\t\t// in Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconfig.pollution.push( key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction checkPollution() {\n\t\tvar newGlobals,\n\t\t\tdeletedGlobals,\n\t\t\told = config.pollution;\n\t\n\t\tsaveGlobal();\n\t\n\t\tnewGlobals = diff( config.pollution, old );\n\t\tif ( newGlobals.length > 0 ) {\n\t\t\tQUnit.pushFailure( \"Introduced global variable(s): \" + newGlobals.join(\", \") );\n\t\t}\n\t\n\t\tdeletedGlobals = diff( old, config.pollution );\n\t\tif ( deletedGlobals.length > 0 ) {\n\t\t\tQUnit.pushFailure( \"Deleted global variable(s): \" + deletedGlobals.join(\", \") );\n\t\t}\n\t}\n\t\n\t// returns a new Array with the elements that are in a but not in b\n\tfunction diff( a, b ) {\n\t\tvar i, j,\n\t\t\tresult = a.slice();\n\t\n\t\tfor ( i = 0; i < result.length; i++ ) {\n\t\t\tfor ( j = 0; j < b.length; j++ ) {\n\t\t\t\tif ( result[i] === b[j] ) {\n\t\t\t\t\tresult.splice( i, 1 );\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tfunction extend( a, b ) {\n\t\tfor ( var prop in b ) {\n\t\t\tif ( hasOwn.call( b, prop ) ) {\n\t\t\t\t// Avoid \"Member not found\" error in IE8 caused by messing with window.constructor\n\t\t\t\tif ( !( prop === \"constructor\" && a === window ) ) {\n\t\t\t\t\tif ( b[ prop ] === undefined ) {\n\t\t\t\t\t\tdelete a[ prop ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta[ prop ] = b[ prop ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn a;\n\t}\n\t\n\t/**\n\t * @param {HTMLElement} elem\n\t * @param {string} type\n\t * @param {Function} fn\n\t */\n\tfunction addEvent( elem, type, fn ) {\n\t\tif ( elem.addEventListener ) {\n\t\n\t\t\t// Standards-based browsers\n\t\t\telem.addEventListener( type, fn, false );\n\t\t} else if ( elem.attachEvent ) {\n\t\n\t\t\t// support: IE <9\n\t\t\telem.attachEvent( \"on\" + type, fn );\n\t\t} else {\n\t\n\t\t\t// Caller must ensure support for event listeners is present\n\t\t\tthrow new Error( \"addEvent() was called in a context without event listener support\" );\n\t\t}\n\t}\n\t\n\t/**\n\t * @param {Array|NodeList} elems\n\t * @param {string} type\n\t * @param {Function} fn\n\t */\n\tfunction addEvents( elems, type, fn ) {\n\t\tvar i = elems.length;\n\t\twhile ( i-- ) {\n\t\t\taddEvent( elems[i], type, fn );\n\t\t}\n\t}\n\t\n\tfunction hasClass( elem, name ) {\n\t\treturn (\" \" + elem.className + \" \").indexOf(\" \" + name + \" \") > -1;\n\t}\n\t\n\tfunction addClass( elem, name ) {\n\t\tif ( !hasClass( elem, name ) ) {\n\t\t\telem.className += (elem.className ? \" \" : \"\") + name;\n\t\t}\n\t}\n\t\n\tfunction removeClass( elem, name ) {\n\t\tvar set = \" \" + elem.className + \" \";\n\t\t// Class name may appear multiple times\n\t\twhile ( set.indexOf(\" \" + name + \" \") > -1 ) {\n\t\t\tset = set.replace(\" \" + name + \" \" , \" \");\n\t\t}\n\t\t// If possible, trim it for prettiness, but not necessarily\n\t\telem.className = typeof set.trim === \"function\" ? set.trim() : set.replace(/^\\s+|\\s+$/g, \"\");\n\t}\n\t\n\tfunction id( name ) {\n\t\treturn defined.document && document.getElementById && document.getElementById( name );\n\t}\n\t\n\tfunction registerLoggingCallback( key ) {\n\t\treturn function( callback ) {\n\t\t\tconfig[key].push( callback );\n\t\t};\n\t}\n\t\n\t// Supports deprecated method of completely overwriting logging callbacks\n\tfunction runLoggingCallbacks( key, scope, args ) {\n\t\tvar i, callbacks;\n\t\tif ( QUnit.hasOwnProperty( key ) ) {\n\t\t\tQUnit[ key ].call(scope, args );\n\t\t} else {\n\t\t\tcallbacks = config[ key ];\n\t\t\tfor ( i = 0; i < callbacks.length; i++ ) {\n\t\t\t\tcallbacks[ i ].call( scope, args );\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// from jquery.js\n\tfunction inArray( elem, array ) {\n\t\tif ( array.indexOf ) {\n\t\t\treturn array.indexOf( elem );\n\t\t}\n\t\n\t\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\t\tif ( array[ i ] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\n\t\treturn -1;\n\t}\n\t\n\tfunction Test( settings ) {\n\t\textend( this, settings );\n\t\tthis.assertions = [];\n\t\tthis.testNumber = ++Test.count;\n\t}\n\t\n\tTest.count = 0;\n\t\n\tTest.prototype = {\n\t\tinit: function() {\n\t\t\tvar a, b, li,\n\t\t\t\ttests = id( \"qunit-tests\" );\n\t\n\t\t\tif ( tests ) {\n\t\t\t\tb = document.createElement( \"strong\" );\n\t\t\t\tb.innerHTML = this.nameHtml;\n\t\n\t\t\t\t// `a` initialized at top of scope\n\t\t\t\ta = document.createElement( \"a\" );\n\t\t\t\ta.innerHTML = \"Rerun\";\n\t\t\t\ta.href = QUnit.url({ testNumber: this.testNumber });\n\t\n\t\t\t\tli = document.createElement( \"li\" );\n\t\t\t\tli.appendChild( b );\n\t\t\t\tli.appendChild( a );\n\t\t\t\tli.className = \"running\";\n\t\t\t\tli.id = this.id = \"qunit-test-output\" + testId++;\n\t\n\t\t\t\ttests.appendChild( li );\n\t\t\t}\n\t\t},\n\t\tsetup: function() {\n\t\t\tif (\n\t\t\t\t// Emit moduleStart when we're switching from one module to another\n\t\t\t\tthis.module !== config.previousModule ||\n\t\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn't\n\t\t\t\t\t// yet exist it means this is the first test in a suite that isn't wrapped in a\n\t\t\t\t\t// module, in which case we'll just emit a moduleStart event for 'undefined'.\n\t\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t\t!hasOwn.call( config, \"previousModule\" )\n\t\t\t) {\n\t\t\t\tif ( hasOwn.call( config, \"previousModule\" ) ) {\n\t\t\t\t\trunLoggingCallbacks( \"moduleDone\", QUnit, {\n\t\t\t\t\t\tname: config.previousModule,\n\t\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\t\ttotal: config.moduleStats.all\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconfig.previousModule = this.module;\n\t\t\t\tconfig.moduleStats = { all: 0, bad: 0 };\n\t\t\t\trunLoggingCallbacks( \"moduleStart\", QUnit, {\n\t\t\t\t\tname: this.module\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tconfig.current = this;\n\t\n\t\t\tthis.testEnvironment = extend({\n\t\t\t\tsetup: function() {},\n\t\t\t\tteardown: function() {}\n\t\t\t}, this.moduleTestEnvironment );\n\t\n\t\t\tthis.started = +new Date();\n\t\t\trunLoggingCallbacks( \"testStart\", QUnit, {\n\t\t\t\tname: this.testName,\n\t\t\t\tmodule: this.module\n\t\t\t});\n\t\n\t\t\t/*jshint camelcase:false */\n\t\n\t\n\t\t\t/**\n\t\t\t * Expose the current test environment.\n\t\t\t *\n\t\t\t * @deprecated since 1.12.0: Use QUnit.config.current.testEnvironment instead.\n\t\t\t */\n\t\t\tQUnit.current_testEnvironment = this.testEnvironment;\n\t\n\t\t\t/*jshint camelcase:true */\n\t\n\t\t\tif ( !config.pollution ) {\n\t\t\t\tsaveGlobal();\n\t\t\t}\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\tthis.testEnvironment.setup.call( this.testEnvironment, QUnit.assert );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthis.testEnvironment.setup.call( this.testEnvironment, QUnit.assert );\n\t\t\t} catch( e ) {\n\t\t\t\tQUnit.pushFailure( \"Setup failed on \" + this.testName + \": \" + ( e.message || e ), extractStacktrace( e, 1 ) );\n\t\t\t}\n\t\t},\n\t\trun: function() {\n\t\t\tconfig.current = this;\n\t\n\t\t\tvar running = id( \"qunit-testresult\" );\n\t\n\t\t\tif ( running ) {\n\t\t\t\trunning.innerHTML = \"Running: <br/>\" + this.nameHtml;\n\t\t\t}\n\t\n\t\t\tif ( this.async ) {\n\t\t\t\tQUnit.stop();\n\t\t\t}\n\t\n\t\t\tthis.callbackStarted = +new Date();\n\t\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\tthis.callback.call( this.testEnvironment, QUnit.assert );\n\t\t\t\tthis.callbackRuntime = +new Date() - this.callbackStarted;\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\ttry {\n\t\t\t\tthis.callback.call( this.testEnvironment, QUnit.assert );\n\t\t\t\tthis.callbackRuntime = +new Date() - this.callbackStarted;\n\t\t\t} catch( e ) {\n\t\t\t\tthis.callbackRuntime = +new Date() - this.callbackStarted;\n\t\n\t\t\t\tQUnit.pushFailure( \"Died on test #\" + (this.assertions.length + 1) + \" \" + this.stack + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );\n\t\t\t\t// else next test will carry the responsibility\n\t\t\t\tsaveGlobal();\n\t\n\t\t\t\t// Restart the tests if they're blocking\n\t\t\t\tif ( config.blocking ) {\n\t\t\t\t\tQUnit.start();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tteardown: function() {\n\t\t\tconfig.current = this;\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\tif ( typeof this.callbackRuntime === \"undefined\" ) {\n\t\t\t\t\tthis.callbackRuntime = +new Date() - this.callbackStarted;\n\t\t\t\t}\n\t\t\t\tthis.testEnvironment.teardown.call( this.testEnvironment, QUnit.assert );\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tthis.testEnvironment.teardown.call( this.testEnvironment, QUnit.assert );\n\t\t\t\t} catch( e ) {\n\t\t\t\t\tQUnit.pushFailure( \"Teardown failed on \" + this.testName + \": \" + ( e.message || e ), extractStacktrace( e, 1 ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckPollution();\n\t\t},\n\t\tfinish: function() {\n\t\t\tconfig.current = this;\n\t\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\t\tQUnit.pushFailure( \"Expected number of assertions to be defined, but expect() was not called.\", this.stack );\n\t\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\t\tQUnit.pushFailure( \"Expected \" + this.expected + \" assertions, but \" + this.assertions.length + \" were run\", this.stack );\n\t\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\t\tQUnit.pushFailure( \"Expected at least one assertion, but none were run - call expect(0) to accept zero assertions.\", this.stack );\n\t\t\t}\n\t\n\t\t\tvar i, assertion, a, b, time, li, ol,\n\t\t\t\ttest = this,\n\t\t\t\tgood = 0,\n\t\t\t\tbad = 0,\n\t\t\t\ttests = id( \"qunit-tests\" );\n\t\n\t\t\tthis.runtime = +new Date() - this.started;\n\t\t\tconfig.stats.all += this.assertions.length;\n\t\t\tconfig.moduleStats.all += this.assertions.length;\n\t\n\t\t\tif ( tests ) {\n\t\t\t\tol = document.createElement( \"ol\" );\n\t\t\t\tol.className = \"qunit-assert-list\";\n\t\n\t\t\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\t\t\tassertion = this.assertions[i];\n\t\n\t\t\t\t\tli = document.createElement( \"li\" );\n\t\t\t\t\tli.className = assertion.result ? \"pass\" : \"fail\";\n\t\t\t\t\tli.innerHTML = assertion.message || ( assertion.result ? \"okay\" : \"failed\" );\n\t\t\t\t\tol.appendChild( li );\n\t\n\t\t\t\t\tif ( assertion.result ) {\n\t\t\t\t\t\tgood++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbad++;\n\t\t\t\t\t\tconfig.stats.bad++;\n\t\t\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// store result when possible\n\t\t\t\tif ( QUnit.config.reorder && defined.sessionStorage ) {\n\t\t\t\t\tif ( bad ) {\n\t\t\t\t\t\tsessionStorage.setItem( \"qunit-test-\" + this.module + \"-\" + this.testName, bad );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsessionStorage.removeItem( \"qunit-test-\" + this.module + \"-\" + this.testName );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif ( bad === 0 ) {\n\t\t\t\t\taddClass( ol, \"qunit-collapsed\" );\n\t\t\t\t}\n\t\n\t\t\t\t// `b` initialized at top of scope\n\t\t\t\tb = document.createElement( \"strong\" );\n\t\t\t\tb.innerHTML = this.nameHtml + \" <b class='counts'>(<b class='failed'>\" + bad + \"</b>, <b class='passed'>\" + good + \"</b>, \" + this.assertions.length + \")</b>\";\n\t\n\t\t\t\taddEvent(b, \"click\", function() {\n\t\t\t\t\tvar next = b.parentNode.lastChild,\n\t\t\t\t\t\tcollapsed = hasClass( next, \"qunit-collapsed\" );\n\t\t\t\t\t( collapsed ? removeClass : addClass )( next, \"qunit-collapsed\" );\n\t\t\t\t});\n\t\n\t\t\t\taddEvent(b, \"dblclick\", function( e ) {\n\t\t\t\t\tvar target = e && e.target ? e.target : window.event.srcElement;\n\t\t\t\t\tif ( target.nodeName.toLowerCase() === \"span\" || target.nodeName.toLowerCase() === \"b\" ) {\n\t\t\t\t\t\ttarget = target.parentNode;\n\t\t\t\t\t}\n\t\t\t\t\tif ( window.location && target.nodeName.toLowerCase() === \"strong\" ) {\n\t\t\t\t\t\twindow.location = QUnit.url({ testNumber: test.testNumber });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\t// `time` initialized at top of scope\n\t\t\t\ttime = document.createElement( \"span\" );\n\t\t\t\ttime.className = \"runtime\";\n\t\t\t\ttime.innerHTML = this.runtime + \" ms\";\n\t\n\t\t\t\t// `li` initialized at top of scope\n\t\t\t\tli = id( this.id );\n\t\t\t\tli.className = bad ? \"fail\" : \"pass\";\n\t\t\t\tli.removeChild( li.firstChild );\n\t\t\t\ta = li.firstChild;\n\t\t\t\tli.appendChild( b );\n\t\t\t\tli.appendChild( a );\n\t\t\t\tli.appendChild( time );\n\t\t\t\tli.appendChild( ol );\n\t\n\t\t\t} else {\n\t\t\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\t\t\tif ( !this.assertions[i].result ) {\n\t\t\t\t\t\tbad++;\n\t\t\t\t\t\tconfig.stats.bad++;\n\t\t\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\trunLoggingCallbacks( \"testDone\", QUnit, {\n\t\t\t\tname: this.testName,\n\t\t\t\tmodule: this.module,\n\t\t\t\tfailed: bad,\n\t\t\t\tpassed: this.assertions.length - bad,\n\t\t\t\ttotal: this.assertions.length,\n\t\t\t\truntime: this.runtime,\n\t\t\t\t// DEPRECATED: this property will be removed in 2.0.0, use runtime instead\n\t\t\t\tduration: this.runtime\n\t\t\t});\n\t\n\t\t\tQUnit.reset();\n\t\n\t\t\tconfig.current = undefined;\n\t\t},\n\t\n\t\tqueue: function() {\n\t\t\tvar bad,\n\t\t\t\ttest = this;\n\t\n\t\t\tsynchronize(function() {\n\t\t\t\ttest.init();\n\t\t\t});\n\t\t\tfunction run() {\n\t\t\t\t// each of these can by async\n\t\t\t\tsynchronize(function() {\n\t\t\t\t\ttest.setup();\n\t\t\t\t});\n\t\t\t\tsynchronize(function() {\n\t\t\t\t\ttest.run();\n\t\t\t\t});\n\t\t\t\tsynchronize(function() {\n\t\t\t\t\ttest.teardown();\n\t\t\t\t});\n\t\t\t\tsynchronize(function() {\n\t\t\t\t\ttest.finish();\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t// `bad` initialized at top of scope\n\t\t\t// defer when previous test run passed, if storage is available\n\t\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t\t\t\t+sessionStorage.getItem( \"qunit-test-\" + this.module + \"-\" + this.testName );\n\t\n\t\t\tif ( bad ) {\n\t\t\t\trun();\n\t\t\t} else {\n\t\t\t\tsynchronize( run, true );\n\t\t\t}\n\t\t}\n\t};\n\t\n\t// `assert` initialized at top of scope\n\t// Assert helpers\n\t// All of these must either call QUnit.push() or manually do:\n\t// - runLoggingCallbacks( \"log\", .. );\n\t// - config.current.assertions.push({ .. });\n\tassert = QUnit.assert = {\n\t\t/**\n\t\t * Asserts rough true-ish result.\n\t\t * @name ok\n\t\t * @function\n\t\t * @example ok( \"asdfasdf\".length > 5, \"There must be at least 5 chars\" );\n\t\t */\n\t\tok: function( result, msg ) {\n\t\t\tif ( !config.current ) {\n\t\t\t\tthrow new Error( \"ok() assertion outside test context, was \" + sourceFromStacktrace(2) );\n\t\t\t}\n\t\t\tresult = !!result;\n\t\t\tmsg = msg || ( result ? \"okay\" : \"failed\" );\n\t\n\t\t\tvar source,\n\t\t\t\tdetails = {\n\t\t\t\t\tmodule: config.current.module,\n\t\t\t\t\tname: config.current.testName,\n\t\t\t\t\tresult: result,\n\t\t\t\t\tmessage: msg\n\t\t\t\t};\n\t\n\t\t\tmsg = \"<span class='test-message'>\" + escapeText( msg ) + \"</span>\";\n\t\n\t\t\tif ( !result ) {\n\t\t\t\tsource = sourceFromStacktrace( 2 );\n\t\t\t\tif ( source ) {\n\t\t\t\t\tdetails.source = source;\n\t\t\t\t\tmsg += \"<table><tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\t\t\t\tescapeText( source ) +\n\t\t\t\t\t\t\"</pre></td></tr></table>\";\n\t\t\t\t}\n\t\t\t}\n\t\t\trunLoggingCallbacks( \"log\", QUnit, details );\n\t\t\tconfig.current.assertions.push({\n\t\t\t\tresult: result,\n\t\t\t\tmessage: msg\n\t\t\t});\n\t\t},\n\t\n\t\t/**\n\t\t * Assert that the first two arguments are equal, with an optional message.\n\t\t * Prints out both actual and expected values.\n\t\t * @name equal\n\t\t * @function\n\t\t * @example equal( format( \"Received {0} bytes.\", 2), \"Received 2 bytes.\", \"format() replaces {0} with next argument\" );\n\t\t */\n\t\tequal: function( actual, expected, message ) {\n\t\t\t/*jshint eqeqeq:false */\n\t\t\tQUnit.push( expected == actual, actual, expected, message );\n\t\t},\n\t\n\t\t/**\n\t\t * @name notEqual\n\t\t * @function\n\t\t */\n\t\tnotEqual: function( actual, expected, message ) {\n\t\t\t/*jshint eqeqeq:false */\n\t\t\tQUnit.push( expected != actual, actual, expected, message );\n\t\t},\n\t\n\t\t/**\n\t\t * @name propEqual\n\t\t * @function\n\t\t */\n\t\tpropEqual: function( actual, expected, message ) {\n\t\t\tactual = objectValues(actual);\n\t\t\texpected = objectValues(expected);\n\t\t\tQUnit.push( QUnit.equiv(actual, expected), actual, expected, message );\n\t\t},\n\t\n\t\t/**\n\t\t * @name notPropEqual\n\t\t * @function\n\t\t */\n\t\tnotPropEqual: function( actual, expected, message ) {\n\t\t\tactual = objectValues(actual);\n\t\t\texpected = objectValues(expected);\n\t\t\tQUnit.push( !QUnit.equiv(actual, expected), actual, expected, message );\n\t\t},\n\t\n\t\t/**\n\t\t * @name deepEqual\n\t\t * @function\n\t\t */\n\t\tdeepEqual: function( actual, expected, message ) {\n\t\t\tQUnit.push( QUnit.equiv(actual, expected), actual, expected, message );\n\t\t},\n\t\n\t\t/**\n\t\t * @name notDeepEqual\n\t\t * @function\n\t\t */\n\t\tnotDeepEqual: function( actual, expected, message ) {\n\t\t\tQUnit.push( !QUnit.equiv(actual, expected), actual, expected, message );\n\t\t},\n\t\n\t\t/**\n\t\t * @name strictEqual\n\t\t * @function\n\t\t */\n\t\tstrictEqual: function( actual, expected, message ) {\n\t\t\tQUnit.push( expected === actual, actual, expected, message );\n\t\t},\n\t\n\t\t/**\n\t\t * @name notStrictEqual\n\t\t * @function\n\t\t */\n\t\tnotStrictEqual: function( actual, expected, message ) {\n\t\t\tQUnit.push( expected !== actual, actual, expected, message );\n\t\t},\n\t\n\t\t\"throws\": function( block, expected, message ) {\n\t\t\tvar actual,\n\t\t\t\texpectedOutput = expected,\n\t\t\t\tok = false;\n\t\n\t\t\t// 'expected' is optional\n\t\t\tif ( !message && typeof expected === \"string\" ) {\n\t\t\t\tmessage = expected;\n\t\t\t\texpected = null;\n\t\t\t}\n\t\n\t\t\tconfig.current.ignoreGlobalErrors = true;\n\t\t\ttry {\n\t\t\t\tblock.call( config.current.testEnvironment );\n\t\t\t} catch (e) {\n\t\t\t\tactual = e;\n\t\t\t}\n\t\t\tconfig.current.ignoreGlobalErrors = false;\n\t\n\t\t\tif ( actual ) {\n\t\n\t\t\t\t// we don't want to validate thrown error\n\t\t\t\tif ( !expected ) {\n\t\t\t\t\tok = true;\n\t\t\t\t\texpectedOutput = null;\n\t\n\t\t\t\t// expected is an Error object\n\t\t\t\t} else if ( expected instanceof Error ) {\n\t\t\t\t\tok = actual instanceof Error &&\n\t\t\t\t\t\t actual.name === expected.name &&\n\t\t\t\t\t\t actual.message === expected.message;\n\t\n\t\t\t\t// expected is a regexp\n\t\t\t\t} else if ( QUnit.objectType( expected ) === \"regexp\" ) {\n\t\t\t\t\tok = expected.test( errorString( actual ) );\n\t\n\t\t\t\t// expected is a string\n\t\t\t\t} else if ( QUnit.objectType( expected ) === \"string\" ) {\n\t\t\t\t\tok = expected === errorString( actual );\n\t\n\t\t\t\t// expected is a constructor\n\t\t\t\t} else if ( actual instanceof expected ) {\n\t\t\t\t\tok = true;\n\t\n\t\t\t\t// expected is a validation function which returns true is validation passed\n\t\t\t\t} else if ( expected.call( {}, actual ) === true ) {\n\t\t\t\t\texpectedOutput = null;\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\n\t\t\t\tQUnit.push( ok, actual, expectedOutput, message );\n\t\t\t} else {\n\t\t\t\tQUnit.pushFailure( message, null, \"No exception was thrown.\" );\n\t\t\t}\n\t\t}\n\t};\n\t\n\t/**\n\t * @deprecated since 1.8.0\n\t * Kept assertion helpers in root for backwards compatibility.\n\t */\n\textend( QUnit.constructor.prototype, assert );\n\t\n\t/**\n\t * @deprecated since 1.9.0\n\t * Kept to avoid TypeErrors for undefined methods.\n\t */\n\tQUnit.constructor.prototype.raises = function() {\n\t\tQUnit.push( false, false, false, \"QUnit.raises has been deprecated since 2012 (fad3c1ea), use QUnit.throws instead\" );\n\t};\n\t\n\t/**\n\t * @deprecated since 1.0.0, replaced with error pushes since 1.3.0\n\t * Kept to avoid TypeErrors for undefined methods.\n\t */\n\tQUnit.constructor.prototype.equals = function() {\n\t\tQUnit.push( false, false, false, \"QUnit.equals has been deprecated since 2009 (e88049a0), use QUnit.equal instead\" );\n\t};\n\tQUnit.constructor.prototype.same = function() {\n\t\tQUnit.push( false, false, false, \"QUnit.same has been deprecated since 2009 (e88049a0), use QUnit.deepEqual instead\" );\n\t};\n\t\n\t// Test for equality any JavaScript type.\n\t// Author: Philippe Rath <prathe@gmail.com>\n\tQUnit.equiv = (function() {\n\t\n\t\t// Call the o related callback with the given arguments.\n\t\tfunction bindCallbacks( o, callbacks, args ) {\n\t\t\tvar prop = QUnit.objectType( o );\n\t\t\tif ( prop ) {\n\t\t\t\tif ( QUnit.objectType( callbacks[ prop ] ) === \"function\" ) {\n\t\t\t\t\treturn callbacks[ prop ].apply( callbacks, args );\n\t\t\t\t} else {\n\t\t\t\t\treturn callbacks[ prop ]; // or undefined\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// the real equiv function\n\t\tvar innerEquiv,\n\t\t\t// stack to decide between skip/abort functions\n\t\t\tcallers = [],\n\t\t\t// stack to avoiding loops from circular referencing\n\t\t\tparents = [],\n\t\t\tparentsB = [],\n\t\n\t\t\tgetProto = Object.getPrototypeOf || function ( obj ) {\n\t\t\t\t/*jshint camelcase:false */\n\t\t\t\treturn obj.__proto__;\n\t\t\t},\n\t\t\tcallbacks = (function () {\n\t\n\t\t\t\t// for string, boolean, number and null\n\t\t\t\tfunction useStrictEquality( b, a ) {\n\t\t\t\t\t/*jshint eqeqeq:false */\n\t\t\t\t\tif ( b instanceof a.constructor || a instanceof b.constructor ) {\n\t\t\t\t\t\t// to catch short annotation VS 'new' annotation of a\n\t\t\t\t\t\t// declaration\n\t\t\t\t\t\t// e.g. var i = 1;\n\t\t\t\t\t\t// var j = new Number(1);\n\t\t\t\t\t\treturn a == b;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn a === b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn {\n\t\t\t\t\t\"string\": useStrictEquality,\n\t\t\t\t\t\"boolean\": useStrictEquality,\n\t\t\t\t\t\"number\": useStrictEquality,\n\t\t\t\t\t\"null\": useStrictEquality,\n\t\t\t\t\t\"undefined\": useStrictEquality,\n\t\n\t\t\t\t\t\"nan\": function( b ) {\n\t\t\t\t\t\treturn isNaN( b );\n\t\t\t\t\t},\n\t\n\t\t\t\t\t\"date\": function( b, a ) {\n\t\t\t\t\t\treturn QUnit.objectType( b ) === \"date\" && a.valueOf() === b.valueOf();\n\t\t\t\t\t},\n\t\n\t\t\t\t\t\"regexp\": function( b, a ) {\n\t\t\t\t\t\treturn QUnit.objectType( b ) === \"regexp\" &&\n\t\t\t\t\t\t\t// the regex itself\n\t\t\t\t\t\t\ta.source === b.source &&\n\t\t\t\t\t\t\t// and its modifiers\n\t\t\t\t\t\t\ta.global === b.global &&\n\t\t\t\t\t\t\t// (gmi) ...\n\t\t\t\t\t\t\ta.ignoreCase === b.ignoreCase &&\n\t\t\t\t\t\t\ta.multiline === b.multiline &&\n\t\t\t\t\t\t\ta.sticky === b.sticky;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// - skip when the property is a method of an instance (OOP)\n\t\t\t\t\t// - abort otherwise,\n\t\t\t\t\t// initial === would have catch identical references anyway\n\t\t\t\t\t\"function\": function() {\n\t\t\t\t\t\tvar caller = callers[callers.length - 1];\n\t\t\t\t\t\treturn caller !== Object && typeof caller !== \"undefined\";\n\t\t\t\t\t},\n\t\n\t\t\t\t\t\"array\": function( b, a ) {\n\t\t\t\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\t\n\t\t\t\t\t\t// b could be an object literal here\n\t\t\t\t\t\tif ( QUnit.objectType( b ) !== \"array\" ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tlen = a.length;\n\t\t\t\t\t\tif ( len !== b.length ) {\n\t\t\t\t\t\t\t// safe and faster\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// track reference to avoid circular references\n\t\t\t\t\t\tparents.push( a );\n\t\t\t\t\t\tparentsB.push( b );\n\t\t\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\t\t\tloop = false;\n\t\t\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\t\t\t\taCircular = parents[j] === a[i];\n\t\t\t\t\t\t\t\tbCircular = parentsB[j] === b[i];\n\t\t\t\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\t\t\t\tif ( a[i] === b[i] || aCircular && bCircular ) {\n\t\t\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( !loop && !innerEquiv(a[i], b[i]) ) {\n\t\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t\"object\": function( b, a ) {\n\t\t\t\t\t\t/*jshint forin:false */\n\t\t\t\t\t\tvar i, j, loop, aCircular, bCircular,\n\t\t\t\t\t\t\t// Default to true\n\t\t\t\t\t\t\teq = true,\n\t\t\t\t\t\t\taProperties = [],\n\t\t\t\t\t\t\tbProperties = [];\n\t\n\t\t\t\t\t\t// comparing constructors is more strict than using\n\t\t\t\t\t\t// instanceof\n\t\t\t\t\t\tif ( a.constructor !== b.constructor ) {\n\t\t\t\t\t\t\t// Allow objects with no prototype to be equivalent to\n\t\t\t\t\t\t\t// objects with Object as their constructor.\n\t\t\t\t\t\t\tif ( !(( getProto(a) === null && getProto(b) === Object.prototype ) ||\n\t\t\t\t\t\t\t\t( getProto(b) === null && getProto(a) === Object.prototype ) ) ) {\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// stack constructor before traversing properties\n\t\t\t\t\t\tcallers.push( a.constructor );\n\t\n\t\t\t\t\t\t// track reference to avoid circular references\n\t\t\t\t\t\tparents.push( a );\n\t\t\t\t\t\tparentsB.push( b );\n\t\n\t\t\t\t\t\t// be strict: don't ensure hasOwnProperty and go deep\n\t\t\t\t\t\tfor ( i in a ) {\n\t\t\t\t\t\t\tloop = false;\n\t\t\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\t\t\t\taCircular = parents[j] === a[i];\n\t\t\t\t\t\t\t\tbCircular = parentsB[j] === b[i];\n\t\t\t\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\t\t\t\tif ( a[i] === b[i] || aCircular && bCircular ) {\n\t\t\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\taProperties.push(i);\n\t\t\t\t\t\t\tif ( !loop && !innerEquiv(a[i], b[i]) ) {\n\t\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\tcallers.pop(); // unstack, we are done\n\t\n\t\t\t\t\t\tfor ( i in b ) {\n\t\t\t\t\t\t\tbProperties.push( i ); // collect b's properties\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Ensures identical properties name\n\t\t\t\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}());\n\t\n\t\tinnerEquiv = function() { // can take multiple arguments\n\t\t\tvar args = [].slice.apply( arguments );\n\t\t\tif ( args.length < 2 ) {\n\t\t\t\treturn true; // end transition\n\t\t\t}\n\t\n\t\t\treturn (function( a, b ) {\n\t\t\t\tif ( a === b ) {\n\t\t\t\t\treturn true; // catch the most you can\n\t\t\t\t} else if ( a === null || b === null || typeof a === \"undefined\" ||\n\t\t\t\t\t\ttypeof b === \"undefined\" ||\n\t\t\t\t\t\tQUnit.objectType(a) !== QUnit.objectType(b) ) {\n\t\t\t\t\treturn false; // don't lose time with error prone cases\n\t\t\t\t} else {\n\t\t\t\t\treturn bindCallbacks(a, callbacks, [ b, a ]);\n\t\t\t\t}\n\t\n\t\t\t\t// apply transition with (1..n) arguments\n\t\t\t}( args[0], args[1] ) && innerEquiv.apply( this, args.splice(1, args.length - 1 )) );\n\t\t};\n\t\n\t\treturn innerEquiv;\n\t}());\n\t\n\t/**\n\t * jsDump Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com |\n\t * http://flesler.blogspot.com Licensed under BSD\n\t * (http://www.opensource.org/licenses/bsd-license.php) Date: 5/15/2008\n\t *\n\t * @projectDescription Advanced and extensible data dumping for Javascript.\n\t * @version 1.0.0\n\t * @author Ariel Flesler\n\t * @link {http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html}\n\t */\n\tQUnit.jsDump = (function() {\n\t\tfunction quote( str ) {\n\t\t\treturn \"\\\"\" + str.toString().replace( /\"/g, \"\\\\\\\"\" ) + \"\\\"\";\n\t\t}\n\t\tfunction literal( o ) {\n\t\t\treturn o + \"\";\n\t\t}\n\t\tfunction join( pre, arr, post ) {\n\t\t\tvar s = jsDump.separator(),\n\t\t\t\tbase = jsDump.indent(),\n\t\t\t\tinner = jsDump.indent(1);\n\t\t\tif ( arr.join ) {\n\t\t\t\tarr = arr.join( \",\" + s + inner );\n\t\t\t}\n\t\t\tif ( !arr ) {\n\t\t\t\treturn pre + post;\n\t\t\t}\n\t\t\treturn [ pre, inner + arr, base + post ].join(s);\n\t\t}\n\t\tfunction array( arr, stack ) {\n\t\t\tvar i = arr.length, ret = new Array(i);\n\t\t\tthis.up();\n\t\t\twhile ( i-- ) {\n\t\t\t\tret[i] = this.parse( arr[i] , undefined , stack);\n\t\t\t}\n\t\t\tthis.down();\n\t\t\treturn join( \"[\", ret, \"]\" );\n\t\t}\n\t\n\t\tvar reName = /^function (\\w+)/,\n\t\t\tjsDump = {\n\t\t\t\t// type is used mostly internally, you can fix a (custom)type in advance\n\t\t\t\tparse: function( obj, type, stack ) {\n\t\t\t\t\tstack = stack || [ ];\n\t\t\t\t\tvar inStack, res,\n\t\t\t\t\t\tparser = this.parsers[ type || this.typeOf(obj) ];\n\t\n\t\t\t\t\ttype = typeof parser;\n\t\t\t\t\tinStack = inArray( obj, stack );\n\t\n\t\t\t\t\tif ( inStack !== -1 ) {\n\t\t\t\t\t\treturn \"recursion(\" + (inStack - stack.length) + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tif ( type === \"function\" )  {\n\t\t\t\t\t\tstack.push( obj );\n\t\t\t\t\t\tres = parser.call( this, obj, stack );\n\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t\treturn ( type === \"string\" ) ? parser : this.parsers.error;\n\t\t\t\t},\n\t\t\t\ttypeOf: function( obj ) {\n\t\t\t\t\tvar type;\n\t\t\t\t\tif ( obj === null ) {\n\t\t\t\t\t\ttype = \"null\";\n\t\t\t\t\t} else if ( typeof obj === \"undefined\" ) {\n\t\t\t\t\t\ttype = \"undefined\";\n\t\t\t\t\t} else if ( QUnit.is( \"regexp\", obj) ) {\n\t\t\t\t\t\ttype = \"regexp\";\n\t\t\t\t\t} else if ( QUnit.is( \"date\", obj) ) {\n\t\t\t\t\t\ttype = \"date\";\n\t\t\t\t\t} else if ( QUnit.is( \"function\", obj) ) {\n\t\t\t\t\t\ttype = \"function\";\n\t\t\t\t\t} else if ( typeof obj.setInterval !== undefined && typeof obj.document !== \"undefined\" && typeof obj.nodeType === \"undefined\" ) {\n\t\t\t\t\t\ttype = \"window\";\n\t\t\t\t\t} else if ( obj.nodeType === 9 ) {\n\t\t\t\t\t\ttype = \"document\";\n\t\t\t\t\t} else if ( obj.nodeType ) {\n\t\t\t\t\t\ttype = \"node\";\n\t\t\t\t\t} else if (\n\t\t\t\t\t\t// native arrays\n\t\t\t\t\t\ttoString.call( obj ) === \"[object Array]\" ||\n\t\t\t\t\t\t// NodeList objects\n\t\t\t\t\t\t( typeof obj.length === \"number\" && typeof obj.item !== \"undefined\" && ( obj.length ? obj.item(0) === obj[0] : ( obj.item( 0 ) === null && typeof obj[0] === \"undefined\" ) ) )\n\t\t\t\t\t) {\n\t\t\t\t\t\ttype = \"array\";\n\t\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {\n\t\t\t\t\t\ttype = \"error\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype = typeof obj;\n\t\t\t\t\t}\n\t\t\t\t\treturn type;\n\t\t\t\t},\n\t\t\t\tseparator: function() {\n\t\t\t\t\treturn this.multiline ?\tthis.HTML ? \"<br />\" : \"\\n\" : this.HTML ? \"&nbsp;\" : \" \";\n\t\t\t\t},\n\t\t\t\t// extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\t\tindent: function( extra ) {\n\t\t\t\t\tif ( !this.multiline ) {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\t\t\t\t\tvar chr = this.indentChar;\n\t\t\t\t\tif ( this.HTML ) {\n\t\t\t\t\t\tchr = chr.replace( /\\t/g, \"   \" ).replace( / /g, \"&nbsp;\" );\n\t\t\t\t\t}\n\t\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join(chr);\n\t\t\t\t},\n\t\t\t\tup: function( a ) {\n\t\t\t\t\tthis.depth += a || 1;\n\t\t\t\t},\n\t\t\t\tdown: function( a ) {\n\t\t\t\t\tthis.depth -= a || 1;\n\t\t\t\t},\n\t\t\t\tsetParser: function( name, parser ) {\n\t\t\t\t\tthis.parsers[name] = parser;\n\t\t\t\t},\n\t\t\t\t// The next 3 are exposed so you can use them\n\t\t\t\tquote: quote,\n\t\t\t\tliteral: literal,\n\t\t\t\tjoin: join,\n\t\t\t\t//\n\t\t\t\tdepth: 1,\n\t\t\t\t// This is the list of parsers, to modify them, use jsDump.setParser\n\t\t\t\tparsers: {\n\t\t\t\t\twindow: \"[Window]\",\n\t\t\t\t\tdocument: \"[Document]\",\n\t\t\t\t\terror: function(error) {\n\t\t\t\t\t\treturn \"Error(\\\"\" + error.message + \"\\\")\";\n\t\t\t\t\t},\n\t\t\t\t\tunknown: \"[Unknown]\",\n\t\t\t\t\t\"null\": \"null\",\n\t\t\t\t\t\"undefined\": \"undefined\",\n\t\t\t\t\t\"function\": function( fn ) {\n\t\t\t\t\t\tvar ret = \"function\",\n\t\t\t\t\t\t\t// functions never have name in IE\n\t\t\t\t\t\t\tname = \"name\" in fn ? fn.name : (reName.exec(fn) || [])[1];\n\t\n\t\t\t\t\t\tif ( name ) {\n\t\t\t\t\t\t\tret += \" \" + name;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret += \"( \";\n\t\n\t\t\t\t\t\tret = [ ret, QUnit.jsDump.parse( fn, \"functionArgs\" ), \"){\" ].join( \"\" );\n\t\t\t\t\t\treturn join( ret, QUnit.jsDump.parse(fn,\"functionCode\" ), \"}\" );\n\t\t\t\t\t},\n\t\t\t\t\tarray: array,\n\t\t\t\t\tnodelist: array,\n\t\t\t\t\t\"arguments\": array,\n\t\t\t\t\tobject: function( map, stack ) {\n\t\t\t\t\t\t/*jshint forin:false */\n\t\t\t\t\t\tvar ret = [ ], keys, key, val, i;\n\t\t\t\t\t\tQUnit.jsDump.up();\n\t\t\t\t\t\tkeys = [];\n\t\t\t\t\t\tfor ( key in map ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkeys.sort();\n\t\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\n\t\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\t\tval = map[ key ];\n\t\t\t\t\t\t\tret.push( QUnit.jsDump.parse( key, \"key\" ) + \": \" + QUnit.jsDump.parse( val, undefined, stack ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tQUnit.jsDump.down();\n\t\t\t\t\t\treturn join( \"{\", ret, \"}\" );\n\t\t\t\t\t},\n\t\t\t\t\tnode: function( node ) {\n\t\t\t\t\t\tvar len, i, val,\n\t\t\t\t\t\t\topen = QUnit.jsDump.HTML ? \"&lt;\" : \"<\",\n\t\t\t\t\t\t\tclose = QUnit.jsDump.HTML ? \"&gt;\" : \">\",\n\t\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\n\t\t\t\t\t\t\tret = open + tag,\n\t\t\t\t\t\t\tattrs = node.attributes;\n\t\n\t\t\t\t\t\tif ( attrs ) {\n\t\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {\n\t\t\t\t\t\t\t\tval = attrs[i].nodeValue;\n\t\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly set.\n\t\t\t\t\t\t\t\t// Those have values like undefined, null, 0, false, \"\" or \"inherit\".\n\t\t\t\t\t\t\t\tif ( val && val !== \"inherit\" ) {\n\t\t\t\t\t\t\t\t\tret += \" \" + attrs[i].nodeName + \"=\" + QUnit.jsDump.parse( val, \"attribute\" );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret += close;\n\t\n\t\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {\n\t\t\t\t\t\t\tret += node.nodeValue;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn ret + open + \"/\" + tag + close;\n\t\t\t\t\t},\n\t\t\t\t\t// function calls it internally, it's the arguments part of the function\n\t\t\t\t\tfunctionArgs: function( fn ) {\n\t\t\t\t\t\tvar args,\n\t\t\t\t\t\t\tl = fn.length;\n\t\n\t\t\t\t\t\tif ( !l ) {\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\targs = new Array(l);\n\t\t\t\t\t\twhile ( l-- ) {\n\t\t\t\t\t\t\t// 97 is 'a'\n\t\t\t\t\t\t\targs[l] = String.fromCharCode(97+l);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn \" \" + args.join( \", \" ) + \" \";\n\t\t\t\t\t},\n\t\t\t\t\t// object calls it internally, the key part of an item in a map\n\t\t\t\t\tkey: quote,\n\t\t\t\t\t// function calls it internally, it's the content of the function\n\t\t\t\t\tfunctionCode: \"[code]\",\n\t\t\t\t\t// node calls it internally, it's an html attribute value\n\t\t\t\t\tattribute: quote,\n\t\t\t\t\tstring: quote,\n\t\t\t\t\tdate: quote,\n\t\t\t\t\tregexp: literal,\n\t\t\t\t\tnumber: literal,\n\t\t\t\t\t\"boolean\": literal\n\t\t\t\t},\n\t\t\t\t// if true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\t\tHTML: false,\n\t\t\t\t// indentation unit\n\t\t\t\tindentChar: \"  \",\n\t\t\t\t// if true, items in a collection, are separated by a \\n, else just a space.\n\t\t\t\tmultiline: true\n\t\t\t};\n\t\n\t\treturn jsDump;\n\t}());\n\t\n\t/*\n\t * Javascript Diff Algorithm\n\t *  By John Resig (http://ejohn.org/)\n\t *  Modified by Chu Alan \"sprite\"\n\t *\n\t * Released under the MIT license.\n\t *\n\t * More Info:\n\t *  http://ejohn.org/projects/javascript-diff-algorithm/\n\t *\n\t * Usage: QUnit.diff(expected, actual)\n\t *\n\t * QUnit.diff( \"the quick brown fox jumped over\", \"the quick fox jumps over\" ) == \"the  quick <del>brown </del> fox <del>jumped </del><ins>jumps </ins> over\"\n\t */\n\tQUnit.diff = (function() {\n\t\t/*jshint eqeqeq:false, eqnull:true */\n\t\tfunction diff( o, n ) {\n\t\t\tvar i,\n\t\t\t\tns = {},\n\t\t\t\tos = {};\n\t\n\t\t\tfor ( i = 0; i < n.length; i++ ) {\n\t\t\t\tif ( !hasOwn.call( ns, n[i] ) ) {\n\t\t\t\t\tns[ n[i] ] = {\n\t\t\t\t\t\trows: [],\n\t\t\t\t\t\to: null\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tns[ n[i] ].rows.push( i );\n\t\t\t}\n\t\n\t\t\tfor ( i = 0; i < o.length; i++ ) {\n\t\t\t\tif ( !hasOwn.call( os, o[i] ) ) {\n\t\t\t\t\tos[ o[i] ] = {\n\t\t\t\t\t\trows: [],\n\t\t\t\t\t\tn: null\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tos[ o[i] ].rows.push( i );\n\t\t\t}\n\t\n\t\t\tfor ( i in ns ) {\n\t\t\t\tif ( hasOwn.call( ns, i ) ) {\n\t\t\t\t\tif ( ns[i].rows.length === 1 && hasOwn.call( os, i ) && os[i].rows.length === 1 ) {\n\t\t\t\t\t\tn[ ns[i].rows[0] ] = {\n\t\t\t\t\t\t\ttext: n[ ns[i].rows[0] ],\n\t\t\t\t\t\t\trow: os[i].rows[0]\n\t\t\t\t\t\t};\n\t\t\t\t\t\to[ os[i].rows[0] ] = {\n\t\t\t\t\t\t\ttext: o[ os[i].rows[0] ],\n\t\t\t\t\t\t\trow: ns[i].rows[0]\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfor ( i = 0; i < n.length - 1; i++ ) {\n\t\t\t\tif ( n[i].text != null && n[ i + 1 ].text == null && n[i].row + 1 < o.length && o[ n[i].row + 1 ].text == null &&\n\t\t\t\t\t\t\tn[ i + 1 ] == o[ n[i].row + 1 ] ) {\n\t\n\t\t\t\t\tn[ i + 1 ] = {\n\t\t\t\t\t\ttext: n[ i + 1 ],\n\t\t\t\t\t\trow: n[i].row + 1\n\t\t\t\t\t};\n\t\t\t\t\to[ n[i].row + 1 ] = {\n\t\t\t\t\t\ttext: o[ n[i].row + 1 ],\n\t\t\t\t\t\trow: i + 1\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfor ( i = n.length - 1; i > 0; i-- ) {\n\t\t\t\tif ( n[i].text != null && n[ i - 1 ].text == null && n[i].row > 0 && o[ n[i].row - 1 ].text == null &&\n\t\t\t\t\t\t\tn[ i - 1 ] == o[ n[i].row - 1 ]) {\n\t\n\t\t\t\t\tn[ i - 1 ] = {\n\t\t\t\t\t\ttext: n[ i - 1 ],\n\t\t\t\t\t\trow: n[i].row - 1\n\t\t\t\t\t};\n\t\t\t\t\to[ n[i].row - 1 ] = {\n\t\t\t\t\t\ttext: o[ n[i].row - 1 ],\n\t\t\t\t\t\trow: i - 1\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\to: o,\n\t\t\t\tn: n\n\t\t\t};\n\t\t}\n\t\n\t\treturn function( o, n ) {\n\t\t\to = o.replace( /\\s+$/, \"\" );\n\t\t\tn = n.replace( /\\s+$/, \"\" );\n\t\n\t\t\tvar i, pre,\n\t\t\t\tstr = \"\",\n\t\t\t\tout = diff( o === \"\" ? [] : o.split(/\\s+/), n === \"\" ? [] : n.split(/\\s+/) ),\n\t\t\t\toSpace = o.match(/\\s+/g),\n\t\t\t\tnSpace = n.match(/\\s+/g);\n\t\n\t\t\tif ( oSpace == null ) {\n\t\t\t\toSpace = [ \" \" ];\n\t\t\t}\n\t\t\telse {\n\t\t\t\toSpace.push( \" \" );\n\t\t\t}\n\t\n\t\t\tif ( nSpace == null ) {\n\t\t\t\tnSpace = [ \" \" ];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnSpace.push( \" \" );\n\t\t\t}\n\t\n\t\t\tif ( out.n.length === 0 ) {\n\t\t\t\tfor ( i = 0; i < out.o.length; i++ ) {\n\t\t\t\t\tstr += \"<del>\" + out.o[i] + oSpace[i] + \"</del>\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( out.n[0].text == null ) {\n\t\t\t\t\tfor ( n = 0; n < out.o.length && out.o[n].text == null; n++ ) {\n\t\t\t\t\t\tstr += \"<del>\" + out.o[n] + oSpace[n] + \"</del>\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tfor ( i = 0; i < out.n.length; i++ ) {\n\t\t\t\t\tif (out.n[i].text == null) {\n\t\t\t\t\t\tstr += \"<ins>\" + out.n[i] + nSpace[i] + \"</ins>\";\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// `pre` initialized at top of scope\n\t\t\t\t\t\tpre = \"\";\n\t\n\t\t\t\t\t\tfor ( n = out.n[i].row + 1; n < out.o.length && out.o[n].text == null; n++ ) {\n\t\t\t\t\t\t\tpre += \"<del>\" + out.o[n] + oSpace[n] + \"</del>\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstr += \" \" + out.n[i].text + nSpace[i] + pre;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn str;\n\t\t};\n\t}());\n\t\n\t// For browser, export only select globals\n\tif ( typeof window !== \"undefined\" ) {\n\t\textend( window, QUnit.constructor.prototype );\n\t\twindow.QUnit = QUnit;\n\t}\n\t\n\t// For CommonJS environments, export everything\n\tif ( typeof module !== \"undefined\" && module.exports ) {\n\t\tmodule.exports = QUnit;\n\t}\n\t\n\t\n\t// Get a reference to the global object, like window in browsers\n\t}( (function() {\n\t\treturn this;\n\t})() ));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n\t * QUnit-TAP - A TAP Output Producer Plugin for QUnit\n\t *\n\t * https://github.com/twada/qunit-tap\n\t * version: 1.5.0\n\t *\n\t * Copyright (c) 2010-2014 Takuto Wada\n\t * Dual licensed under the MIT and GPLv2 licenses.\n\t *   https://raw.github.com/twada/qunit-tap/master/MIT-LICENSE.txt\n\t *   https://raw.github.com/twada/qunit-tap/master/GPL-LICENSE.txt\n\t *\n\t * A part of extend function is:\n\t *   Copyright 2012 jQuery Foundation and other contributors\n\t *   Released under the MIT license.\n\t *   http://jquery.org/license\n\t */\n\t(function (root, factory) {\n\t    'use strict';\n\t\n\t    // using returnExports UMD pattern\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        module.exports = factory();\n\t    } else {\n\t        root.qunitTap = factory();\n\t    }\n\t}(this, function () {\n\t    'use strict';\n\t\n\t    var qunitTapVersion = '1.5.0',\n\t        slice = Array.prototype.slice;\n\t\n\t    // borrowed from qunit.js\n\t    function extend (a, b) {\n\t        var prop;\n\t        for (prop in b) {\n\t            if (b.hasOwnProperty(prop)) {\n\t                if (typeof b[prop] === 'undefined') {\n\t                    delete a[prop];\n\t                } else {\n\t                    a[prop] = b[prop];\n\t                }\n\t            }\n\t        }\n\t        return a;\n\t    }\n\t\n\t    function indexOf (ary, element) {\n\t        var i;\n\t        for (i = 0; i < ary.length; i += 1) {\n\t            if (ary[i] === element) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t\n\t    function removeElement (ary, element) {\n\t        var index = indexOf(ary, element);\n\t        if (index !== -1) {\n\t            return ary.splice(index, 1);\n\t        } else {\n\t            return [];\n\t        }\n\t    }\n\t\n\t    function isPlanRequired (conf) {\n\t        return (typeof conf !== 'undefined' && typeof conf.requireExpects !== 'undefined' && conf.requireExpects);\n\t    }\n\t\n\t    function isPassed (details) {\n\t        return !!(details.result);\n\t    }\n\t\n\t    function isFailed (details) {\n\t        return !(isPassed(details));\n\t    }\n\t\n\t    function isAssertOkFailed (details) {\n\t        return isFailed(details) && typeof details.expected === 'undefined' && typeof details.actual === 'undefined';\n\t    }\n\t\n\t    function escapeLineEndings (str) {\n\t        return str.replace(/(\\r?\\n)/g, '$&# ');\n\t    }\n\t\n\t    function ltrim (str) {\n\t        return str.replace(/^\\s+/, '');\n\t    }\n\t\n\t    function noop (obj) {\n\t        return obj;\n\t    }\n\t\n\t    function render (desc, fieldName, fieldValue, formatter) {\n\t        desc.push(fieldName + ': ' + formatter(fieldValue));\n\t    }\n\t\n\t    function renderIf (shouldRender, desc, fieldName, fieldValue, formatter) {\n\t        if (!shouldRender || typeof fieldValue === 'undefined') {\n\t            return;\n\t        }\n\t        render(desc, fieldName, fieldValue, formatter);\n\t    }\n\t\n\t    function formatTestLine (testLine, rest) {\n\t        if (!rest) {\n\t            return testLine;\n\t        }\n\t        return testLine + ' - ' + escapeLineEndings(rest);\n\t    }\n\t\n\t    var createCallbackAppenderFor = function (qu) {\n\t        return function (subject, observer, event) {\n\t            var originalLoggingCallback = subject[event],\n\t                callback = function () {\n\t                    // make listener methods (moduleStart,testStart,log, ...) overridable.\n\t                    observer[event].apply(observer, slice.apply(arguments));\n\t                };\n\t            originalLoggingCallback(callback);\n\t            return callback;\n\t        };\n\t    };\n\t\n\t\n\t    /**\n\t     * QUnit-TAP - A TAP Output Producer Plugin for QUnit\n\t     * @param qunitObject QUnit object reference.\n\t     * @param printLikeFunction print-like function for TAP output (assumes line-separator is added by this function for each call).\n\t     * @param options configuration options to customize default behavior.\n\t     * @return object to provide QUnit-TAP API and customization subject.\n\t     */\n\t    function qunitTap(qunitObject, printLikeFunction, options) {\n\t        if (!qunitObject) {\n\t            throw new Error('should pass QUnit object reference. Please check QUnit\\'s \"require\" path if you are using Node.js (or any CommonJS env).');\n\t        } else if (typeof printLikeFunction !== 'function') {\n\t            throw new Error('should pass print-like function');\n\t        }\n\t\n\t        var qu = qunitObject,\n\t            tap = {},\n\t            jsDumpExists = (typeof qu.jsDump !== 'undefined' && typeof qu.jsDump.parse === 'function'),\n\t            explain = (jsDumpExists ? function explain (obj) { return qu.jsDump.parse(obj); } : noop),\n\t            deprecateOption = function deprecateOption (optionName, fallback) {\n\t                // option deprecation and fallback function\n\t                if (!options || typeof options !== 'object') {\n\t                    return;\n\t                }\n\t                if (typeof options[optionName] === 'undefined') {\n\t                    return;\n\t                }\n\t                printLikeFunction('# WARNING: Option \"' + optionName + '\" is deprecated and will be removed in future version.');\n\t                fallback(options[optionName]);\n\t            },\n\t            targetEvents = [\n\t                'moduleStart',\n\t                'testStart',\n\t                'log',\n\t                'testDone',\n\t                'done'\n\t            ],\n\t            registeredCallbacks = {};\n\t\n\t\n\t        tap.config = extend(\n\t            {\n\t                initialCount: 1,\n\t                showModuleNameOnFailure: true,\n\t                showTestNameOnFailure: true,\n\t                showExpectationOnFailure: true,\n\t                showSourceOnFailure: true\n\t            },\n\t            options\n\t        );\n\t        deprecateOption('noPlan', function (flag) {\n\t            printLikeFunction('# Now QUnit-TAP works as with \"noPlan: true\" by default. If you want to delare plan explicitly, please use \"QUnit.config.requireExpects\" option instead.');\n\t            tap.config.noPlan = flag;\n\t        });\n\t        deprecateOption('count', function (count) {\n\t            tap.config.initialCount = (count + 1);\n\t        });\n\t        deprecateOption('showDetailsOnFailure', function (flag) {\n\t            tap.config.showModuleNameOnFailure = flag;\n\t            tap.config.showTestNameOnFailure = flag;\n\t            tap.config.showExpectationOnFailure = flag;\n\t            tap.config.showSourceOnFailure = flag;\n\t        });\n\t        tap.VERSION = qunitTapVersion;\n\t        tap.puts = printLikeFunction;\n\t        tap.count = tap.config.initialCount - 1;\n\t        tap.expectedCount = tap.config.initialCount - 1;\n\t\n\t        function isEnabled (configName) {\n\t            return tap.config[configName];\n\t        }\n\t\n\t        function formatDetails (details) {\n\t            if (isPassed(details)) {\n\t                return details.message;\n\t            }\n\t            var desc = [];\n\t            if (details.message) {\n\t                desc.push(details.message);\n\t            }\n\t            if (isEnabled('showExpectationOnFailure') && !(isAssertOkFailed(details))) {\n\t                render(desc, 'expected', details.expected, explain);\n\t                render(desc, 'got', details.actual, explain);\n\t            }\n\t            renderIf(isEnabled('showTestNameOnFailure'), desc, 'test', details.name, noop);\n\t            renderIf(isEnabled('showModuleNameOnFailure'), desc, 'module', details.module, noop);\n\t            renderIf(isEnabled('showSourceOnFailure'), desc, 'source', details.source, ltrim);\n\t            return desc.join(', ');\n\t        }\n\t\n\t        function printPlanLine (toCount) {\n\t            tap.puts(tap.config.initialCount + '..' + toCount);\n\t        }\n\t\n\t        function unsubscribeEvent (eventName) {\n\t            var listeners;\n\t            if (indexOf(targetEvents, eventName) === -1) {\n\t                return;\n\t            }\n\t            listeners = qu.config[eventName];\n\t            if (typeof listeners === 'undefined') {\n\t                return;\n\t            }\n\t            removeElement(listeners, registeredCallbacks[eventName]);\n\t        }\n\t\n\t        function unsubscribeEvents (eventNames) {\n\t            var i;\n\t            for (i = 0; i < eventNames.length; i += 1) {\n\t                unsubscribeEvent(eventNames[i]);\n\t            }\n\t        }\n\t\n\t        tap.explain = explain;\n\t\n\t        tap.note = function note (obj) {\n\t            tap.puts(escapeLineEndings('# ' + obj));\n\t        };\n\t\n\t        tap.diag = function diag (obj) {\n\t            tap.note(obj);\n\t            return false;\n\t        };\n\t\n\t        tap.moduleStart = function moduleStart (arg) {\n\t            var name = (typeof arg === 'string') ? arg : arg.name;\n\t            tap.note('module: ' + name);\n\t        };\n\t\n\t        tap.testStart = function testStart (arg) {\n\t            var name = (typeof arg === 'string') ? arg : arg.name;\n\t            tap.note('test: ' + name);\n\t        };\n\t\n\t        tap.log = function log (details) {\n\t            var testLine = '';\n\t            tap.count += 1;\n\t            if (isFailed(details)) {\n\t                testLine += 'not ';\n\t            }\n\t            testLine += ('ok ' + tap.count);\n\t            tap.puts(formatTestLine(testLine, formatDetails(details)));\n\t        };\n\t\n\t        tap.testDone = function testDone () {\n\t            if (isPlanRequired(qu.config)) {\n\t                tap.expectedCount += qu.config.current.expected;\n\t            }\n\t        };\n\t\n\t        tap.done = function done () {\n\t            if (typeof tap.config.noPlan !== 'undefined' && !(tap.config.noPlan)) {\n\t                // Do nothing until removal of 'noPlan' option.\n\t            } else if (isPlanRequired(qu.config)) {\n\t                printPlanLine(tap.expectedCount);\n\t            } else {\n\t                printPlanLine(tap.count);\n\t            }\n\t        };\n\t\n\t        tap.unsubscribe = function unsubscribe () {\n\t            if (typeof qu.config === 'undefined') {\n\t                return;\n\t            }\n\t            if (arguments.length === 0) {\n\t                unsubscribeEvents(targetEvents);\n\t            } else {\n\t                unsubscribeEvents(slice.apply(arguments));\n\t            }\n\t        };\n\t\n\t        (function () {\n\t            var appendCallback = createCallbackAppenderFor(qu),\n\t                eventName, i, callback;\n\t            for (i = 0; i < targetEvents.length; i += 1) {\n\t                eventName = targetEvents[i];\n\t                callback = appendCallback(qu, tap, eventName);\n\t                registeredCallbacks[eventName] = callback;\n\t            }\n\t        })();\n\t\n\t        return tap;\n\t    }\n\t\n\t    qunitTap.qunitTap = function () {\n\t        throw new Error('[BC BREAK] Since 1.4.0, QUnit-TAP exports single qunitTap function as module.exports. Therefore, require(\"qunit-tap\") returns qunitTap function itself. Please fix your code if you are using Node.js (or any CommonJS env).');\n\t    };\n\t\n\t    // using substack pattern (export single function)\n\t    return qunitTap;\n\t}));\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(module) {'use strict';\n\t\n\t/* global QUnit, qunitTap */\n\t\n\tvar qunit_started = false;\n\t\n\t/* Always use explicit start */\n\tQUnit.config.autostart = false;\n\t\n\t/*\n\t * HACK: phantomjs doesn't handle uncaught exceptions as it should if\n\t * window.onerror is non-null, even when that handler returns false\n\t * (expecting that the browser default behavior will occur).\n\t *\n\t * So remove the qunit window.onerror handler until the tests actually\n\t * start, and any errors become part of the test suite results.\n\t */\n\tvar qunit_onerror = window.onerror;\n\twindow.onerror = null;\n\tQUnit.begin(function() {\n\t    window.onerror = function(error, file, line) {\n\t        var ret = false;\n\t        if (qunit_onerror)\n\t            ret = qunit_onerror(error, file, line);\n\t\n\t        /*\n\t         * If a global exception happens during an async test\n\t         * then that test won't be able to call the start() function\n\t         * to move to the next test, so call it here.\n\t         */\n\t        if (QUnit.config.current && QUnit.config.current.async)\n\t            QUnit.start();\n\t\n\t        return ret;\n\t    };\n\t});\n\t\n\tQUnit.moduleStart(function() {\n\t    qunit_started = true;\n\t});\n\t\n\tQUnit.done(function() {\n\t    console.log(\"phantom-tap-done\");\n\t    window.onerror = null;\n\t});\n\t/*\n\t * Now initialize qunit-tap\n\t *\n\t * When not running under tap-phantom this stuff will just show up in\n\t * the console. We print out a special canary at the end of the tests\n\t * so that tap-phantom can know when the testing is done.\n\t *\n\t * In addition double check for a test file that doesn't properly call\n\t * QUnit.start() after its done setting up its tests.\n\t *\n\t * We also want to insert the current test name into all tap lines.\n\t */\n\tvar tap_regex = /^((not )?ok [0-9]+ (- )?)(.*)$/;\n\tqunitTap(QUnit, function() {\n\t    if (arguments.length == 1 && QUnit.config.current) {\n\t        var match = tap_regex.exec(arguments[0]);\n\t        if (match) {\n\t            console.log(match[1] + QUnit.config.current.testName + \": \" + match[4]);\n\t            return;\n\t        }\n\t    }\n\t    console.log.apply(console, arguments);\n\t});\n\t\n\twindow.setTimeout(function() {\n\t    if (!qunit_started) {\n\t        console.log(\"QUnit not started by test\");\n\t        console.log(\"phantom-tap-error\");\n\t    }\n\t}, 20000);\n\t\n\twindow.tests_included = true;\n\t\n\tif (module && module.exports)\n\t    module.exports = QUnit;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)(module)))\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\n\t\tif(!module.webpackPolyfill) {\n\t\t\tmodule.deprecate = function() {};\n\t\t\tmodule.paths = [];\n\t\t\t// module.parent = undefined by default\n\t\t\tmodule.children = [];\n\t\t\tmodule.webpackPolyfill = 1;\n\t\t}\n\t\treturn module;\n\t}\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// kdump/test-config-client.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fa79fae7f7d7178e37c4","'use strict';\n\n/*\n * This file is part of Cockpit.\n *\n * Copyright (C) 2016 Red Hat, Inc.\n *\n * Cockpit is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * Cockpit is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n */\n\nvar QUnit = require(\"qunit-tests\");\nvar cockpit = require(\"cockpit\");\nvar assert = QUnit;\n\nvar kdump = require(\"./config-client.es6\");\n\nvar basicConfig = [\n    \"# top comment\",\n    \"\",\n    \"foo bar\",\n    \" indented value\",\n    \"\",\n    \"will disappear\",\n    \"key value #comment\"\n].join(\"\\n\");\n\nvar changedConfig = [\n    \"# top comment\",\n    \"\",\n    \"foo moo\",\n    \"indented value\",\n    \"\",\n    \"#key value #comment\",\n    \"hooray value\"\n].join(\"\\n\");\n\nQUnit.asyncTest(\"config_update\", function() {\n    assert.expect(10);\n    var dataWasChanged = cockpit.defer();\n    var config;\n    var configChanged = function(event, settings) {\n        assert.equal(settings[\"foo\"].value, \"moo\", \"value changed correctly\");\n        assert.equal(\"key\" in settings, false, \"setting with comment deleted correctly\");\n        assert.equal(\"will\" in settings, false, \"setting without comment deleted correctly\");\n        assert.equal(settings[\"hooray\"].value, \"value\", \"value added correctly\");\n        assert.equal(config._rawContent, changedConfig, \"raw text for changed config is correct\");\n        dataWasChanged.resolve();\n    };\n\n    var filename = \"cockpit_config_read\";\n    var configFile = cockpit.file(filename);\n    configFile\n        .replace(basicConfig)\n        .always(function() {\n            assert.equal(this.state(), \"resolved\", \"writing initial config didn't fail\");\n            assert.equal(configFile.path, filename, \"file has correct path\");\n            config = new kdump.ConfigFile(filename);\n            config.wait().always(function() {\n                assert.equal(this.state(), \"resolved\", \"waiting for config didn't fail\");\n                config.settings[\"foo\"].value = \"moo\";\n                delete config.settings[\"key\"];\n                delete config.settings[\"will\"];\n                config.settings[\"hooray\"] = { value: \"value\" };\n                config.addEventListener('kdumpConfigChanged', configChanged);\n                config.write(config.settings)\n                    .always(function() {\n                        assert.equal(this.state(), \"resolved\", \"writing to config didn't fail\");\n                        dataWasChanged.promise().done(function() {\n                            assert.equal(this.state(), \"resolved\", \"waiting for config change didn't fail\");\n                            QUnit.start();\n                        });\n                    });\n            });\n        });\n});\n\nwindow.setTimeout(function() {\n    QUnit.start();\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../pkg/kdump/test-config-client.js\n// module id = 0\n// module chunks = 1","module.exports = cockpit;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"cockpit\"\n// module id = 2\n// module chunks = 0 1","/*\n * This file is part of Cockpit.\n *\n * Copyright (C) 2016 Red Hat, Inc.\n *\n * Cockpit is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * Cockpit is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n */\n\n  /* jshint esversion:6 */\n\nimport cockpit from 'cockpit';\n\n/* Parse an ini-style config file\n * and monitor it for changes\n */\nexport class ConfigFile {\n    constructor(filename, superuser = false) {\n        this.filename = filename;\n        this._rawContent = undefined;\n        this._lines = [ ];\n        this._originalSettings = { };\n        this._dataAvailable = cockpit.defer();\n        this.settings = { };\n\n        cockpit.event_target(this);\n\n        this._fileHandle = cockpit.file(filename, { superuser: superuser } );\n        this._fileHandle.watch((rawContent) => {\n            this._parseText(rawContent);\n        });\n    }\n    close() {\n        if (this._fileHandle) {\n            this._fileHandle.remove();\n            this._fileHandle = undefined;\n        }\n    }\n    // wait for data to have been read at least once\n    wait() {\n        return this._dataAvailable.promise();\n    }\n    /* parse lines of the config file\n     * if a line has a valid config key, use that as key\n     * and also store original line, line index, value and whether the line contains a comment\n     * we care about the comment since we don't want to overwrite a user comment when changing a value\n     * e.g. for line \"someKey foo # comment\"\n     * outputObject[\"someKey\"] = { index: 0, value: \"foo\", origLine: \"someKey foo # comment\", hasComment: true }\n     * skipNotify: Don't notify about changes, e.g.to avoid multiple updates when writing a file\n     */\n    _parseText(rawContent, skipNotify=false) {\n        if (this._dataAvailable)\n            this._dataAvailable.resolve();\n\n        // if nothing changed, don't bother parsing the content\n        // do proceed if the content is empty, it might be our initial read\n        if (!rawContent) {\n            this._originalSettings = null;\n            this.settings = null;\n            if (!skipNotify)\n                this.dispatchEvent(\"kdumpConfigChanged\", this.settings);\n            return;\n        }\n\n        if (rawContent == this._rawContent)\n            return;\n\n        //if (skipNotify === undefined)\n        //    skipNotify = false;\n\n        this._rawContent = rawContent;\n        // parse the config file\n        this._lines = rawContent.split(/\\r?\\n/);\n\n        this.settings = { };\n        this._lines.forEach((line, index) => {\n            let trimmed = line.trimLeft();\n            // if the line is empty or only a comment, skip\n            if (trimmed.indexOf(\"#\") === 0 || trimmed.length === 0)\n                return;\n\n            // we need to have a space between key and value\n            let separatorIndex = trimmed.indexOf(\" \");\n            if (separatorIndex === -1)\n                return;\n            let key = trimmed.substring(0, separatorIndex);\n            let value = trimmed.substring(separatorIndex+1).trim();\n\n            // value might have a comment at the end\n            let commentIndex = value.indexOf(\"#\");\n            let comment;\n            if (commentIndex !== -1) {\n                comment = value.substring(commentIndex).trim();\n                value = value.substring(0, commentIndex).trim();\n            }\n            this.settings[key] = {\n                index: index,\n                value: value,\n                origLine: line,\n                comment: comment\n            };\n        });\n\n        // make sure we copy the original keys so we overwrite the correct lines when saving\n        this._originalSettings = { };\n        Object.keys(this.settings).forEach((key) => {\n            this._originalSettings[key] = cockpit.extend({}, this.settings[key]);\n        });\n        if (!skipNotify)\n            this.dispatchEvent(\"kdumpConfigChanged\", this.settings);\n    }\n\n    /* generate the config file from raw text and settings\n     */\n    _generateConfig(settings) {\n        let lines = this._lines.slice(0);\n        let linesToDelete = [];\n        // first find the settings lines that have been disabled/deleted\n        Object.keys(this._originalSettings).forEach((key) => {\n            if (!(key in settings))  {\n                let origEntry = this._originalSettings[key];\n                // if the line had a comment, keep it, otherwise delete\n                if (origEntry.comment !== undefined)\n                    lines[origEntry.index] = \"#\" + origEntry.origLine;\n                else\n                    linesToDelete.push(origEntry.index);\n            }\n        });\n        // we take the lines from our last read operation and modify them with the new settings\n        Object.keys(settings).forEach((key) => {\n            let entry = settings[key];\n            let line = key + \" \" + entry.value;\n            if (entry.comment)\n                line = line + \" \" + entry.comment;\n            // this might be a new entry\n            if (!(key in this._originalSettings)) {\n                lines.push(line);\n                return;\n            }\n            // otherwise edit the old line\n            let origEntry = this._originalSettings[key];\n            lines[origEntry.index] = line;\n        });\n        // now delete the rows we want to delete\n        linesToDelete.sort().reverse().forEach((lineIndex) => {\n            lines.splice(lineIndex, 1);\n        });\n\n        return lines.join(\"\\n\");\n    }\n\n    /* write settings back to file\n     * new settings that don't have a corresponding entry already have an undefined or null index\n     * returns a promise for the file operation (cockpit File)\n     */\n    write(settings) {\n        return this._fileHandle.modify((oldContent) => {\n            this._parseText(oldContent, true);\n            return this._generateConfig(settings);\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../pkg/kdump/config-client.es6","'use strict';\n\n/*\n * This file is part of Cockpit.\n *\n * Copyright (C) 2014 Red Hat, Inc.\n *\n * Cockpit is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * Cockpit is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n */\n\n(function() {\n    \"use strict\";\n\n    /* QUnit needs to have 'window' as 'this' in order to load */\n    window.QUnit = require(\"qunit/qunit/qunit.js\");\n    window.qunitTap = require(\"qunit-tap/lib/qunit-tap.js\");\n\n    require(\"./qunit-config.js\");\n\n    require(\"qunit/qunit/qunit.css\");\n\n    module.exports = window.QUnit;\n\n}());\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../pkg/lib/qunit-tests.js\n// module id = 20\n// module chunks = 1","/*!\n * QUnit 1.14.0\n * http://qunitjs.com/\n *\n * Copyright 2013 jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-01-31T16:40Z\n */\n\n(function( window ) {\n\nvar QUnit,\n\tassert,\n\tconfig,\n\tonErrorFnPrev,\n\ttestId = 0,\n\tfileName = (sourceFromStacktrace( 0 ) || \"\" ).replace(/(:\\d+)+\\)?/, \"\").replace(/.+\\//, \"\"),\n\ttoString = Object.prototype.toString,\n\thasOwn = Object.prototype.hasOwnProperty,\n\t// Keep a local reference to Date (GH-283)\n\tDate = window.Date,\n\tsetTimeout = window.setTimeout,\n\tclearTimeout = window.clearTimeout,\n\tdefined = {\n\t\tdocument: typeof window.document !== \"undefined\",\n\t\tsetTimeout: typeof window.setTimeout !== \"undefined\",\n\t\tsessionStorage: (function() {\n\t\t\tvar x = \"qunit-test-string\";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\treturn true;\n\t\t\t} catch( e ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}())\n\t},\n\t/**\n\t * Provides a normalized error string, correcting an issue\n\t * with IE 7 (and prior) where Error.prototype.toString is\n\t * not properly implemented\n\t *\n\t * Based on http://es5.github.com/#x15.11.4.4\n\t *\n\t * @param {String|Error} error\n\t * @return {String} error message\n\t */\n\terrorString = function( error ) {\n\t\tvar name, message,\n\t\t\terrorString = error.toString();\n\t\tif ( errorString.substring( 0, 7 ) === \"[object\" ) {\n\t\t\tname = error.name ? error.name.toString() : \"Error\";\n\t\t\tmessage = error.message ? error.message.toString() : \"\";\n\t\t\tif ( name && message ) {\n\t\t\t\treturn name + \": \" + message;\n\t\t\t} else if ( name ) {\n\t\t\t\treturn name;\n\t\t\t} else if ( message ) {\n\t\t\t\treturn message;\n\t\t\t} else {\n\t\t\t\treturn \"Error\";\n\t\t\t}\n\t\t} else {\n\t\t\treturn errorString;\n\t\t}\n\t},\n\t/**\n\t * Makes a clone of an object using only Array or Object as base,\n\t * and copies over the own enumerable properties.\n\t *\n\t * @param {Object} obj\n\t * @return {Object} New object with only the own properties (recursively).\n\t */\n\tobjectValues = function( obj ) {\n\t\t// Grunt 0.3.x uses an older version of jshint that still has jshint/jshint#392.\n\t\t/*jshint newcap: false */\n\t\tvar key, val,\n\t\t\tvals = QUnit.is( \"array\", obj ) ? [] : {};\n\t\tfor ( key in obj ) {\n\t\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\t\tval = obj[key];\n\t\t\t\tvals[key] = val === Object(val) ? objectValues(val) : val;\n\t\t\t}\n\t\t}\n\t\treturn vals;\n\t};\n\n\n// Root QUnit object.\n// `QUnit` initialized at top of scope\nQUnit = {\n\n\t// call on start of module test to prepend name to all tests\n\tmodule: function( name, testEnvironment ) {\n\t\tconfig.currentModule = name;\n\t\tconfig.currentModuleTestEnvironment = testEnvironment;\n\t\tconfig.modules[name] = true;\n\t},\n\n\tasyncTest: function( testName, expected, callback ) {\n\t\tif ( arguments.length === 2 ) {\n\t\t\tcallback = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tQUnit.test( testName, expected, callback, true );\n\t},\n\n\ttest: function( testName, expected, callback, async ) {\n\t\tvar test,\n\t\t\tnameHtml = \"<span class='test-name'>\" + escapeText( testName ) + \"</span>\";\n\n\t\tif ( arguments.length === 2 ) {\n\t\t\tcallback = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tif ( config.currentModule ) {\n\t\t\tnameHtml = \"<span class='module-name'>\" + escapeText( config.currentModule ) + \"</span>: \" + nameHtml;\n\t\t}\n\n\t\ttest = new Test({\n\t\t\tnameHtml: nameHtml,\n\t\t\ttestName: testName,\n\t\t\texpected: expected,\n\t\t\tasync: async,\n\t\t\tcallback: callback,\n\t\t\tmodule: config.currentModule,\n\t\t\tmoduleTestEnvironment: config.currentModuleTestEnvironment,\n\t\t\tstack: sourceFromStacktrace( 2 )\n\t\t});\n\n\t\tif ( !validTest( test ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\ttest.queue();\n\t},\n\n\t// Specify the number of expected assertions to guarantee that failed test (no assertions are run at all) don't slip through.\n\texpect: function( asserts ) {\n\t\tif (arguments.length === 1) {\n\t\t\tconfig.current.expected = asserts;\n\t\t} else {\n\t\t\treturn config.current.expected;\n\t\t}\n\t},\n\n\tstart: function( count ) {\n\t\t// QUnit hasn't been initialized yet.\n\t\t// Note: RequireJS (et al) may delay onLoad\n\t\tif ( config.semaphore === undefined ) {\n\t\t\tQUnit.begin(function() {\n\t\t\t\t// This is triggered at the top of QUnit.load, push start() to the event loop, to allow QUnit.load to finish first\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tQUnit.start( count );\n\t\t\t\t});\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tconfig.semaphore -= count || 1;\n\t\t// don't start until equal number of stop-calls\n\t\tif ( config.semaphore > 0 ) {\n\t\t\treturn;\n\t\t}\n\t\t// ignore if start is called more often then stop\n\t\tif ( config.semaphore < 0 ) {\n\t\t\tconfig.semaphore = 0;\n\t\t\tQUnit.pushFailure( \"Called start() while already started (QUnit.config.semaphore was 0 already)\", null, sourceFromStacktrace(2) );\n\t\t\treturn;\n\t\t}\n\t\t// A slight delay, to avoid any current callbacks\n\t\tif ( defined.setTimeout ) {\n\t\t\tsetTimeout(function() {\n\t\t\t\tif ( config.semaphore > 0 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( config.timeout ) {\n\t\t\t\t\tclearTimeout( config.timeout );\n\t\t\t\t}\n\n\t\t\t\tconfig.blocking = false;\n\t\t\t\tprocess( true );\n\t\t\t}, 13);\n\t\t} else {\n\t\t\tconfig.blocking = false;\n\t\t\tprocess( true );\n\t\t}\n\t},\n\n\tstop: function( count ) {\n\t\tconfig.semaphore += count || 1;\n\t\tconfig.blocking = true;\n\n\t\tif ( config.testTimeout && defined.setTimeout ) {\n\t\t\tclearTimeout( config.timeout );\n\t\t\tconfig.timeout = setTimeout(function() {\n\t\t\t\tQUnit.ok( false, \"Test timed out\" );\n\t\t\t\tconfig.semaphore = 1;\n\t\t\t\tQUnit.start();\n\t\t\t}, config.testTimeout );\n\t\t}\n\t}\n};\n\n// We use the prototype to distinguish between properties that should\n// be exposed as globals (and in exports) and those that shouldn't\n(function() {\n\tfunction F() {}\n\tF.prototype = QUnit;\n\tQUnit = new F();\n\t// Make F QUnit's constructor so that we can add to the prototype later\n\tQUnit.constructor = F;\n}());\n\n/**\n * Config object: Maintain internal state\n * Later exposed as QUnit.config\n * `config` initialized at top of scope\n */\nconfig = {\n\t// The queue of tests to run\n\tqueue: [],\n\n\t// block until document ready\n\tblocking: true,\n\n\t// when enabled, show only failing tests\n\t// gets persisted through sessionStorage and can be changed in UI via checkbox\n\thidepassed: false,\n\n\t// by default, run previously failed tests first\n\t// very useful in combination with \"Hide passed tests\" checked\n\treorder: true,\n\n\t// by default, modify document.title when suite is done\n\taltertitle: true,\n\n\t// by default, scroll to top of the page when suite is done\n\tscrolltop: true,\n\n\t// when enabled, all tests must call expect()\n\trequireExpects: false,\n\n\t// add checkboxes that are persisted in the query-string\n\t// when enabled, the id is set to `true` as a `QUnit.config` property\n\turlConfig: [\n\t\t{\n\t\t\tid: \"noglobals\",\n\t\t\tlabel: \"Check for Globals\",\n\t\t\ttooltip: \"Enabling this will test if any test introduces new properties on the `window` object. Stored as query-strings.\"\n\t\t},\n\t\t{\n\t\t\tid: \"notrycatch\",\n\t\t\tlabel: \"No try-catch\",\n\t\t\ttooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging exceptions in IE reasonable. Stored as query-strings.\"\n\t\t}\n\t],\n\n\t// Set of all modules.\n\tmodules: {},\n\n\t// logging callback queues\n\tbegin: [],\n\tdone: [],\n\tlog: [],\n\ttestStart: [],\n\ttestDone: [],\n\tmoduleStart: [],\n\tmoduleDone: []\n};\n\n// Initialize more QUnit.config and QUnit.urlParams\n(function() {\n\tvar i, current,\n\t\tlocation = window.location || { search: \"\", protocol: \"file:\" },\n\t\tparams = location.search.slice( 1 ).split( \"&\" ),\n\t\tlength = params.length,\n\t\turlParams = {};\n\n\tif ( params[ 0 ] ) {\n\t\tfor ( i = 0; i < length; i++ ) {\n\t\t\tcurrent = params[ i ].split( \"=\" );\n\t\t\tcurrent[ 0 ] = decodeURIComponent( current[ 0 ] );\n\n\t\t\t// allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\tcurrent[ 1 ] = current[ 1 ] ? decodeURIComponent( current[ 1 ] ) : true;\n\t\t\tif ( urlParams[ current[ 0 ] ] ) {\n\t\t\t\turlParams[ current[ 0 ] ] = [].concat( urlParams[ current[ 0 ] ], current[ 1 ] );\n\t\t\t} else {\n\t\t\t\turlParams[ current[ 0 ] ] = current[ 1 ];\n\t\t\t}\n\t\t}\n\t}\n\n\tQUnit.urlParams = urlParams;\n\n\t// String search anywhere in moduleName+testName\n\tconfig.filter = urlParams.filter;\n\n\t// Exact match of the module name\n\tconfig.module = urlParams.module;\n\n\tconfig.testNumber = [];\n\tif ( urlParams.testNumber ) {\n\n\t\t// Ensure that urlParams.testNumber is an array\n\t\turlParams.testNumber = [].concat( urlParams.testNumber );\n\t\tfor ( i = 0; i < urlParams.testNumber.length; i++ ) {\n\t\t\tcurrent = urlParams.testNumber[ i ];\n\t\t\tconfig.testNumber.push( parseInt( current, 10 ) );\n\t\t}\n\t}\n\n\t// Figure out if we're running the tests from a server or not\n\tQUnit.isLocal = location.protocol === \"file:\";\n}());\n\nextend( QUnit, {\n\n\tconfig: config,\n\n\t// Initialize the configuration options\n\tinit: function() {\n\t\textend( config, {\n\t\t\tstats: { all: 0, bad: 0 },\n\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\tstarted: +new Date(),\n\t\t\tupdateRate: 1000,\n\t\t\tblocking: false,\n\t\t\tautostart: true,\n\t\t\tautorun: false,\n\t\t\tfilter: \"\",\n\t\t\tqueue: [],\n\t\t\tsemaphore: 1\n\t\t});\n\n\t\tvar tests, banner, result,\n\t\t\tqunit = id( \"qunit\" );\n\n\t\tif ( qunit ) {\n\t\t\tqunit.innerHTML =\n\t\t\t\t\"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +\n\t\t\t\t\"<h2 id='qunit-banner'></h2>\" +\n\t\t\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +\n\t\t\t\t\"<h2 id='qunit-userAgent'></h2>\" +\n\t\t\t\t\"<ol id='qunit-tests'></ol>\";\n\t\t}\n\n\t\ttests = id( \"qunit-tests\" );\n\t\tbanner = id( \"qunit-banner\" );\n\t\tresult = id( \"qunit-testresult\" );\n\n\t\tif ( tests ) {\n\t\t\ttests.innerHTML = \"\";\n\t\t}\n\n\t\tif ( banner ) {\n\t\t\tbanner.className = \"\";\n\t\t}\n\n\t\tif ( result ) {\n\t\t\tresult.parentNode.removeChild( result );\n\t\t}\n\n\t\tif ( tests ) {\n\t\t\tresult = document.createElement( \"p\" );\n\t\t\tresult.id = \"qunit-testresult\";\n\t\t\tresult.className = \"result\";\n\t\t\ttests.parentNode.insertBefore( result, tests );\n\t\t\tresult.innerHTML = \"Running...<br/>&nbsp;\";\n\t\t}\n\t},\n\n\t// Resets the test setup. Useful for tests that modify the DOM.\n\t/*\n\tDEPRECATED: Use multiple tests instead of resetting inside a test.\n\tUse testStart or testDone for custom cleanup.\n\tThis method will throw an error in 2.0, and will be removed in 2.1\n\t*/\n\treset: function() {\n\t\tvar fixture = id( \"qunit-fixture\" );\n\t\tif ( fixture ) {\n\t\t\tfixture.innerHTML = config.fixture;\n\t\t}\n\t},\n\n\t// Safe object type checking\n\tis: function( type, obj ) {\n\t\treturn QUnit.objectType( obj ) === type;\n\t},\n\n\tobjectType: function( obj ) {\n\t\tif ( typeof obj === \"undefined\" ) {\n\t\t\treturn \"undefined\";\n\t\t}\n\n\t\t// Consider: typeof null === object\n\t\tif ( obj === null ) {\n\t\t\treturn \"null\";\n\t\t}\n\n\t\tvar match = toString.call( obj ).match(/^\\[object\\s(.*)\\]$/),\n\t\t\ttype = match && match[1] || \"\";\n\n\t\tswitch ( type ) {\n\t\t\tcase \"Number\":\n\t\t\t\tif ( isNaN(obj) ) {\n\t\t\t\t\treturn \"nan\";\n\t\t\t\t}\n\t\t\t\treturn \"number\";\n\t\t\tcase \"String\":\n\t\t\tcase \"Boolean\":\n\t\t\tcase \"Array\":\n\t\t\tcase \"Date\":\n\t\t\tcase \"RegExp\":\n\t\t\tcase \"Function\":\n\t\t\t\treturn type.toLowerCase();\n\t\t}\n\t\tif ( typeof obj === \"object\" ) {\n\t\t\treturn \"object\";\n\t\t}\n\t\treturn undefined;\n\t},\n\n\tpush: function( result, actual, expected, message ) {\n\t\tif ( !config.current ) {\n\t\t\tthrow new Error( \"assertion outside test context, was \" + sourceFromStacktrace() );\n\t\t}\n\n\t\tvar output, source,\n\t\t\tdetails = {\n\t\t\t\tmodule: config.current.module,\n\t\t\t\tname: config.current.testName,\n\t\t\t\tresult: result,\n\t\t\t\tmessage: message,\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected\n\t\t\t};\n\n\t\tmessage = escapeText( message ) || ( result ? \"okay\" : \"failed\" );\n\t\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\n\t\toutput = message;\n\n\t\tif ( !result ) {\n\t\t\texpected = escapeText( QUnit.jsDump.parse(expected) );\n\t\t\tactual = escapeText( QUnit.jsDump.parse(actual) );\n\t\t\toutput += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" + expected + \"</pre></td></tr>\";\n\n\t\t\tif ( actual !== expected ) {\n\t\t\t\toutput += \"<tr class='test-actual'><th>Result: </th><td><pre>\" + actual + \"</pre></td></tr>\";\n\t\t\t\toutput += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" + QUnit.diff( expected, actual ) + \"</pre></td></tr>\";\n\t\t\t}\n\n\t\t\tsource = sourceFromStacktrace();\n\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t\toutput += \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText( source ) + \"</pre></td></tr>\";\n\t\t\t}\n\n\t\t\toutput += \"</table>\";\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", QUnit, details );\n\n\t\tconfig.current.assertions.push({\n\t\t\tresult: !!result,\n\t\t\tmessage: output\n\t\t});\n\t},\n\n\tpushFailure: function( message, source, actual ) {\n\t\tif ( !config.current ) {\n\t\t\tthrow new Error( \"pushFailure() assertion outside test context, was \" + sourceFromStacktrace(2) );\n\t\t}\n\n\t\tvar output,\n\t\t\tdetails = {\n\t\t\t\tmodule: config.current.module,\n\t\t\t\tname: config.current.testName,\n\t\t\t\tresult: false,\n\t\t\t\tmessage: message\n\t\t\t};\n\n\t\tmessage = escapeText( message ) || \"error\";\n\t\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\n\t\toutput = message;\n\n\t\toutput += \"<table>\";\n\n\t\tif ( actual ) {\n\t\t\toutput += \"<tr class='test-actual'><th>Result: </th><td><pre>\" + escapeText( actual ) + \"</pre></td></tr>\";\n\t\t}\n\n\t\tif ( source ) {\n\t\t\tdetails.source = source;\n\t\t\toutput += \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText( source ) + \"</pre></td></tr>\";\n\t\t}\n\n\t\toutput += \"</table>\";\n\n\t\trunLoggingCallbacks( \"log\", QUnit, details );\n\n\t\tconfig.current.assertions.push({\n\t\t\tresult: false,\n\t\t\tmessage: output\n\t\t});\n\t},\n\n\turl: function( params ) {\n\t\tparams = extend( extend( {}, QUnit.urlParams ), params );\n\t\tvar key,\n\t\t\tquerystring = \"?\";\n\n\t\tfor ( key in params ) {\n\t\t\tif ( hasOwn.call( params, key ) ) {\n\t\t\t\tquerystring += encodeURIComponent( key ) + \"=\" +\n\t\t\t\t\tencodeURIComponent( params[ key ] ) + \"&\";\n\t\t\t}\n\t\t}\n\t\treturn window.location.protocol + \"//\" + window.location.host +\n\t\t\twindow.location.pathname + querystring.slice( 0, -1 );\n\t},\n\n\textend: extend,\n\tid: id,\n\taddEvent: addEvent,\n\taddClass: addClass,\n\thasClass: hasClass,\n\tremoveClass: removeClass\n\t// load, equiv, jsDump, diff: Attached later\n});\n\n/**\n * @deprecated: Created for backwards compatibility with test runner that set the hook function\n * into QUnit.{hook}, instead of invoking it and passing the hook function.\n * QUnit.constructor is set to the empty F() above so that we can add to it's prototype here.\n * Doing this allows us to tell if the following methods have been overwritten on the actual\n * QUnit object.\n */\nextend( QUnit.constructor.prototype, {\n\n\t// Logging callbacks; all receive a single argument with the listed properties\n\t// run test/logs.html for any related changes\n\tbegin: registerLoggingCallback( \"begin\" ),\n\n\t// done: { failed, passed, total, runtime }\n\tdone: registerLoggingCallback( \"done\" ),\n\n\t// log: { result, actual, expected, message }\n\tlog: registerLoggingCallback( \"log\" ),\n\n\t// testStart: { name }\n\ttestStart: registerLoggingCallback( \"testStart\" ),\n\n\t// testDone: { name, failed, passed, total, runtime }\n\ttestDone: registerLoggingCallback( \"testDone\" ),\n\n\t// moduleStart: { name }\n\tmoduleStart: registerLoggingCallback( \"moduleStart\" ),\n\n\t// moduleDone: { name, failed, passed, total }\n\tmoduleDone: registerLoggingCallback( \"moduleDone\" )\n});\n\nif ( !defined.document || document.readyState === \"complete\" ) {\n\tconfig.autorun = true;\n}\n\nQUnit.load = function() {\n\trunLoggingCallbacks( \"begin\", QUnit, {} );\n\n\t// Initialize the config, saving the execution queue\n\tvar banner, filter, i, j, label, len, main, ol, toolbar, val, selection,\n\t\turlConfigContainer, moduleFilter, userAgent,\n\t\tnumModules = 0,\n\t\tmoduleNames = [],\n\t\tmoduleFilterHtml = \"\",\n\t\turlConfigHtml = \"\",\n\t\toldconfig = extend( {}, config );\n\n\tQUnit.init();\n\textend(config, oldconfig);\n\n\tconfig.blocking = false;\n\n\tlen = config.urlConfig.length;\n\n\tfor ( i = 0; i < len; i++ ) {\n\t\tval = config.urlConfig[i];\n\t\tif ( typeof val === \"string\" ) {\n\t\t\tval = {\n\t\t\t\tid: val,\n\t\t\t\tlabel: val\n\t\t\t};\n\t\t}\n\t\tconfig[ val.id ] = QUnit.urlParams[ val.id ];\n\t\tif ( !val.value || typeof val.value === \"string\" ) {\n\t\t\turlConfigHtml += \"<input id='qunit-urlconfig-\" + escapeText( val.id ) +\n\t\t\t\t\"' name='\" + escapeText( val.id ) +\n\t\t\t\t\"' type='checkbox'\" +\n\t\t\t\t( val.value ? \" value='\" + escapeText( val.value ) + \"'\" : \"\" ) +\n\t\t\t\t( config[ val.id ] ? \" checked='checked'\" : \"\" ) +\n\t\t\t\t\" title='\" + escapeText( val.tooltip ) +\n\t\t\t\t\"'><label for='qunit-urlconfig-\" + escapeText( val.id ) +\n\t\t\t\t\"' title='\" + escapeText( val.tooltip ) + \"'>\" + val.label + \"</label>\";\n\t\t} else {\n\t\t\turlConfigHtml += \"<label for='qunit-urlconfig-\" + escapeText( val.id ) +\n\t\t\t\t\"' title='\" + escapeText( val.tooltip ) +\n\t\t\t\t\"'>\" + val.label +\n\t\t\t\t\": </label><select id='qunit-urlconfig-\" + escapeText( val.id ) +\n\t\t\t\t\"' name='\" + escapeText( val.id ) +\n\t\t\t\t\"' title='\" + escapeText( val.tooltip ) +\n\t\t\t\t\"'><option></option>\";\n\t\t\tselection = false;\n\t\t\tif ( QUnit.is( \"array\", val.value ) ) {\n\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {\n\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( val.value[j] ) + \"'\" +\n\t\t\t\t\t\t( config[ val.id ] === val.value[j] ?\n\t\t\t\t\t\t\t(selection = true) && \" selected='selected'\" :\n\t\t\t\t\t\t\t\"\" ) +\n\t\t\t\t\t\t\">\" + escapeText( val.value[j] ) + \"</option>\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( j in val.value ) {\n\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {\n\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( j ) + \"'\" +\n\t\t\t\t\t\t\t( config[ val.id ] === j ?\n\t\t\t\t\t\t\t\t(selection = true) && \" selected='selected'\" :\n\t\t\t\t\t\t\t\t\"\" ) +\n\t\t\t\t\t\t\t\">\" + escapeText( val.value[j] ) + \"</option>\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( config[ val.id ] && !selection ) {\n\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( config[ val.id ] ) +\n\t\t\t\t\t\"' selected='selected' disabled='disabled'>\" +\n\t\t\t\t\tescapeText( config[ val.id ] ) +\n\t\t\t\t\t\"</option>\";\n\t\t\t}\n\t\t\turlConfigHtml += \"</select>\";\n\t\t}\n\t}\n\tfor ( i in config.modules ) {\n\t\tif ( config.modules.hasOwnProperty( i ) ) {\n\t\t\tmoduleNames.push(i);\n\t\t}\n\t}\n\tnumModules = moduleNames.length;\n\tmoduleNames.sort( function( a, b ) {\n\t\treturn a.localeCompare( b );\n\t});\n\tmoduleFilterHtml += \"<label for='qunit-modulefilter'>Module: </label><select id='qunit-modulefilter' name='modulefilter'><option value='' \" +\n\t\t( config.module === undefined  ? \"selected='selected'\" : \"\" ) +\n\t\t\">< All Modules ></option>\";\n\n\n\tfor ( i = 0; i < numModules; i++) {\n\t\t\tmoduleFilterHtml += \"<option value='\" + escapeText( encodeURIComponent(moduleNames[i]) ) + \"' \" +\n\t\t\t\t( config.module === moduleNames[i] ? \"selected='selected'\" : \"\" ) +\n\t\t\t\t\">\" + escapeText(moduleNames[i]) + \"</option>\";\n\t}\n\tmoduleFilterHtml += \"</select>\";\n\n\t// `userAgent` initialized at top of scope\n\tuserAgent = id( \"qunit-userAgent\" );\n\tif ( userAgent ) {\n\t\tuserAgent.innerHTML = navigator.userAgent;\n\t}\n\n\t// `banner` initialized at top of scope\n\tbanner = id( \"qunit-header\" );\n\tif ( banner ) {\n\t\tbanner.innerHTML = \"<a href='\" + QUnit.url({ filter: undefined, module: undefined, testNumber: undefined }) + \"'>\" + banner.innerHTML + \"</a> \";\n\t}\n\n\t// `toolbar` initialized at top of scope\n\ttoolbar = id( \"qunit-testrunner-toolbar\" );\n\tif ( toolbar ) {\n\t\t// `filter` initialized at top of scope\n\t\tfilter = document.createElement( \"input\" );\n\t\tfilter.type = \"checkbox\";\n\t\tfilter.id = \"qunit-filter-pass\";\n\n\t\taddEvent( filter, \"click\", function() {\n\t\t\tvar tmp,\n\t\t\t\tol = id( \"qunit-tests\" );\n\n\t\t\tif ( filter.checked ) {\n\t\t\t\tol.className = ol.className + \" hidepass\";\n\t\t\t} else {\n\t\t\t\ttmp = \" \" + ol.className.replace( /[\\n\\t\\r]/g, \" \" ) + \" \";\n\t\t\t\tol.className = tmp.replace( / hidepass /, \" \" );\n\t\t\t}\n\t\t\tif ( defined.sessionStorage ) {\n\t\t\t\tif (filter.checked) {\n\t\t\t\t\tsessionStorage.setItem( \"qunit-filter-passed-tests\", \"true\" );\n\t\t\t\t} else {\n\t\t\t\t\tsessionStorage.removeItem( \"qunit-filter-passed-tests\" );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif ( config.hidepassed || defined.sessionStorage && sessionStorage.getItem( \"qunit-filter-passed-tests\" ) ) {\n\t\t\tfilter.checked = true;\n\t\t\t// `ol` initialized at top of scope\n\t\t\tol = id( \"qunit-tests\" );\n\t\t\tol.className = ol.className + \" hidepass\";\n\t\t}\n\t\ttoolbar.appendChild( filter );\n\n\t\t// `label` initialized at top of scope\n\t\tlabel = document.createElement( \"label\" );\n\t\tlabel.setAttribute( \"for\", \"qunit-filter-pass\" );\n\t\tlabel.setAttribute( \"title\", \"Only show tests and assertions that fail. Stored in sessionStorage.\" );\n\t\tlabel.innerHTML = \"Hide passed tests\";\n\t\ttoolbar.appendChild( label );\n\n\t\turlConfigContainer = document.createElement(\"span\");\n\t\turlConfigContainer.innerHTML = urlConfigHtml;\n\t\t// For oldIE support:\n\t\t// * Add handlers to the individual elements instead of the container\n\t\t// * Use \"click\" instead of \"change\" for checkboxes\n\t\t// * Fallback from event.target to event.srcElement\n\t\taddEvents( urlConfigContainer.getElementsByTagName(\"input\"), \"click\", function( event ) {\n\t\t\tvar params = {},\n\t\t\t\ttarget = event.target || event.srcElement;\n\t\t\tparams[ target.name ] = target.checked ?\n\t\t\t\ttarget.defaultValue || true :\n\t\t\t\tundefined;\n\t\t\twindow.location = QUnit.url( params );\n\t\t});\n\t\taddEvents( urlConfigContainer.getElementsByTagName(\"select\"), \"change\", function( event ) {\n\t\t\tvar params = {},\n\t\t\t\ttarget = event.target || event.srcElement;\n\t\t\tparams[ target.name ] = target.options[ target.selectedIndex ].value || undefined;\n\t\t\twindow.location = QUnit.url( params );\n\t\t});\n\t\ttoolbar.appendChild( urlConfigContainer );\n\n\t\tif (numModules > 1) {\n\t\t\tmoduleFilter = document.createElement( \"span\" );\n\t\t\tmoduleFilter.setAttribute( \"id\", \"qunit-modulefilter-container\" );\n\t\t\tmoduleFilter.innerHTML = moduleFilterHtml;\n\t\t\taddEvent( moduleFilter.lastChild, \"change\", function() {\n\t\t\t\tvar selectBox = moduleFilter.getElementsByTagName(\"select\")[0],\n\t\t\t\t\tselectedModule = decodeURIComponent(selectBox.options[selectBox.selectedIndex].value);\n\n\t\t\t\twindow.location = QUnit.url({\n\t\t\t\t\tmodule: ( selectedModule === \"\" ) ? undefined : selectedModule,\n\t\t\t\t\t// Remove any existing filters\n\t\t\t\t\tfilter: undefined,\n\t\t\t\t\ttestNumber: undefined\n\t\t\t\t});\n\t\t\t});\n\t\t\ttoolbar.appendChild(moduleFilter);\n\t\t}\n\t}\n\n\t// `main` initialized at top of scope\n\tmain = id( \"qunit-fixture\" );\n\tif ( main ) {\n\t\tconfig.fixture = main.innerHTML;\n\t}\n\n\tif ( config.autostart ) {\n\t\tQUnit.start();\n\t}\n};\n\nif ( defined.document ) {\n\taddEvent( window, \"load\", QUnit.load );\n}\n\n// `onErrorFnPrev` initialized at top of scope\n// Preserve other handlers\nonErrorFnPrev = window.onerror;\n\n// Cover uncaught exceptions\n// Returning true will suppress the default browser handler,\n// returning false will let it run.\nwindow.onerror = function ( error, filePath, linerNr ) {\n\tvar ret = false;\n\tif ( onErrorFnPrev ) {\n\t\tret = onErrorFnPrev( error, filePath, linerNr );\n\t}\n\n\t// Treat return value as window.onerror itself does,\n\t// Only do our handling if not suppressed.\n\tif ( ret !== true ) {\n\t\tif ( QUnit.config.current ) {\n\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t} else {\n\t\t\tQUnit.test( \"global failure\", extend( function() {\n\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t}, { validTest: validTest } ) );\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn ret;\n};\n\nfunction done() {\n\tconfig.autorun = true;\n\n\t// Log the last module results\n\tif ( config.previousModule ) {\n\t\trunLoggingCallbacks( \"moduleDone\", QUnit, {\n\t\t\tname: config.previousModule,\n\t\t\tfailed: config.moduleStats.bad,\n\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\ttotal: config.moduleStats.all\n\t\t});\n\t}\n\tdelete config.previousModule;\n\n\tvar i, key,\n\t\tbanner = id( \"qunit-banner\" ),\n\t\ttests = id( \"qunit-tests\" ),\n\t\truntime = +new Date() - config.started,\n\t\tpassed = config.stats.all - config.stats.bad,\n\t\thtml = [\n\t\t\t\"Tests completed in \",\n\t\t\truntime,\n\t\t\t\" milliseconds.<br/>\",\n\t\t\t\"<span class='passed'>\",\n\t\t\tpassed,\n\t\t\t\"</span> assertions of <span class='total'>\",\n\t\t\tconfig.stats.all,\n\t\t\t\"</span> passed, <span class='failed'>\",\n\t\t\tconfig.stats.bad,\n\t\t\t\"</span> failed.\"\n\t\t].join( \"\" );\n\n\tif ( banner ) {\n\t\tbanner.className = ( config.stats.bad ? \"qunit-fail\" : \"qunit-pass\" );\n\t}\n\n\tif ( tests ) {\n\t\tid( \"qunit-testresult\" ).innerHTML = html;\n\t}\n\n\tif ( config.altertitle && defined.document && document.title ) {\n\t\t// show  for good,  for bad suite result in title\n\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\tdocument.title = [\n\t\t\t( config.stats.bad ? \"\\u2716\" : \"\\u2714\" ),\n\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, \"\" )\n\t\t].join( \" \" );\n\t}\n\n\t// clear own sessionStorage items if all tests passed\n\tif ( config.reorder && defined.sessionStorage && config.stats.bad === 0 ) {\n\t\t// `key` & `i` initialized at top of scope\n\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\n\t\t\tkey = sessionStorage.key( i++ );\n\t\t\tif ( key.indexOf( \"qunit-test-\" ) === 0 ) {\n\t\t\t\tsessionStorage.removeItem( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t// scroll back to top to show results\n\tif ( config.scrolltop && window.scrollTo ) {\n\t\twindow.scrollTo(0, 0);\n\t}\n\n\trunLoggingCallbacks( \"done\", QUnit, {\n\t\tfailed: config.stats.bad,\n\t\tpassed: passed,\n\t\ttotal: config.stats.all,\n\t\truntime: runtime\n\t});\n}\n\n/** @return Boolean: true if this test should be ran */\nfunction validTest( test ) {\n\tvar include,\n\t\tfilter = config.filter && config.filter.toLowerCase(),\n\t\tmodule = config.module && config.module.toLowerCase(),\n\t\tfullName = ( test.module + \": \" + test.testName ).toLowerCase();\n\n\t// Internally-generated tests are always valid\n\tif ( test.callback && test.callback.validTest === validTest ) {\n\t\tdelete test.callback.validTest;\n\t\treturn true;\n\t}\n\n\tif ( config.testNumber.length > 0 ) {\n\t\tif ( inArray( test.testNumber, config.testNumber ) < 0 ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif ( module && ( !test.module || test.module.toLowerCase() !== module ) ) {\n\t\treturn false;\n\t}\n\n\tif ( !filter ) {\n\t\treturn true;\n\t}\n\n\tinclude = filter.charAt( 0 ) !== \"!\";\n\tif ( !include ) {\n\t\tfilter = filter.slice( 1 );\n\t}\n\n\t// If the filter matches, we need to honour include\n\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\treturn include;\n\t}\n\n\t// Otherwise, do the opposite\n\treturn !include;\n}\n\n// so far supports only Firefox, Chrome and Opera (buggy), Safari (for real exceptions)\n// Later Safari and IE10 are supposed to support error.stack as well\n// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\nfunction extractStacktrace( e, offset ) {\n\toffset = offset === undefined ? 3 : offset;\n\n\tvar stack, include, i;\n\n\tif ( e.stacktrace ) {\n\t\t// Opera\n\t\treturn e.stacktrace.split( \"\\n\" )[ offset + 3 ];\n\t} else if ( e.stack ) {\n\t\t// Firefox, Chrome\n\t\tstack = e.stack.split( \"\\n\" );\n\t\tif (/^error$/i.test( stack[0] ) ) {\n\t\t\tstack.shift();\n\t\t}\n\t\tif ( fileName ) {\n\t\t\tinclude = [];\n\t\t\tfor ( i = offset; i < stack.length; i++ ) {\n\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinclude.push( stack[ i ] );\n\t\t\t}\n\t\t\tif ( include.length ) {\n\t\t\t\treturn include.join( \"\\n\" );\n\t\t\t}\n\t\t}\n\t\treturn stack[ offset ];\n\t} else if ( e.sourceURL ) {\n\t\t// Safari, PhantomJS\n\t\t// hopefully one day Safari provides actual stacktraces\n\t\t// exclude useless self-reference for generated Error objects\n\t\tif ( /qunit.js$/.test( e.sourceURL ) ) {\n\t\t\treturn;\n\t\t}\n\t\t// for actual exceptions, this is useful\n\t\treturn e.sourceURL + \":\" + e.line;\n\t}\n}\nfunction sourceFromStacktrace( offset ) {\n\ttry {\n\t\tthrow new Error();\n\t} catch ( e ) {\n\t\treturn extractStacktrace( e, offset );\n\t}\n}\n\n/**\n * Escape text for attribute or text content.\n */\nfunction escapeText( s ) {\n\tif ( !s ) {\n\t\treturn \"\";\n\t}\n\ts = s + \"\";\n\t// Both single quotes and double quotes (for attributes)\n\treturn s.replace( /['\"<>&]/g, function( s ) {\n\t\tswitch( s ) {\n\t\t\tcase \"'\":\n\t\t\t\treturn \"&#039;\";\n\t\t\tcase \"\\\"\":\n\t\t\t\treturn \"&quot;\";\n\t\t\tcase \"<\":\n\t\t\t\treturn \"&lt;\";\n\t\t\tcase \">\":\n\t\t\t\treturn \"&gt;\";\n\t\t\tcase \"&\":\n\t\t\t\treturn \"&amp;\";\n\t\t}\n\t});\n}\n\nfunction synchronize( callback, last ) {\n\tconfig.queue.push( callback );\n\n\tif ( config.autorun && !config.blocking ) {\n\t\tprocess( last );\n\t}\n}\n\nfunction process( last ) {\n\tfunction next() {\n\t\tprocess( last );\n\t}\n\tvar start = new Date().getTime();\n\tconfig.depth = config.depth ? config.depth + 1 : 1;\n\n\twhile ( config.queue.length && !config.blocking ) {\n\t\tif ( !defined.setTimeout || config.updateRate <= 0 || ( ( new Date().getTime() - start ) < config.updateRate ) ) {\n\t\t\tconfig.queue.shift()();\n\t\t} else {\n\t\t\tsetTimeout( next, 13 );\n\t\t\tbreak;\n\t\t}\n\t}\n\tconfig.depth--;\n\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\tdone();\n\t}\n}\n\nfunction saveGlobal() {\n\tconfig.pollution = [];\n\n\tif ( config.noglobals ) {\n\t\tfor ( var key in window ) {\n\t\t\tif ( hasOwn.call( window, key ) ) {\n\t\t\t\t// in Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconfig.pollution.push( key );\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction checkPollution() {\n\tvar newGlobals,\n\t\tdeletedGlobals,\n\t\told = config.pollution;\n\n\tsaveGlobal();\n\n\tnewGlobals = diff( config.pollution, old );\n\tif ( newGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Introduced global variable(s): \" + newGlobals.join(\", \") );\n\t}\n\n\tdeletedGlobals = diff( old, config.pollution );\n\tif ( deletedGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Deleted global variable(s): \" + deletedGlobals.join(\", \") );\n\t}\n}\n\n// returns a new Array with the elements that are in a but not in b\nfunction diff( a, b ) {\n\tvar i, j,\n\t\tresult = a.slice();\n\n\tfor ( i = 0; i < result.length; i++ ) {\n\t\tfor ( j = 0; j < b.length; j++ ) {\n\t\t\tif ( result[i] === b[j] ) {\n\t\t\t\tresult.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction extend( a, b ) {\n\tfor ( var prop in b ) {\n\t\tif ( hasOwn.call( b, prop ) ) {\n\t\t\t// Avoid \"Member not found\" error in IE8 caused by messing with window.constructor\n\t\t\tif ( !( prop === \"constructor\" && a === window ) ) {\n\t\t\t\tif ( b[ prop ] === undefined ) {\n\t\t\t\t\tdelete a[ prop ];\n\t\t\t\t} else {\n\t\t\t\t\ta[ prop ] = b[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a;\n}\n\n/**\n * @param {HTMLElement} elem\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvent( elem, type, fn ) {\n\tif ( elem.addEventListener ) {\n\n\t\t// Standards-based browsers\n\t\telem.addEventListener( type, fn, false );\n\t} else if ( elem.attachEvent ) {\n\n\t\t// support: IE <9\n\t\telem.attachEvent( \"on\" + type, fn );\n\t} else {\n\n\t\t// Caller must ensure support for event listeners is present\n\t\tthrow new Error( \"addEvent() was called in a context without event listener support\" );\n\t}\n}\n\n/**\n * @param {Array|NodeList} elems\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvents( elems, type, fn ) {\n\tvar i = elems.length;\n\twhile ( i-- ) {\n\t\taddEvent( elems[i], type, fn );\n\t}\n}\n\nfunction hasClass( elem, name ) {\n\treturn (\" \" + elem.className + \" \").indexOf(\" \" + name + \" \") > -1;\n}\n\nfunction addClass( elem, name ) {\n\tif ( !hasClass( elem, name ) ) {\n\t\telem.className += (elem.className ? \" \" : \"\") + name;\n\t}\n}\n\nfunction removeClass( elem, name ) {\n\tvar set = \" \" + elem.className + \" \";\n\t// Class name may appear multiple times\n\twhile ( set.indexOf(\" \" + name + \" \") > -1 ) {\n\t\tset = set.replace(\" \" + name + \" \" , \" \");\n\t}\n\t// If possible, trim it for prettiness, but not necessarily\n\telem.className = typeof set.trim === \"function\" ? set.trim() : set.replace(/^\\s+|\\s+$/g, \"\");\n}\n\nfunction id( name ) {\n\treturn defined.document && document.getElementById && document.getElementById( name );\n}\n\nfunction registerLoggingCallback( key ) {\n\treturn function( callback ) {\n\t\tconfig[key].push( callback );\n\t};\n}\n\n// Supports deprecated method of completely overwriting logging callbacks\nfunction runLoggingCallbacks( key, scope, args ) {\n\tvar i, callbacks;\n\tif ( QUnit.hasOwnProperty( key ) ) {\n\t\tQUnit[ key ].call(scope, args );\n\t} else {\n\t\tcallbacks = config[ key ];\n\t\tfor ( i = 0; i < callbacks.length; i++ ) {\n\t\t\tcallbacks[ i ].call( scope, args );\n\t\t}\n\t}\n}\n\n// from jquery.js\nfunction inArray( elem, array ) {\n\tif ( array.indexOf ) {\n\t\treturn array.indexOf( elem );\n\t}\n\n\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\tif ( array[ i ] === elem ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nfunction Test( settings ) {\n\textend( this, settings );\n\tthis.assertions = [];\n\tthis.testNumber = ++Test.count;\n}\n\nTest.count = 0;\n\nTest.prototype = {\n\tinit: function() {\n\t\tvar a, b, li,\n\t\t\ttests = id( \"qunit-tests\" );\n\n\t\tif ( tests ) {\n\t\t\tb = document.createElement( \"strong\" );\n\t\t\tb.innerHTML = this.nameHtml;\n\n\t\t\t// `a` initialized at top of scope\n\t\t\ta = document.createElement( \"a\" );\n\t\t\ta.innerHTML = \"Rerun\";\n\t\t\ta.href = QUnit.url({ testNumber: this.testNumber });\n\n\t\t\tli = document.createElement( \"li\" );\n\t\t\tli.appendChild( b );\n\t\t\tli.appendChild( a );\n\t\t\tli.className = \"running\";\n\t\t\tli.id = this.id = \"qunit-test-output\" + testId++;\n\n\t\t\ttests.appendChild( li );\n\t\t}\n\t},\n\tsetup: function() {\n\t\tif (\n\t\t\t// Emit moduleStart when we're switching from one module to another\n\t\t\tthis.module !== config.previousModule ||\n\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn't\n\t\t\t\t// yet exist it means this is the first test in a suite that isn't wrapped in a\n\t\t\t\t// module, in which case we'll just emit a moduleStart event for 'undefined'.\n\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t!hasOwn.call( config, \"previousModule\" )\n\t\t) {\n\t\t\tif ( hasOwn.call( config, \"previousModule\" ) ) {\n\t\t\t\trunLoggingCallbacks( \"moduleDone\", QUnit, {\n\t\t\t\t\tname: config.previousModule,\n\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\ttotal: config.moduleStats.all\n\t\t\t\t});\n\t\t\t}\n\t\t\tconfig.previousModule = this.module;\n\t\t\tconfig.moduleStats = { all: 0, bad: 0 };\n\t\t\trunLoggingCallbacks( \"moduleStart\", QUnit, {\n\t\t\t\tname: this.module\n\t\t\t});\n\t\t}\n\n\t\tconfig.current = this;\n\n\t\tthis.testEnvironment = extend({\n\t\t\tsetup: function() {},\n\t\t\tteardown: function() {}\n\t\t}, this.moduleTestEnvironment );\n\n\t\tthis.started = +new Date();\n\t\trunLoggingCallbacks( \"testStart\", QUnit, {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module\n\t\t});\n\n\t\t/*jshint camelcase:false */\n\n\n\t\t/**\n\t\t * Expose the current test environment.\n\t\t *\n\t\t * @deprecated since 1.12.0: Use QUnit.config.current.testEnvironment instead.\n\t\t */\n\t\tQUnit.current_testEnvironment = this.testEnvironment;\n\n\t\t/*jshint camelcase:true */\n\n\t\tif ( !config.pollution ) {\n\t\t\tsaveGlobal();\n\t\t}\n\t\tif ( config.notrycatch ) {\n\t\t\tthis.testEnvironment.setup.call( this.testEnvironment, QUnit.assert );\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tthis.testEnvironment.setup.call( this.testEnvironment, QUnit.assert );\n\t\t} catch( e ) {\n\t\t\tQUnit.pushFailure( \"Setup failed on \" + this.testName + \": \" + ( e.message || e ), extractStacktrace( e, 1 ) );\n\t\t}\n\t},\n\trun: function() {\n\t\tconfig.current = this;\n\n\t\tvar running = id( \"qunit-testresult\" );\n\n\t\tif ( running ) {\n\t\t\trunning.innerHTML = \"Running: <br/>\" + this.nameHtml;\n\t\t}\n\n\t\tif ( this.async ) {\n\t\t\tQUnit.stop();\n\t\t}\n\n\t\tthis.callbackStarted = +new Date();\n\n\t\tif ( config.notrycatch ) {\n\t\t\tthis.callback.call( this.testEnvironment, QUnit.assert );\n\t\t\tthis.callbackRuntime = +new Date() - this.callbackStarted;\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tthis.callback.call( this.testEnvironment, QUnit.assert );\n\t\t\tthis.callbackRuntime = +new Date() - this.callbackStarted;\n\t\t} catch( e ) {\n\t\t\tthis.callbackRuntime = +new Date() - this.callbackStarted;\n\n\t\t\tQUnit.pushFailure( \"Died on test #\" + (this.assertions.length + 1) + \" \" + this.stack + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );\n\t\t\t// else next test will carry the responsibility\n\t\t\tsaveGlobal();\n\n\t\t\t// Restart the tests if they're blocking\n\t\t\tif ( config.blocking ) {\n\t\t\t\tQUnit.start();\n\t\t\t}\n\t\t}\n\t},\n\tteardown: function() {\n\t\tconfig.current = this;\n\t\tif ( config.notrycatch ) {\n\t\t\tif ( typeof this.callbackRuntime === \"undefined\" ) {\n\t\t\t\tthis.callbackRuntime = +new Date() - this.callbackStarted;\n\t\t\t}\n\t\t\tthis.testEnvironment.teardown.call( this.testEnvironment, QUnit.assert );\n\t\t\treturn;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tthis.testEnvironment.teardown.call( this.testEnvironment, QUnit.assert );\n\t\t\t} catch( e ) {\n\t\t\t\tQUnit.pushFailure( \"Teardown failed on \" + this.testName + \": \" + ( e.message || e ), extractStacktrace( e, 1 ) );\n\t\t\t}\n\t\t}\n\t\tcheckPollution();\n\t},\n\tfinish: function() {\n\t\tconfig.current = this;\n\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\tQUnit.pushFailure( \"Expected number of assertions to be defined, but expect() was not called.\", this.stack );\n\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\tQUnit.pushFailure( \"Expected \" + this.expected + \" assertions, but \" + this.assertions.length + \" were run\", this.stack );\n\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\tQUnit.pushFailure( \"Expected at least one assertion, but none were run - call expect(0) to accept zero assertions.\", this.stack );\n\t\t}\n\n\t\tvar i, assertion, a, b, time, li, ol,\n\t\t\ttest = this,\n\t\t\tgood = 0,\n\t\t\tbad = 0,\n\t\t\ttests = id( \"qunit-tests\" );\n\n\t\tthis.runtime = +new Date() - this.started;\n\t\tconfig.stats.all += this.assertions.length;\n\t\tconfig.moduleStats.all += this.assertions.length;\n\n\t\tif ( tests ) {\n\t\t\tol = document.createElement( \"ol\" );\n\t\t\tol.className = \"qunit-assert-list\";\n\n\t\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\t\tassertion = this.assertions[i];\n\n\t\t\t\tli = document.createElement( \"li\" );\n\t\t\t\tli.className = assertion.result ? \"pass\" : \"fail\";\n\t\t\t\tli.innerHTML = assertion.message || ( assertion.result ? \"okay\" : \"failed\" );\n\t\t\t\tol.appendChild( li );\n\n\t\t\t\tif ( assertion.result ) {\n\t\t\t\t\tgood++;\n\t\t\t\t} else {\n\t\t\t\t\tbad++;\n\t\t\t\t\tconfig.stats.bad++;\n\t\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// store result when possible\n\t\t\tif ( QUnit.config.reorder && defined.sessionStorage ) {\n\t\t\t\tif ( bad ) {\n\t\t\t\t\tsessionStorage.setItem( \"qunit-test-\" + this.module + \"-\" + this.testName, bad );\n\t\t\t\t} else {\n\t\t\t\t\tsessionStorage.removeItem( \"qunit-test-\" + this.module + \"-\" + this.testName );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( bad === 0 ) {\n\t\t\t\taddClass( ol, \"qunit-collapsed\" );\n\t\t\t}\n\n\t\t\t// `b` initialized at top of scope\n\t\t\tb = document.createElement( \"strong\" );\n\t\t\tb.innerHTML = this.nameHtml + \" <b class='counts'>(<b class='failed'>\" + bad + \"</b>, <b class='passed'>\" + good + \"</b>, \" + this.assertions.length + \")</b>\";\n\n\t\t\taddEvent(b, \"click\", function() {\n\t\t\t\tvar next = b.parentNode.lastChild,\n\t\t\t\t\tcollapsed = hasClass( next, \"qunit-collapsed\" );\n\t\t\t\t( collapsed ? removeClass : addClass )( next, \"qunit-collapsed\" );\n\t\t\t});\n\n\t\t\taddEvent(b, \"dblclick\", function( e ) {\n\t\t\t\tvar target = e && e.target ? e.target : window.event.srcElement;\n\t\t\t\tif ( target.nodeName.toLowerCase() === \"span\" || target.nodeName.toLowerCase() === \"b\" ) {\n\t\t\t\t\ttarget = target.parentNode;\n\t\t\t\t}\n\t\t\t\tif ( window.location && target.nodeName.toLowerCase() === \"strong\" ) {\n\t\t\t\t\twindow.location = QUnit.url({ testNumber: test.testNumber });\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// `time` initialized at top of scope\n\t\t\ttime = document.createElement( \"span\" );\n\t\t\ttime.className = \"runtime\";\n\t\t\ttime.innerHTML = this.runtime + \" ms\";\n\n\t\t\t// `li` initialized at top of scope\n\t\t\tli = id( this.id );\n\t\t\tli.className = bad ? \"fail\" : \"pass\";\n\t\t\tli.removeChild( li.firstChild );\n\t\t\ta = li.firstChild;\n\t\t\tli.appendChild( b );\n\t\t\tli.appendChild( a );\n\t\t\tli.appendChild( time );\n\t\t\tli.appendChild( ol );\n\n\t\t} else {\n\t\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\t\tif ( !this.assertions[i].result ) {\n\t\t\t\t\tbad++;\n\t\t\t\t\tconfig.stats.bad++;\n\t\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( \"testDone\", QUnit, {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module,\n\t\t\tfailed: bad,\n\t\t\tpassed: this.assertions.length - bad,\n\t\t\ttotal: this.assertions.length,\n\t\t\truntime: this.runtime,\n\t\t\t// DEPRECATED: this property will be removed in 2.0.0, use runtime instead\n\t\t\tduration: this.runtime\n\t\t});\n\n\t\tQUnit.reset();\n\n\t\tconfig.current = undefined;\n\t},\n\n\tqueue: function() {\n\t\tvar bad,\n\t\t\ttest = this;\n\n\t\tsynchronize(function() {\n\t\t\ttest.init();\n\t\t});\n\t\tfunction run() {\n\t\t\t// each of these can by async\n\t\t\tsynchronize(function() {\n\t\t\t\ttest.setup();\n\t\t\t});\n\t\t\tsynchronize(function() {\n\t\t\t\ttest.run();\n\t\t\t});\n\t\t\tsynchronize(function() {\n\t\t\t\ttest.teardown();\n\t\t\t});\n\t\t\tsynchronize(function() {\n\t\t\t\ttest.finish();\n\t\t\t});\n\t\t}\n\n\t\t// `bad` initialized at top of scope\n\t\t// defer when previous test run passed, if storage is available\n\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t\t\t+sessionStorage.getItem( \"qunit-test-\" + this.module + \"-\" + this.testName );\n\n\t\tif ( bad ) {\n\t\t\trun();\n\t\t} else {\n\t\t\tsynchronize( run, true );\n\t\t}\n\t}\n};\n\n// `assert` initialized at top of scope\n// Assert helpers\n// All of these must either call QUnit.push() or manually do:\n// - runLoggingCallbacks( \"log\", .. );\n// - config.current.assertions.push({ .. });\nassert = QUnit.assert = {\n\t/**\n\t * Asserts rough true-ish result.\n\t * @name ok\n\t * @function\n\t * @example ok( \"asdfasdf\".length > 5, \"There must be at least 5 chars\" );\n\t */\n\tok: function( result, msg ) {\n\t\tif ( !config.current ) {\n\t\t\tthrow new Error( \"ok() assertion outside test context, was \" + sourceFromStacktrace(2) );\n\t\t}\n\t\tresult = !!result;\n\t\tmsg = msg || ( result ? \"okay\" : \"failed\" );\n\n\t\tvar source,\n\t\t\tdetails = {\n\t\t\t\tmodule: config.current.module,\n\t\t\t\tname: config.current.testName,\n\t\t\t\tresult: result,\n\t\t\t\tmessage: msg\n\t\t\t};\n\n\t\tmsg = \"<span class='test-message'>\" + escapeText( msg ) + \"</span>\";\n\n\t\tif ( !result ) {\n\t\t\tsource = sourceFromStacktrace( 2 );\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t\tmsg += \"<table><tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\t\t\tescapeText( source ) +\n\t\t\t\t\t\"</pre></td></tr></table>\";\n\t\t\t}\n\t\t}\n\t\trunLoggingCallbacks( \"log\", QUnit, details );\n\t\tconfig.current.assertions.push({\n\t\t\tresult: result,\n\t\t\tmessage: msg\n\t\t});\n\t},\n\n\t/**\n\t * Assert that the first two arguments are equal, with an optional message.\n\t * Prints out both actual and expected values.\n\t * @name equal\n\t * @function\n\t * @example equal( format( \"Received {0} bytes.\", 2), \"Received 2 bytes.\", \"format() replaces {0} with next argument\" );\n\t */\n\tequal: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tQUnit.push( expected == actual, actual, expected, message );\n\t},\n\n\t/**\n\t * @name notEqual\n\t * @function\n\t */\n\tnotEqual: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tQUnit.push( expected != actual, actual, expected, message );\n\t},\n\n\t/**\n\t * @name propEqual\n\t * @function\n\t */\n\tpropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues(actual);\n\t\texpected = objectValues(expected);\n\t\tQUnit.push( QUnit.equiv(actual, expected), actual, expected, message );\n\t},\n\n\t/**\n\t * @name notPropEqual\n\t * @function\n\t */\n\tnotPropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues(actual);\n\t\texpected = objectValues(expected);\n\t\tQUnit.push( !QUnit.equiv(actual, expected), actual, expected, message );\n\t},\n\n\t/**\n\t * @name deepEqual\n\t * @function\n\t */\n\tdeepEqual: function( actual, expected, message ) {\n\t\tQUnit.push( QUnit.equiv(actual, expected), actual, expected, message );\n\t},\n\n\t/**\n\t * @name notDeepEqual\n\t * @function\n\t */\n\tnotDeepEqual: function( actual, expected, message ) {\n\t\tQUnit.push( !QUnit.equiv(actual, expected), actual, expected, message );\n\t},\n\n\t/**\n\t * @name strictEqual\n\t * @function\n\t */\n\tstrictEqual: function( actual, expected, message ) {\n\t\tQUnit.push( expected === actual, actual, expected, message );\n\t},\n\n\t/**\n\t * @name notStrictEqual\n\t * @function\n\t */\n\tnotStrictEqual: function( actual, expected, message ) {\n\t\tQUnit.push( expected !== actual, actual, expected, message );\n\t},\n\n\t\"throws\": function( block, expected, message ) {\n\t\tvar actual,\n\t\t\texpectedOutput = expected,\n\t\t\tok = false;\n\n\t\t// 'expected' is optional\n\t\tif ( !message && typeof expected === \"string\" ) {\n\t\t\tmessage = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tconfig.current.ignoreGlobalErrors = true;\n\t\ttry {\n\t\t\tblock.call( config.current.testEnvironment );\n\t\t} catch (e) {\n\t\t\tactual = e;\n\t\t}\n\t\tconfig.current.ignoreGlobalErrors = false;\n\n\t\tif ( actual ) {\n\n\t\t\t// we don't want to validate thrown error\n\t\t\tif ( !expected ) {\n\t\t\t\tok = true;\n\t\t\t\texpectedOutput = null;\n\n\t\t\t// expected is an Error object\n\t\t\t} else if ( expected instanceof Error ) {\n\t\t\t\tok = actual instanceof Error &&\n\t\t\t\t\t actual.name === expected.name &&\n\t\t\t\t\t actual.message === expected.message;\n\n\t\t\t// expected is a regexp\n\t\t\t} else if ( QUnit.objectType( expected ) === \"regexp\" ) {\n\t\t\t\tok = expected.test( errorString( actual ) );\n\n\t\t\t// expected is a string\n\t\t\t} else if ( QUnit.objectType( expected ) === \"string\" ) {\n\t\t\t\tok = expected === errorString( actual );\n\n\t\t\t// expected is a constructor\n\t\t\t} else if ( actual instanceof expected ) {\n\t\t\t\tok = true;\n\n\t\t\t// expected is a validation function which returns true is validation passed\n\t\t\t} else if ( expected.call( {}, actual ) === true ) {\n\t\t\t\texpectedOutput = null;\n\t\t\t\tok = true;\n\t\t\t}\n\n\t\t\tQUnit.push( ok, actual, expectedOutput, message );\n\t\t} else {\n\t\t\tQUnit.pushFailure( message, null, \"No exception was thrown.\" );\n\t\t}\n\t}\n};\n\n/**\n * @deprecated since 1.8.0\n * Kept assertion helpers in root for backwards compatibility.\n */\nextend( QUnit.constructor.prototype, assert );\n\n/**\n * @deprecated since 1.9.0\n * Kept to avoid TypeErrors for undefined methods.\n */\nQUnit.constructor.prototype.raises = function() {\n\tQUnit.push( false, false, false, \"QUnit.raises has been deprecated since 2012 (fad3c1ea), use QUnit.throws instead\" );\n};\n\n/**\n * @deprecated since 1.0.0, replaced with error pushes since 1.3.0\n * Kept to avoid TypeErrors for undefined methods.\n */\nQUnit.constructor.prototype.equals = function() {\n\tQUnit.push( false, false, false, \"QUnit.equals has been deprecated since 2009 (e88049a0), use QUnit.equal instead\" );\n};\nQUnit.constructor.prototype.same = function() {\n\tQUnit.push( false, false, false, \"QUnit.same has been deprecated since 2009 (e88049a0), use QUnit.deepEqual instead\" );\n};\n\n// Test for equality any JavaScript type.\n// Author: Philippe Rath <prathe@gmail.com>\nQUnit.equiv = (function() {\n\n\t// Call the o related callback with the given arguments.\n\tfunction bindCallbacks( o, callbacks, args ) {\n\t\tvar prop = QUnit.objectType( o );\n\t\tif ( prop ) {\n\t\t\tif ( QUnit.objectType( callbacks[ prop ] ) === \"function\" ) {\n\t\t\t\treturn callbacks[ prop ].apply( callbacks, args );\n\t\t\t} else {\n\t\t\t\treturn callbacks[ prop ]; // or undefined\n\t\t\t}\n\t\t}\n\t}\n\n\t// the real equiv function\n\tvar innerEquiv,\n\t\t// stack to decide between skip/abort functions\n\t\tcallers = [],\n\t\t// stack to avoiding loops from circular referencing\n\t\tparents = [],\n\t\tparentsB = [],\n\n\t\tgetProto = Object.getPrototypeOf || function ( obj ) {\n\t\t\t/*jshint camelcase:false */\n\t\t\treturn obj.__proto__;\n\t\t},\n\t\tcallbacks = (function () {\n\n\t\t\t// for string, boolean, number and null\n\t\t\tfunction useStrictEquality( b, a ) {\n\t\t\t\t/*jshint eqeqeq:false */\n\t\t\t\tif ( b instanceof a.constructor || a instanceof b.constructor ) {\n\t\t\t\t\t// to catch short annotation VS 'new' annotation of a\n\t\t\t\t\t// declaration\n\t\t\t\t\t// e.g. var i = 1;\n\t\t\t\t\t// var j = new Number(1);\n\t\t\t\t\treturn a == b;\n\t\t\t\t} else {\n\t\t\t\t\treturn a === b;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t\"string\": useStrictEquality,\n\t\t\t\t\"boolean\": useStrictEquality,\n\t\t\t\t\"number\": useStrictEquality,\n\t\t\t\t\"null\": useStrictEquality,\n\t\t\t\t\"undefined\": useStrictEquality,\n\n\t\t\t\t\"nan\": function( b ) {\n\t\t\t\t\treturn isNaN( b );\n\t\t\t\t},\n\n\t\t\t\t\"date\": function( b, a ) {\n\t\t\t\t\treturn QUnit.objectType( b ) === \"date\" && a.valueOf() === b.valueOf();\n\t\t\t\t},\n\n\t\t\t\t\"regexp\": function( b, a ) {\n\t\t\t\t\treturn QUnit.objectType( b ) === \"regexp\" &&\n\t\t\t\t\t\t// the regex itself\n\t\t\t\t\t\ta.source === b.source &&\n\t\t\t\t\t\t// and its modifiers\n\t\t\t\t\t\ta.global === b.global &&\n\t\t\t\t\t\t// (gmi) ...\n\t\t\t\t\t\ta.ignoreCase === b.ignoreCase &&\n\t\t\t\t\t\ta.multiline === b.multiline &&\n\t\t\t\t\t\ta.sticky === b.sticky;\n\t\t\t\t},\n\n\t\t\t\t// - skip when the property is a method of an instance (OOP)\n\t\t\t\t// - abort otherwise,\n\t\t\t\t// initial === would have catch identical references anyway\n\t\t\t\t\"function\": function() {\n\t\t\t\t\tvar caller = callers[callers.length - 1];\n\t\t\t\t\treturn caller !== Object && typeof caller !== \"undefined\";\n\t\t\t\t},\n\n\t\t\t\t\"array\": function( b, a ) {\n\t\t\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\n\t\t\t\t\t// b could be an object literal here\n\t\t\t\t\tif ( QUnit.objectType( b ) !== \"array\" ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tlen = a.length;\n\t\t\t\t\tif ( len !== b.length ) {\n\t\t\t\t\t\t// safe and faster\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// track reference to avoid circular references\n\t\t\t\t\tparents.push( a );\n\t\t\t\t\tparentsB.push( b );\n\t\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\t\tloop = false;\n\t\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\t\t\taCircular = parents[j] === a[i];\n\t\t\t\t\t\t\tbCircular = parentsB[j] === b[i];\n\t\t\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\t\t\tif ( a[i] === b[i] || aCircular && bCircular ) {\n\t\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( !loop && !innerEquiv(a[i], b[i]) ) {\n\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\t\"object\": function( b, a ) {\n\t\t\t\t\t/*jshint forin:false */\n\t\t\t\t\tvar i, j, loop, aCircular, bCircular,\n\t\t\t\t\t\t// Default to true\n\t\t\t\t\t\teq = true,\n\t\t\t\t\t\taProperties = [],\n\t\t\t\t\t\tbProperties = [];\n\n\t\t\t\t\t// comparing constructors is more strict than using\n\t\t\t\t\t// instanceof\n\t\t\t\t\tif ( a.constructor !== b.constructor ) {\n\t\t\t\t\t\t// Allow objects with no prototype to be equivalent to\n\t\t\t\t\t\t// objects with Object as their constructor.\n\t\t\t\t\t\tif ( !(( getProto(a) === null && getProto(b) === Object.prototype ) ||\n\t\t\t\t\t\t\t( getProto(b) === null && getProto(a) === Object.prototype ) ) ) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// stack constructor before traversing properties\n\t\t\t\t\tcallers.push( a.constructor );\n\n\t\t\t\t\t// track reference to avoid circular references\n\t\t\t\t\tparents.push( a );\n\t\t\t\t\tparentsB.push( b );\n\n\t\t\t\t\t// be strict: don't ensure hasOwnProperty and go deep\n\t\t\t\t\tfor ( i in a ) {\n\t\t\t\t\t\tloop = false;\n\t\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\t\t\taCircular = parents[j] === a[i];\n\t\t\t\t\t\t\tbCircular = parentsB[j] === b[i];\n\t\t\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\t\t\tif ( a[i] === b[i] || aCircular && bCircular ) {\n\t\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\taProperties.push(i);\n\t\t\t\t\t\tif ( !loop && !innerEquiv(a[i], b[i]) ) {\n\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\tcallers.pop(); // unstack, we are done\n\n\t\t\t\t\tfor ( i in b ) {\n\t\t\t\t\t\tbProperties.push( i ); // collect b's properties\n\t\t\t\t\t}\n\n\t\t\t\t\t// Ensures identical properties name\n\t\t\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t\t\t}\n\t\t\t};\n\t\t}());\n\n\tinnerEquiv = function() { // can take multiple arguments\n\t\tvar args = [].slice.apply( arguments );\n\t\tif ( args.length < 2 ) {\n\t\t\treturn true; // end transition\n\t\t}\n\n\t\treturn (function( a, b ) {\n\t\t\tif ( a === b ) {\n\t\t\t\treturn true; // catch the most you can\n\t\t\t} else if ( a === null || b === null || typeof a === \"undefined\" ||\n\t\t\t\t\ttypeof b === \"undefined\" ||\n\t\t\t\t\tQUnit.objectType(a) !== QUnit.objectType(b) ) {\n\t\t\t\treturn false; // don't lose time with error prone cases\n\t\t\t} else {\n\t\t\t\treturn bindCallbacks(a, callbacks, [ b, a ]);\n\t\t\t}\n\n\t\t\t// apply transition with (1..n) arguments\n\t\t}( args[0], args[1] ) && innerEquiv.apply( this, args.splice(1, args.length - 1 )) );\n\t};\n\n\treturn innerEquiv;\n}());\n\n/**\n * jsDump Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com |\n * http://flesler.blogspot.com Licensed under BSD\n * (http://www.opensource.org/licenses/bsd-license.php) Date: 5/15/2008\n *\n * @projectDescription Advanced and extensible data dumping for Javascript.\n * @version 1.0.0\n * @author Ariel Flesler\n * @link {http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html}\n */\nQUnit.jsDump = (function() {\n\tfunction quote( str ) {\n\t\treturn \"\\\"\" + str.toString().replace( /\"/g, \"\\\\\\\"\" ) + \"\\\"\";\n\t}\n\tfunction literal( o ) {\n\t\treturn o + \"\";\n\t}\n\tfunction join( pre, arr, post ) {\n\t\tvar s = jsDump.separator(),\n\t\t\tbase = jsDump.indent(),\n\t\t\tinner = jsDump.indent(1);\n\t\tif ( arr.join ) {\n\t\t\tarr = arr.join( \",\" + s + inner );\n\t\t}\n\t\tif ( !arr ) {\n\t\t\treturn pre + post;\n\t\t}\n\t\treturn [ pre, inner + arr, base + post ].join(s);\n\t}\n\tfunction array( arr, stack ) {\n\t\tvar i = arr.length, ret = new Array(i);\n\t\tthis.up();\n\t\twhile ( i-- ) {\n\t\t\tret[i] = this.parse( arr[i] , undefined , stack);\n\t\t}\n\t\tthis.down();\n\t\treturn join( \"[\", ret, \"]\" );\n\t}\n\n\tvar reName = /^function (\\w+)/,\n\t\tjsDump = {\n\t\t\t// type is used mostly internally, you can fix a (custom)type in advance\n\t\t\tparse: function( obj, type, stack ) {\n\t\t\t\tstack = stack || [ ];\n\t\t\t\tvar inStack, res,\n\t\t\t\t\tparser = this.parsers[ type || this.typeOf(obj) ];\n\n\t\t\t\ttype = typeof parser;\n\t\t\t\tinStack = inArray( obj, stack );\n\n\t\t\t\tif ( inStack !== -1 ) {\n\t\t\t\t\treturn \"recursion(\" + (inStack - stack.length) + \")\";\n\t\t\t\t}\n\t\t\t\tif ( type === \"function\" )  {\n\t\t\t\t\tstack.push( obj );\n\t\t\t\t\tres = parser.call( this, obj, stack );\n\t\t\t\t\tstack.pop();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\treturn ( type === \"string\" ) ? parser : this.parsers.error;\n\t\t\t},\n\t\t\ttypeOf: function( obj ) {\n\t\t\t\tvar type;\n\t\t\t\tif ( obj === null ) {\n\t\t\t\t\ttype = \"null\";\n\t\t\t\t} else if ( typeof obj === \"undefined\" ) {\n\t\t\t\t\ttype = \"undefined\";\n\t\t\t\t} else if ( QUnit.is( \"regexp\", obj) ) {\n\t\t\t\t\ttype = \"regexp\";\n\t\t\t\t} else if ( QUnit.is( \"date\", obj) ) {\n\t\t\t\t\ttype = \"date\";\n\t\t\t\t} else if ( QUnit.is( \"function\", obj) ) {\n\t\t\t\t\ttype = \"function\";\n\t\t\t\t} else if ( typeof obj.setInterval !== undefined && typeof obj.document !== \"undefined\" && typeof obj.nodeType === \"undefined\" ) {\n\t\t\t\t\ttype = \"window\";\n\t\t\t\t} else if ( obj.nodeType === 9 ) {\n\t\t\t\t\ttype = \"document\";\n\t\t\t\t} else if ( obj.nodeType ) {\n\t\t\t\t\ttype = \"node\";\n\t\t\t\t} else if (\n\t\t\t\t\t// native arrays\n\t\t\t\t\ttoString.call( obj ) === \"[object Array]\" ||\n\t\t\t\t\t// NodeList objects\n\t\t\t\t\t( typeof obj.length === \"number\" && typeof obj.item !== \"undefined\" && ( obj.length ? obj.item(0) === obj[0] : ( obj.item( 0 ) === null && typeof obj[0] === \"undefined\" ) ) )\n\t\t\t\t) {\n\t\t\t\t\ttype = \"array\";\n\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {\n\t\t\t\t\ttype = \"error\";\n\t\t\t\t} else {\n\t\t\t\t\ttype = typeof obj;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\t\t\tseparator: function() {\n\t\t\t\treturn this.multiline ?\tthis.HTML ? \"<br />\" : \"\\n\" : this.HTML ? \"&nbsp;\" : \" \";\n\t\t\t},\n\t\t\t// extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\tindent: function( extra ) {\n\t\t\t\tif ( !this.multiline ) {\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\t\t\t\tvar chr = this.indentChar;\n\t\t\t\tif ( this.HTML ) {\n\t\t\t\t\tchr = chr.replace( /\\t/g, \"   \" ).replace( / /g, \"&nbsp;\" );\n\t\t\t\t}\n\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join(chr);\n\t\t\t},\n\t\t\tup: function( a ) {\n\t\t\t\tthis.depth += a || 1;\n\t\t\t},\n\t\t\tdown: function( a ) {\n\t\t\t\tthis.depth -= a || 1;\n\t\t\t},\n\t\t\tsetParser: function( name, parser ) {\n\t\t\t\tthis.parsers[name] = parser;\n\t\t\t},\n\t\t\t// The next 3 are exposed so you can use them\n\t\t\tquote: quote,\n\t\t\tliteral: literal,\n\t\t\tjoin: join,\n\t\t\t//\n\t\t\tdepth: 1,\n\t\t\t// This is the list of parsers, to modify them, use jsDump.setParser\n\t\t\tparsers: {\n\t\t\t\twindow: \"[Window]\",\n\t\t\t\tdocument: \"[Document]\",\n\t\t\t\terror: function(error) {\n\t\t\t\t\treturn \"Error(\\\"\" + error.message + \"\\\")\";\n\t\t\t\t},\n\t\t\t\tunknown: \"[Unknown]\",\n\t\t\t\t\"null\": \"null\",\n\t\t\t\t\"undefined\": \"undefined\",\n\t\t\t\t\"function\": function( fn ) {\n\t\t\t\t\tvar ret = \"function\",\n\t\t\t\t\t\t// functions never have name in IE\n\t\t\t\t\t\tname = \"name\" in fn ? fn.name : (reName.exec(fn) || [])[1];\n\n\t\t\t\t\tif ( name ) {\n\t\t\t\t\t\tret += \" \" + name;\n\t\t\t\t\t}\n\t\t\t\t\tret += \"( \";\n\n\t\t\t\t\tret = [ ret, QUnit.jsDump.parse( fn, \"functionArgs\" ), \"){\" ].join( \"\" );\n\t\t\t\t\treturn join( ret, QUnit.jsDump.parse(fn,\"functionCode\" ), \"}\" );\n\t\t\t\t},\n\t\t\t\tarray: array,\n\t\t\t\tnodelist: array,\n\t\t\t\t\"arguments\": array,\n\t\t\t\tobject: function( map, stack ) {\n\t\t\t\t\t/*jshint forin:false */\n\t\t\t\t\tvar ret = [ ], keys, key, val, i;\n\t\t\t\t\tQUnit.jsDump.up();\n\t\t\t\t\tkeys = [];\n\t\t\t\t\tfor ( key in map ) {\n\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t}\n\t\t\t\t\tkeys.sort();\n\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\n\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\tval = map[ key ];\n\t\t\t\t\t\tret.push( QUnit.jsDump.parse( key, \"key\" ) + \": \" + QUnit.jsDump.parse( val, undefined, stack ) );\n\t\t\t\t\t}\n\t\t\t\t\tQUnit.jsDump.down();\n\t\t\t\t\treturn join( \"{\", ret, \"}\" );\n\t\t\t\t},\n\t\t\t\tnode: function( node ) {\n\t\t\t\t\tvar len, i, val,\n\t\t\t\t\t\topen = QUnit.jsDump.HTML ? \"&lt;\" : \"<\",\n\t\t\t\t\t\tclose = QUnit.jsDump.HTML ? \"&gt;\" : \">\",\n\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\n\t\t\t\t\t\tret = open + tag,\n\t\t\t\t\t\tattrs = node.attributes;\n\n\t\t\t\t\tif ( attrs ) {\n\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {\n\t\t\t\t\t\t\tval = attrs[i].nodeValue;\n\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly set.\n\t\t\t\t\t\t\t// Those have values like undefined, null, 0, false, \"\" or \"inherit\".\n\t\t\t\t\t\t\tif ( val && val !== \"inherit\" ) {\n\t\t\t\t\t\t\t\tret += \" \" + attrs[i].nodeName + \"=\" + QUnit.jsDump.parse( val, \"attribute\" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret += close;\n\n\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {\n\t\t\t\t\t\tret += node.nodeValue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret + open + \"/\" + tag + close;\n\t\t\t\t},\n\t\t\t\t// function calls it internally, it's the arguments part of the function\n\t\t\t\tfunctionArgs: function( fn ) {\n\t\t\t\t\tvar args,\n\t\t\t\t\t\tl = fn.length;\n\n\t\t\t\t\tif ( !l ) {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\n\t\t\t\t\targs = new Array(l);\n\t\t\t\t\twhile ( l-- ) {\n\t\t\t\t\t\t// 97 is 'a'\n\t\t\t\t\t\targs[l] = String.fromCharCode(97+l);\n\t\t\t\t\t}\n\t\t\t\t\treturn \" \" + args.join( \", \" ) + \" \";\n\t\t\t\t},\n\t\t\t\t// object calls it internally, the key part of an item in a map\n\t\t\t\tkey: quote,\n\t\t\t\t// function calls it internally, it's the content of the function\n\t\t\t\tfunctionCode: \"[code]\",\n\t\t\t\t// node calls it internally, it's an html attribute value\n\t\t\t\tattribute: quote,\n\t\t\t\tstring: quote,\n\t\t\t\tdate: quote,\n\t\t\t\tregexp: literal,\n\t\t\t\tnumber: literal,\n\t\t\t\t\"boolean\": literal\n\t\t\t},\n\t\t\t// if true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\tHTML: false,\n\t\t\t// indentation unit\n\t\t\tindentChar: \"  \",\n\t\t\t// if true, items in a collection, are separated by a \\n, else just a space.\n\t\t\tmultiline: true\n\t\t};\n\n\treturn jsDump;\n}());\n\n/*\n * Javascript Diff Algorithm\n *  By John Resig (http://ejohn.org/)\n *  Modified by Chu Alan \"sprite\"\n *\n * Released under the MIT license.\n *\n * More Info:\n *  http://ejohn.org/projects/javascript-diff-algorithm/\n *\n * Usage: QUnit.diff(expected, actual)\n *\n * QUnit.diff( \"the quick brown fox jumped over\", \"the quick fox jumps over\" ) == \"the  quick <del>brown </del> fox <del>jumped </del><ins>jumps </ins> over\"\n */\nQUnit.diff = (function() {\n\t/*jshint eqeqeq:false, eqnull:true */\n\tfunction diff( o, n ) {\n\t\tvar i,\n\t\t\tns = {},\n\t\t\tos = {};\n\n\t\tfor ( i = 0; i < n.length; i++ ) {\n\t\t\tif ( !hasOwn.call( ns, n[i] ) ) {\n\t\t\t\tns[ n[i] ] = {\n\t\t\t\t\trows: [],\n\t\t\t\t\to: null\n\t\t\t\t};\n\t\t\t}\n\t\t\tns[ n[i] ].rows.push( i );\n\t\t}\n\n\t\tfor ( i = 0; i < o.length; i++ ) {\n\t\t\tif ( !hasOwn.call( os, o[i] ) ) {\n\t\t\t\tos[ o[i] ] = {\n\t\t\t\t\trows: [],\n\t\t\t\t\tn: null\n\t\t\t\t};\n\t\t\t}\n\t\t\tos[ o[i] ].rows.push( i );\n\t\t}\n\n\t\tfor ( i in ns ) {\n\t\t\tif ( hasOwn.call( ns, i ) ) {\n\t\t\t\tif ( ns[i].rows.length === 1 && hasOwn.call( os, i ) && os[i].rows.length === 1 ) {\n\t\t\t\t\tn[ ns[i].rows[0] ] = {\n\t\t\t\t\t\ttext: n[ ns[i].rows[0] ],\n\t\t\t\t\t\trow: os[i].rows[0]\n\t\t\t\t\t};\n\t\t\t\t\to[ os[i].rows[0] ] = {\n\t\t\t\t\t\ttext: o[ os[i].rows[0] ],\n\t\t\t\t\t\trow: ns[i].rows[0]\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor ( i = 0; i < n.length - 1; i++ ) {\n\t\t\tif ( n[i].text != null && n[ i + 1 ].text == null && n[i].row + 1 < o.length && o[ n[i].row + 1 ].text == null &&\n\t\t\t\t\t\tn[ i + 1 ] == o[ n[i].row + 1 ] ) {\n\n\t\t\t\tn[ i + 1 ] = {\n\t\t\t\t\ttext: n[ i + 1 ],\n\t\t\t\t\trow: n[i].row + 1\n\t\t\t\t};\n\t\t\t\to[ n[i].row + 1 ] = {\n\t\t\t\t\ttext: o[ n[i].row + 1 ],\n\t\t\t\t\trow: i + 1\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tfor ( i = n.length - 1; i > 0; i-- ) {\n\t\t\tif ( n[i].text != null && n[ i - 1 ].text == null && n[i].row > 0 && o[ n[i].row - 1 ].text == null &&\n\t\t\t\t\t\tn[ i - 1 ] == o[ n[i].row - 1 ]) {\n\n\t\t\t\tn[ i - 1 ] = {\n\t\t\t\t\ttext: n[ i - 1 ],\n\t\t\t\t\trow: n[i].row - 1\n\t\t\t\t};\n\t\t\t\to[ n[i].row - 1 ] = {\n\t\t\t\t\ttext: o[ n[i].row - 1 ],\n\t\t\t\t\trow: i - 1\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\to: o,\n\t\t\tn: n\n\t\t};\n\t}\n\n\treturn function( o, n ) {\n\t\to = o.replace( /\\s+$/, \"\" );\n\t\tn = n.replace( /\\s+$/, \"\" );\n\n\t\tvar i, pre,\n\t\t\tstr = \"\",\n\t\t\tout = diff( o === \"\" ? [] : o.split(/\\s+/), n === \"\" ? [] : n.split(/\\s+/) ),\n\t\t\toSpace = o.match(/\\s+/g),\n\t\t\tnSpace = n.match(/\\s+/g);\n\n\t\tif ( oSpace == null ) {\n\t\t\toSpace = [ \" \" ];\n\t\t}\n\t\telse {\n\t\t\toSpace.push( \" \" );\n\t\t}\n\n\t\tif ( nSpace == null ) {\n\t\t\tnSpace = [ \" \" ];\n\t\t}\n\t\telse {\n\t\t\tnSpace.push( \" \" );\n\t\t}\n\n\t\tif ( out.n.length === 0 ) {\n\t\t\tfor ( i = 0; i < out.o.length; i++ ) {\n\t\t\t\tstr += \"<del>\" + out.o[i] + oSpace[i] + \"</del>\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( out.n[0].text == null ) {\n\t\t\t\tfor ( n = 0; n < out.o.length && out.o[n].text == null; n++ ) {\n\t\t\t\t\tstr += \"<del>\" + out.o[n] + oSpace[n] + \"</del>\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < out.n.length; i++ ) {\n\t\t\t\tif (out.n[i].text == null) {\n\t\t\t\t\tstr += \"<ins>\" + out.n[i] + nSpace[i] + \"</ins>\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// `pre` initialized at top of scope\n\t\t\t\t\tpre = \"\";\n\n\t\t\t\t\tfor ( n = out.n[i].row + 1; n < out.o.length && out.o[n].text == null; n++ ) {\n\t\t\t\t\t\tpre += \"<del>\" + out.o[n] + oSpace[n] + \"</del>\";\n\t\t\t\t\t}\n\t\t\t\t\tstr += \" \" + out.n[i].text + nSpace[i] + pre;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn str;\n\t};\n}());\n\n// For browser, export only select globals\nif ( typeof window !== \"undefined\" ) {\n\textend( window, QUnit.constructor.prototype );\n\twindow.QUnit = QUnit;\n}\n\n// For CommonJS environments, export everything\nif ( typeof module !== \"undefined\" && module.exports ) {\n\tmodule.exports = QUnit;\n}\n\n\n// Get a reference to the global object, like window in browsers\n}( (function() {\n\treturn this;\n})() ));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../bower_components/qunit/qunit/qunit.js\n// module id = 21\n// module chunks = 1","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/process/browser.js\n// module id = 22\n// module chunks = 1","/**\n * QUnit-TAP - A TAP Output Producer Plugin for QUnit\n *\n * https://github.com/twada/qunit-tap\n * version: 1.5.0\n *\n * Copyright (c) 2010-2014 Takuto Wada\n * Dual licensed under the MIT and GPLv2 licenses.\n *   https://raw.github.com/twada/qunit-tap/master/MIT-LICENSE.txt\n *   https://raw.github.com/twada/qunit-tap/master/GPL-LICENSE.txt\n *\n * A part of extend function is:\n *   Copyright 2012 jQuery Foundation and other contributors\n *   Released under the MIT license.\n *   http://jquery.org/license\n */\n(function (root, factory) {\n    'use strict';\n\n    // using returnExports UMD pattern\n    if (typeof define === 'function' && define.amd) {\n        define(factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.qunitTap = factory();\n    }\n}(this, function () {\n    'use strict';\n\n    var qunitTapVersion = '1.5.0',\n        slice = Array.prototype.slice;\n\n    // borrowed from qunit.js\n    function extend (a, b) {\n        var prop;\n        for (prop in b) {\n            if (b.hasOwnProperty(prop)) {\n                if (typeof b[prop] === 'undefined') {\n                    delete a[prop];\n                } else {\n                    a[prop] = b[prop];\n                }\n            }\n        }\n        return a;\n    }\n\n    function indexOf (ary, element) {\n        var i;\n        for (i = 0; i < ary.length; i += 1) {\n            if (ary[i] === element) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    function removeElement (ary, element) {\n        var index = indexOf(ary, element);\n        if (index !== -1) {\n            return ary.splice(index, 1);\n        } else {\n            return [];\n        }\n    }\n\n    function isPlanRequired (conf) {\n        return (typeof conf !== 'undefined' && typeof conf.requireExpects !== 'undefined' && conf.requireExpects);\n    }\n\n    function isPassed (details) {\n        return !!(details.result);\n    }\n\n    function isFailed (details) {\n        return !(isPassed(details));\n    }\n\n    function isAssertOkFailed (details) {\n        return isFailed(details) && typeof details.expected === 'undefined' && typeof details.actual === 'undefined';\n    }\n\n    function escapeLineEndings (str) {\n        return str.replace(/(\\r?\\n)/g, '$&# ');\n    }\n\n    function ltrim (str) {\n        return str.replace(/^\\s+/, '');\n    }\n\n    function noop (obj) {\n        return obj;\n    }\n\n    function render (desc, fieldName, fieldValue, formatter) {\n        desc.push(fieldName + ': ' + formatter(fieldValue));\n    }\n\n    function renderIf (shouldRender, desc, fieldName, fieldValue, formatter) {\n        if (!shouldRender || typeof fieldValue === 'undefined') {\n            return;\n        }\n        render(desc, fieldName, fieldValue, formatter);\n    }\n\n    function formatTestLine (testLine, rest) {\n        if (!rest) {\n            return testLine;\n        }\n        return testLine + ' - ' + escapeLineEndings(rest);\n    }\n\n    var createCallbackAppenderFor = function (qu) {\n        return function (subject, observer, event) {\n            var originalLoggingCallback = subject[event],\n                callback = function () {\n                    // make listener methods (moduleStart,testStart,log, ...) overridable.\n                    observer[event].apply(observer, slice.apply(arguments));\n                };\n            originalLoggingCallback(callback);\n            return callback;\n        };\n    };\n\n\n    /**\n     * QUnit-TAP - A TAP Output Producer Plugin for QUnit\n     * @param qunitObject QUnit object reference.\n     * @param printLikeFunction print-like function for TAP output (assumes line-separator is added by this function for each call).\n     * @param options configuration options to customize default behavior.\n     * @return object to provide QUnit-TAP API and customization subject.\n     */\n    function qunitTap(qunitObject, printLikeFunction, options) {\n        if (!qunitObject) {\n            throw new Error('should pass QUnit object reference. Please check QUnit\\'s \"require\" path if you are using Node.js (or any CommonJS env).');\n        } else if (typeof printLikeFunction !== 'function') {\n            throw new Error('should pass print-like function');\n        }\n\n        var qu = qunitObject,\n            tap = {},\n            jsDumpExists = (typeof qu.jsDump !== 'undefined' && typeof qu.jsDump.parse === 'function'),\n            explain = (jsDumpExists ? function explain (obj) { return qu.jsDump.parse(obj); } : noop),\n            deprecateOption = function deprecateOption (optionName, fallback) {\n                // option deprecation and fallback function\n                if (!options || typeof options !== 'object') {\n                    return;\n                }\n                if (typeof options[optionName] === 'undefined') {\n                    return;\n                }\n                printLikeFunction('# WARNING: Option \"' + optionName + '\" is deprecated and will be removed in future version.');\n                fallback(options[optionName]);\n            },\n            targetEvents = [\n                'moduleStart',\n                'testStart',\n                'log',\n                'testDone',\n                'done'\n            ],\n            registeredCallbacks = {};\n\n\n        tap.config = extend(\n            {\n                initialCount: 1,\n                showModuleNameOnFailure: true,\n                showTestNameOnFailure: true,\n                showExpectationOnFailure: true,\n                showSourceOnFailure: true\n            },\n            options\n        );\n        deprecateOption('noPlan', function (flag) {\n            printLikeFunction('# Now QUnit-TAP works as with \"noPlan: true\" by default. If you want to delare plan explicitly, please use \"QUnit.config.requireExpects\" option instead.');\n            tap.config.noPlan = flag;\n        });\n        deprecateOption('count', function (count) {\n            tap.config.initialCount = (count + 1);\n        });\n        deprecateOption('showDetailsOnFailure', function (flag) {\n            tap.config.showModuleNameOnFailure = flag;\n            tap.config.showTestNameOnFailure = flag;\n            tap.config.showExpectationOnFailure = flag;\n            tap.config.showSourceOnFailure = flag;\n        });\n        tap.VERSION = qunitTapVersion;\n        tap.puts = printLikeFunction;\n        tap.count = tap.config.initialCount - 1;\n        tap.expectedCount = tap.config.initialCount - 1;\n\n        function isEnabled (configName) {\n            return tap.config[configName];\n        }\n\n        function formatDetails (details) {\n            if (isPassed(details)) {\n                return details.message;\n            }\n            var desc = [];\n            if (details.message) {\n                desc.push(details.message);\n            }\n            if (isEnabled('showExpectationOnFailure') && !(isAssertOkFailed(details))) {\n                render(desc, 'expected', details.expected, explain);\n                render(desc, 'got', details.actual, explain);\n            }\n            renderIf(isEnabled('showTestNameOnFailure'), desc, 'test', details.name, noop);\n            renderIf(isEnabled('showModuleNameOnFailure'), desc, 'module', details.module, noop);\n            renderIf(isEnabled('showSourceOnFailure'), desc, 'source', details.source, ltrim);\n            return desc.join(', ');\n        }\n\n        function printPlanLine (toCount) {\n            tap.puts(tap.config.initialCount + '..' + toCount);\n        }\n\n        function unsubscribeEvent (eventName) {\n            var listeners;\n            if (indexOf(targetEvents, eventName) === -1) {\n                return;\n            }\n            listeners = qu.config[eventName];\n            if (typeof listeners === 'undefined') {\n                return;\n            }\n            removeElement(listeners, registeredCallbacks[eventName]);\n        }\n\n        function unsubscribeEvents (eventNames) {\n            var i;\n            for (i = 0; i < eventNames.length; i += 1) {\n                unsubscribeEvent(eventNames[i]);\n            }\n        }\n\n        tap.explain = explain;\n\n        tap.note = function note (obj) {\n            tap.puts(escapeLineEndings('# ' + obj));\n        };\n\n        tap.diag = function diag (obj) {\n            tap.note(obj);\n            return false;\n        };\n\n        tap.moduleStart = function moduleStart (arg) {\n            var name = (typeof arg === 'string') ? arg : arg.name;\n            tap.note('module: ' + name);\n        };\n\n        tap.testStart = function testStart (arg) {\n            var name = (typeof arg === 'string') ? arg : arg.name;\n            tap.note('test: ' + name);\n        };\n\n        tap.log = function log (details) {\n            var testLine = '';\n            tap.count += 1;\n            if (isFailed(details)) {\n                testLine += 'not ';\n            }\n            testLine += ('ok ' + tap.count);\n            tap.puts(formatTestLine(testLine, formatDetails(details)));\n        };\n\n        tap.testDone = function testDone () {\n            if (isPlanRequired(qu.config)) {\n                tap.expectedCount += qu.config.current.expected;\n            }\n        };\n\n        tap.done = function done () {\n            if (typeof tap.config.noPlan !== 'undefined' && !(tap.config.noPlan)) {\n                // Do nothing until removal of 'noPlan' option.\n            } else if (isPlanRequired(qu.config)) {\n                printPlanLine(tap.expectedCount);\n            } else {\n                printPlanLine(tap.count);\n            }\n        };\n\n        tap.unsubscribe = function unsubscribe () {\n            if (typeof qu.config === 'undefined') {\n                return;\n            }\n            if (arguments.length === 0) {\n                unsubscribeEvents(targetEvents);\n            } else {\n                unsubscribeEvents(slice.apply(arguments));\n            }\n        };\n\n        (function () {\n            var appendCallback = createCallbackAppenderFor(qu),\n                eventName, i, callback;\n            for (i = 0; i < targetEvents.length; i += 1) {\n                eventName = targetEvents[i];\n                callback = appendCallback(qu, tap, eventName);\n                registeredCallbacks[eventName] = callback;\n            }\n        })();\n\n        return tap;\n    }\n\n    qunitTap.qunitTap = function () {\n        throw new Error('[BC BREAK] Since 1.4.0, QUnit-TAP exports single qunitTap function as module.exports. Therefore, require(\"qunit-tap\") returns qunitTap function itself. Please fix your code if you are using Node.js (or any CommonJS env).');\n    };\n\n    // using substack pattern (export single function)\n    return qunitTap;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../bower_components/qunit-tap/lib/qunit-tap.js\n// module id = 23\n// module chunks = 1","'use strict';\n\n/* global QUnit, qunitTap */\n\nvar qunit_started = false;\n\n/* Always use explicit start */\nQUnit.config.autostart = false;\n\n/*\n * HACK: phantomjs doesn't handle uncaught exceptions as it should if\n * window.onerror is non-null, even when that handler returns false\n * (expecting that the browser default behavior will occur).\n *\n * So remove the qunit window.onerror handler until the tests actually\n * start, and any errors become part of the test suite results.\n */\nvar qunit_onerror = window.onerror;\nwindow.onerror = null;\nQUnit.begin(function() {\n    window.onerror = function(error, file, line) {\n        var ret = false;\n        if (qunit_onerror)\n            ret = qunit_onerror(error, file, line);\n\n        /*\n         * If a global exception happens during an async test\n         * then that test won't be able to call the start() function\n         * to move to the next test, so call it here.\n         */\n        if (QUnit.config.current && QUnit.config.current.async)\n            QUnit.start();\n\n        return ret;\n    };\n});\n\nQUnit.moduleStart(function() {\n    qunit_started = true;\n});\n\nQUnit.done(function() {\n    console.log(\"phantom-tap-done\");\n    window.onerror = null;\n});\n/*\n * Now initialize qunit-tap\n *\n * When not running under tap-phantom this stuff will just show up in\n * the console. We print out a special canary at the end of the tests\n * so that tap-phantom can know when the testing is done.\n *\n * In addition double check for a test file that doesn't properly call\n * QUnit.start() after its done setting up its tests.\n *\n * We also want to insert the current test name into all tap lines.\n */\nvar tap_regex = /^((not )?ok [0-9]+ (- )?)(.*)$/;\nqunitTap(QUnit, function() {\n    if (arguments.length == 1 && QUnit.config.current) {\n        var match = tap_regex.exec(arguments[0]);\n        if (match) {\n            console.log(match[1] + QUnit.config.current.testName + \": \" + match[4]);\n            return;\n        }\n    }\n    console.log.apply(console, arguments);\n});\n\nwindow.setTimeout(function() {\n    if (!qunit_started) {\n        console.log(\"QUnit not started by test\");\n        console.log(\"phantom-tap-error\");\n    }\n}, 20000);\n\nwindow.tests_included = true;\n\nif (module && module.exports)\n    module.exports = QUnit;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../pkg/lib/qunit-config.js\n// module id = 24\n// module chunks = 1","module.exports = function(module) {\n\tif(!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tmodule.children = [];\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/webpack/buildin/module.js\n// module id = 25\n// module chunks = 1"],"sourceRoot":""}