{"version":3,"sources":["webpack:///systemd/logs.min.js","webpack:///webpack/bootstrap 3dcd348b61d1e1c851e0","webpack:///../pkg/systemd/logs.js","webpack:///external \"jQuery\"","webpack:///external \"cockpit\"","webpack:///../pkg/lib/journal.js","webpack:///../pkg/lib/mustache.js","webpack:///../~/mustache/mustache.js","webpack:///../pkg/lib/journal_day_header.mustache","webpack:///../pkg/lib/journal_line.mustache","webpack:///../pkg/lib/journal_reboot.mustache"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","$","update_problems","problem_paths","i","problems","displayable_problems","ID","count","Count","problem_path","path","UUID","Duphash","journalbox","outer","start","match","day_box","query_error","error","console","warn","cockpit","message","prepend_entries","entries","length","renderer","prepend","prepend_flush","renderitems_day_cache","append_entries","append","append_flush","didnt_reach_start","first","button","_","start_box","html","click","stopped","text","procs","push","journal","journalctl","follow","reverse","cursor","fail","stream","shift","query_more","this","stop","done","empty","update_day_box","d","box","firstChild","nextSibling","hasClass","offset","top","currentIndex","window","scrollY","query_count","on","options","all","last","boot","since","off","each","proc","stop_query","filler","update_query","item","query_prio","location","prio_level","parseInt","all_prios","document","getElementById","childNodes","j","nodeName","getAttribute","toString","query_start","scrollTop","height","update_entry","show_entry","entry","Date","is_problem","find_problems","create_problem","out","create_entry","show_error","printable","keys","Object","sort","key","css","switch_tab","new_tab","new_content","find","removeClass","addClass","replaceWith","problem","all_p","ge_t","pi_t","pd_t","ge","pi","pd","tab","d_btn","r_btn","IsReported","pid","Reports","url","attr","CanBeReported","children","spawn","superuser","reload","ex","exit_status","insertAfter","service","DeleteProblems","go","indexOf","body","create_problem_details","GetProblemData","args","elem","val","c1","problem_info_1","String","c2","problem_info_2","problem_details_elems","problem_render_callbacks","render_table_eq","orig","render_table","render_table_co","delimiter","result","lines","split","line","render_multiline","rendered","replace","render_multitable","RegExp","render_dso_list","render_open_fds","join","render_cgroup","render_mountinfo","render_maps","render_limits","render_backtrace","content","content_json","JSON","parse","crash_thread","other_threads","other_items","threads","thread_key","thread","hasOwnProperty","create_detail_from_parsed_core_backtrace","detail_content","create_table_from_thread","thread_num","all_keys","get_all_keys_from_frames","table","frame_num","frame_key","frame","key_key","title","row_content","desired_ordered_of_keys","all_ordered_keys","in_key","key_index","update","hide","show","translate","gettext","problems_client","dbus","proxy","proxies","core_backtrace","os_info","environ","limits","cgroup","namespaces","maps","dso_list","mountinfo","proc_pid_status","open_fds","var_log_messages","not-reportable","exploitable","suspend_stats","dmesg","container_rootfs","docker_inspect","r","Deferred","wait","GetProblems","resolve","err","extend","prio","jQuery","output_funcs_for_box","render_line","ident","time","parts","Mustache","render","line_template","render_reboot_separator","reboot_line","render_day_header","day","day_header_template","parse_html","string","div","createElement","innerHTML","trim","jquery","reboot_template","reboot","elt","appendChild","insertBefore","remove_last","lastChild","removeChild","remove_first","C_","fire_streamers","ents","streamers","apply","promise","clearInterval","interval","arg","matches","arguments","Array","undefined","cmd","directory","until","after","dfd","defer","buffer","host","batch","latency","data","forEach","e","setInterval","reject","always","callback","close","value","format","month_names","funcs_or_box","copy_object","o","format_entry","journal_entry","pad","n","str","toFixed","full","getMonth","getDate","getFullYear","getHours","getMinutes","bootid","entry_is_equal","a","b","render_state_line","state","output_funcs","last_time","start_new_line","top_state","bottom_state","top_output","header_present","line_present","first_time","bottom_output","logbox","max_entries","removeAttribute","setAttribute","tail","concat","slice","createTextNode","template","cache","mustache","view","partials","to_html","send","clearCache","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","testRegExp","re","RegExp_test","isWhitespace","nonSpaceRe","isFunction","object","escapeRegExp","escapeHtml","s","entityMap","escapeTags","tags","isArray","Error","parseTemplate","stripSpace","hasTag","nonSpace","spaces","tokens","pop","spaceRe","type","chr","token","openSection","tagRes","scanner","Scanner","sections","eos","pos","scanUntil","len","charAt","scan","tagRe","whiteRe","equalsRe","curlyRe","nestTokens","squashTokens","lastToken","squashedTokens","section","nestedTokens","collector","Context","parentContext",".","parent","Writer","prototype","test","Object_toString","&","<",">","\"","'","/","index","substring","search","lookup","name","context","names","renderTokens","originalTemplate","subRender","self","jlen","escape","version","defaultWriter"],"mappings":"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","file":"systemd/logs.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\n\t * This file is part of Cockpit.\n\t *\n\t * Copyright (C) 2015 Red Hat, Inc.\n\t *\n\t * Cockpit is free software; you can redistribute it and/or modify it\n\t * under the terms of the GNU Lesser General Public License as published by\n\t * the Free Software Foundation; either version 2.1 of the License, or\n\t * (at your option) any later version.\n\t *\n\t * Cockpit is distributed in the hope that it will be useful, but\n\t * WITHOUT ANY WARRANTY; without even the implied warranty of\n\t * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n\t * Lesser General Public License for more details.\n\t *\n\t * You should have received a copy of the GNU Lesser General Public License\n\t * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n\t */\n\t\n\tvar $ = __webpack_require__(2);\n\t$(function() {\n\t    \"use strict\";\n\t\n\t    var cockpit = __webpack_require__(3);\n\t\n\t    var journal = __webpack_require__(4);\n\t\n\t    cockpit.translate();\n\t    var _ = cockpit.gettext;\n\t\n\t    var problems_client = cockpit.dbus('org.freedesktop.problems', { superuser: \"try\" });\n\t    var service = problems_client.proxy('org.freedesktop.Problems2', '/org/freedesktop/Problems2');\n\t    var problems = problems_client.proxies('org.freedesktop.Problems2.Entry', '/org/freedesktop/Problems2/Entry');\n\t\n\t    // A map of ABRT's problems items and it's callback for rendering\n\t    var problem_render_callbacks = {'core_backtrace': render_backtrace,\n\t                                    'os_info': render_table_eq,\n\t                                    'environ': render_table_eq,\n\t                                    'limits': render_limits,\n\t                                    'cgroup': render_cgroup,\n\t                                    'namespaces': render_table_co,\n\t                                    'maps': render_maps,\n\t                                    'dso_list': render_dso_list,\n\t                                    'mountinfo': render_mountinfo,\n\t                                    'proc_pid_status': render_table_co,\n\t                                    'open_fds': render_open_fds,\n\t                                    'var_log_messages': render_multiline,\n\t                                    'not-reportable': render_multiline,\n\t                                    'exploitable': render_multiline,\n\t                                    'suspend_stats': render_table_co,\n\t                                    'dmesg': render_multiline,\n\t                                    'container_rootfs': render_multiline,\n\t                                    'docker_inspect': render_multiline\n\t                                    };\n\t\n\t    var problem_info_1 = ['reason', 'cmdline', 'executable', 'package', 'component',\n\t                          'crash_function', 'pid', 'pwd', 'hostname', 'count',\n\t                          'type', 'analyzer', 'rootdir', 'duphash', 'exception_type',\n\t                          'container', 'container_uuid', 'container_cmdline',\n\t                          'container_id', 'container_image' ];\n\t\n\t    var problem_info_2 = ['Directory', 'username', 'abrt_version', 'architecture', 'global_pid', 'kernel',\n\t                          'last_occurrence', 'os_release', 'pkg_fingerprint', 'pkg_vendor',\n\t                          'runlevel', 'tid', 'time', 'uid', 'uuid'];\n\t\n\t    var displayable_problems = {};\n\t\n\t    //Get list of all problems that can be displayed\n\t    var find_problems = function () {\n\t        var r = $.Deferred();\n\t        problems.wait(function() {\n\t            try {\n\t                service.GetProblems(0, {})\n\t                    .done(function(problem_paths, options) {\n\t                        update_problems(problem_paths);\n\t                        r.resolve();\n\t                    });\n\t            }\n\t            catch(err) {\n\t                //ABRT is not installed. Suggest installing?\n\t                r.resolve();\n\t            }\n\t        });\n\t        return r;\n\t    };\n\t\n\t    function update_problems(problem_paths) {\n\t        for (var i in problem_paths) {\n\t            var p = problems[problem_paths[i]];\n\t            displayable_problems[p.ID] = {'count': p.Count, 'problem_path': p.path};\n\t            displayable_problems[p.UUID] = {'count': p.Count, 'problem_path': p.path};\n\t            displayable_problems[p.Duphash] = {'count': p.Count, 'problem_path': p.path};\n\t        }\n\t    }\n\t\n\t    /* Not public API */\n\t    function journalbox(outer, start, match, day_box) {\n\t        var box = $('<div class=\"panel panel-default cockpit-log-panel\">');\n\t        var start_box = $('<div class=\"journal-start\">');\n\t\n\t        outer.empty().append(box, start_box);\n\t\n\t        var query_count = 5000;\n\t        var query_more = 1000;\n\t\n\t        var renderer = journal.renderer(box);\n\t        /* cache to store offsets for days */\n\t        var renderitems_day_cache = null;\n\t        var procs = [];\n\t\n\t        function query_error(error) {\n\t            /* TODO: blank slate */\n\t            console.warn(cockpit.message(error));\n\t        }\n\t\n\t        function prepend_entries(entries) {\n\t            for (var i = 0; i < entries.length; i++)\n\t                renderer.prepend(entries[i]);\n\t            renderer.prepend_flush();\n\t            /* empty cache for day offsets */\n\t            renderitems_day_cache = null;\n\t        }\n\t\n\t        function append_entries(entries) {\n\t            for (var i = 0; i < entries.length; i++)\n\t                renderer.append(entries[i]);\n\t            renderer.append_flush();\n\t            /* empty cache for day offsets */\n\t            renderitems_day_cache = null;\n\t        }\n\t\n\t        function didnt_reach_start(first) {\n\t            var button = $('<button id=\"journal-load-earlier\" class=\"btn btn-default\" data-inline=\"true\" data-mini=\"true\">' +\n\t                           _(\"Load earlier entries\") +\n\t                           '</button>');\n\t            start_box.html(button);\n\t            button.click(function() {\n\t                var count = 0;\n\t                var stopped = null;\n\t                start_box.text(_(\"Loading...\"));\n\t                procs.push(journal.journalctl(match, { follow: false, reverse: true, cursor: first }).\n\t                    fail(query_error).\n\t                    stream(function(entries) {\n\t                        if (entries[0][\"__CURSOR\"] == first)\n\t                            entries.shift();\n\t                        count += entries.length;\n\t                        append_entries(entries);\n\t                        if (count >= query_more) {\n\t                            stopped = entries[entries.length - 1][\"__CURSOR\"];\n\t                            didnt_reach_start(stopped);\n\t                            this.stop();\n\t                        }\n\t                    }).\n\t                    done(function() {\n\t                        if (start_box.text() == _(\"Loading...\"))\n\t                            start_box.empty();\n\t                    }));\n\t            });\n\t        }\n\t\n\t        function follow(cursor) {\n\t            procs.push(journal.journalctl(match, { follow: true, count: 0, cursor: cursor }).\n\t                fail(query_error).\n\t                stream(function(entries) {\n\t                    if (entries[0][\"__CURSOR\"] == cursor)\n\t                        entries.shift();\n\t                    prepend_entries(entries);\n\t                    update_day_box();\n\t                }));\n\t        }\n\t\n\t        function update_day_box() {\n\t            /* Build cache if empty\n\t             */\n\t            if (renderitems_day_cache === null) {\n\t                renderitems_day_cache = [];\n\t                for (var d = box[0].firstChild; d; d = d.nextSibling) {\n\t                    if ($(d).hasClass('panel-heading'))\n\t                        renderitems_day_cache.push([$(d).offset().top, $(d).text()]);\n\t                }\n\t            }\n\t            if (renderitems_day_cache.length > 0) {\n\t                /* Find the last day that begins above top\n\t                 */\n\t                var currentIndex = 0;\n\t                var top = window.scrollY;\n\t                while ((currentIndex + 1) < renderitems_day_cache.length &&\n\t                        renderitems_day_cache[currentIndex + 1][0] < top) {\n\t                    currentIndex++;\n\t                }\n\t                day_box.text(renderitems_day_cache[currentIndex][1]);\n\t            } else {\n\t                /* No visible day headers\n\t                 */\n\t                day_box.text(_(\"Go to\"));\n\t            }\n\t        }\n\t\n\t        start_box.text(_(\"Loading...\"));\n\t\n\t        $(window).on('scroll', update_day_box);\n\t\n\t        var options = {\n\t            follow: false,\n\t            reverse: true\n\t        };\n\t\n\t        var all = false;\n\t        if (start == 'boot') {\n\t            options[\"boot\"] = null;\n\t        } else if (start == 'last-24h') {\n\t            options[\"since\"] = \"-1days\";\n\t        } else if (start == 'last-week') {\n\t            options[\"since\"] = \"-7days\";\n\t        } else {\n\t            all = true;\n\t        }\n\t\n\t        var last = null;\n\t        var count = 0;\n\t        var stopped = null;\n\t\n\t        procs.push(journal.journalctl(match, options).\n\t            fail(query_error).\n\t            stream(function(entries) {\n\t                if (!last) {\n\t                    last = entries[0][\"__CURSOR\"];\n\t                    follow(last);\n\t                    update_day_box();\n\t                }\n\t                count += entries.length;\n\t                append_entries(entries);\n\t                if (count >= query_count) {\n\t                    stopped = entries[entries.length - 1][\"__CURSOR\"];\n\t                    didnt_reach_start(stopped);\n\t                    this.stop();\n\t                }\n\t            }).\n\t            done(function() {\n\t                if (start_box.text() == _(\"Loading...\"))\n\t                    start_box.empty();\n\t                if (!last) {\n\t                    procs.push(journal.journalctl(match, { follow: true, count: 0,\n\t                                                           boot: options[\"boot\"],\n\t                                                           since: options[\"since\"]\n\t                                                         }).\n\t                        fail(query_error).\n\t                        stream(function(entries) {\n\t                            prepend_entries(entries);\n\t                            update_day_box();\n\t                        }));\n\t                }\n\t                if (!all || stopped)\n\t                    didnt_reach_start();\n\t            }));\n\t\n\t        outer.stop = function stop() {\n\t            $(window).off('scroll', update_day_box);\n\t            $.each(procs, function(i, proc) {\n\t                proc.stop();\n\t            });\n\t        };\n\t\n\t        return outer;\n\t    }\n\t\n\t    var filler;\n\t\n\t    function stop_query() {\n\t        if (filler)\n\t            filler.stop();\n\t    }\n\t\n\t    function update_query() {\n\t        stop_query();\n\t\n\t        var match = [ ];\n\t\n\t        var query_prio = cockpit.location.options['prio'] || \"3\";\n\t        var prio_level = parseInt(query_prio, 10);\n\t\n\t        // Set selected item into priority dropdown menu\n\t        var all_prios = document.getElementById('prio-lists').childNodes;\n\t        var item;\n\t        for (var j = 0; j < all_prios.length; j++) {\n\t            if (all_prios[j].nodeName === 'LI') {\n\t                item = all_prios[j].childNodes[0];\n\t                if (item.getAttribute('data-prio') === query_prio) {\n\t                    $('#journal-prio').text(item.text);\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t\n\t        if (prio_level) {\n\t            for (var i = 0; i <= prio_level; i++)\n\t                match.push('PRIORITY=' + i.toString());\n\t        }\n\t\n\t        // If item 'Only Problems' was selected, match only ABRT's problems\n\t        if (prio_level === 2) {\n\t            match.push('SYSLOG_IDENTIFIER=abrt-notification');\n\t        }\n\t\n\t        var options = cockpit.location.options;\n\t        if (options['service'])\n\t            match.push('_SYSTEMD_UNIT=' + options['service']);\n\t        else if (options['tag'])\n\t            match.push('SYSLOG_IDENTIFIER=' + options['tag']);\n\t\n\t        var query_start = cockpit.location.options['start'] || \"recent\";\n\t        if (query_start == 'recent')\n\t            $(window).scrollTop($(document).height());\n\t\n\t        journalbox($(\"#journal-box\"), query_start, match, $('#journal-current-day'));\n\t    }\n\t\n\t    function update_entry() {\n\t        var cursor = cockpit.location.path[0];\n\t        var out = $('#journal-entry-fields');\n\t\n\t        out.empty();\n\t\n\t        function show_entry(entry) {\n\t            var d = new Date(entry[\"__REALTIME_TIMESTAMP\"] / 1000);\n\t            $('#journal-entry-date').text(d.toString());\n\t\n\t            var id;\n\t            if (entry[\"SYSLOG_IDENTIFIER\"])\n\t                id = entry[\"SYSLOG_IDENTIFIER\"];\n\t            else if (entry[\"_SYSTEMD_UNIT\"])\n\t                id = entry[\"_SYSTEMD_UNIT\"];\n\t            else\n\t                id = _(\"Journal entry\");\n\t\n\t            var is_problem = false;\n\t            if (id === 'abrt-notification'){\n\t                is_problem = true;\n\t                id = entry['PROBLEM_BINARY'];\n\t            }\n\t\n\t            $('#journal-entry-id').text(id);\n\t\n\t            if (is_problem) {\n\t                find_problems().done(function() {\n\t                    create_problem(out, entry);\n\t                });\n\t            } else {\n\t                create_entry(out, entry);\n\t            }\n\t        }\n\t\n\t        function show_error(error) {\n\t            out.append(\n\t                $('<tr>').append(\n\t                    $('<td>').\n\t                        text(error)));\n\t        }\n\t\n\t        journal.journalctl({ cursor: cursor, count: 1, follow: false }).\n\t            done(function (entries) {\n\t                if (entries.length >= 1 && entries[0][\"__CURSOR\"] == cursor)\n\t                    show_entry(entries[0]);\n\t                else\n\t                    show_error(_(\"Journal entry not found\"));\n\t            }).\n\t            fail(function (error) {\n\t                show_error(error);\n\t            });\n\t    }\n\t\n\t    function create_entry(out, entry){\n\t        $('#journal-entry-message').text(journal.printable(entry['MESSAGE']));\n\t        var keys = Object.keys(entry).sort();\n\t        $.each(keys, function (i, key) {\n\t            if (key !== 'MESSAGE') {\n\t                out.append(\n\t                    $('<tr>').append(\n\t                        $('<td>').css('text-align', 'right').text(key),\n\t                        $('<td>').css('text-align', 'left')\n\t                            .text(journal.printable(entry[key]))));\n\t            }\n\t        });\n\t    }\n\t\n\t    function create_problem(out, entry) {\n\t        var problem = null;\n\t        var all_p = [entry['PROBLEM_DIR'], entry['PROBLEM_DUPHASH'], entry['PROBLEM_UUID']];\n\t        for (var i = 0; i < all_p.length; i++) {\n\t            if (all_p[i] in displayable_problems) {\n\t                problem = problems[displayable_problems[all_p[i]]['problem_path']];\n\t                break;\n\t            }\n\t        }\n\t\n\t        //Display unknown problems as standard logs\n\t        //unknown problem = deleted problem | problem of different user\n\t        if (problem === null){\n\t            create_entry(out, entry);\n\t            return;\n\t        }\n\t\n\t        function switch_tab(new_tab, new_content) {\n\t            out.find('li').removeClass('active');\n\t            new_tab.addClass('active');\n\t            out.find('div').first().replaceWith(new_content);\n\t        }\n\t\n\t        $('#journal-entry-message').text('');\n\t\n\t        var ge_t = $('<li class=\"active\">').append($('<a>').append($('<span translatable=\"yes\">').text('General')));\n\t        var pi_t = $('<li>').append($('<a>').append($('<span translatable=\"yes\">').text('Problem info')));\n\t        var pd_t = $('<li>').append($('<a>').append($('<span translatable=\"yes\">').text('Problem details')));\n\t\n\t        var ge = $('<div>');\n\t        var pi = $('<div>');\n\t        var pd = $('<div class=\"panel-group\" id=\"accordion-markup\">');\n\t        var tab = $('<ul class=\"nav nav-tabs nav-tabs-pf\">');\n\t\n\t        var d_btn =  $('<button class=\"btn btn-danger problem-btn btn-delete pficon pficon-delete\">');\n\t\n\t        var r_btn = $();\n\t        if (problem.IsReported){\n\t            for (var pid = 0; pid < problem.Reports.length; pid++) {\n\t                if (problem.Reports[pid][0] === 'ABRT Server') {\n\t                    var url = problem.Reports[pid][1]['URL']['v']['v'];\n\t                    r_btn = $('<a class=\"problem-btn\">')\n\t                            .attr('href', url)\n\t                            .attr(\"target\", \"_blank\")\n\t                            .text('Reported');\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t\n\t        else if (problem.CanBeReported){\n\t            r_btn = $('<button class=\"btn btn-primary problem-btn\">').text('Report');\n\t\n\t            r_btn.click(function() {\n\t                tab.children(':last-child').replaceWith($('<div class=\"spinner problem-btn\">'));\n\t                var proc = cockpit.spawn(['reporter-ureport', '-d', problem.ID], { superuser: 'true' });\n\t                proc.done(function() {\n\t                    window.location.reload();\n\t                });\n\t                proc.fail(function(ex) {\n\t                    var message;\n\t                    // 70 is 'This problem has already been reported'\n\t                    if (ex.exit_status === 70) {\n\t                        window.location.reload();\n\t                        return;\n\t                    } else if (ex.problem === 'access-denied') {\n\t                        message = _(\"Not authorized to upload-report\");\n\t                    } else if (ex.problem === \"not-found\") {\n\t                        message = _(\"Reporter 'reporter-ureport' not found.\");\n\t                    } else {\n\t                        message = _(\"Reporting was unsucessful. Try running `reporter-ureport -d \"+ problem.ID +\"`\");\n\t                    }\n\t                    $('<div class=\"alert alert-danger\">')\n\t                        .append('<span class=\"pficon pficon-error-circle-o\">')\n\t                        .text(message).insertAfter(\".breadcrumb\");\n\t                    tab.children(':last-child').replaceWith($('<span>'));\n\t                });\n\t            });\n\t        }\n\t\n\t        ge_t.click(function() {\n\t            switch_tab(ge_t, ge);\n\t        });\n\t\n\t        pi_t.click(function() {\n\t            switch_tab(pi_t, pi);\n\t        });\n\t\n\t        pd_t.click(function() {\n\t            switch_tab(pd_t, pd);\n\t        });\n\t\n\t        d_btn.click(function() {\n\t            service.DeleteProblems([problem.path]);\n\t            displayable_problems = { };\n\t            find_problems().done(function() {\n\t                cockpit.location.go('/');\n\t            });\n\t        });\n\t\n\t        // write into general tab non-ABRT related items\n\t        var keys = Object.keys(entry).sort();\n\t        $.each(keys, function(i, key) {\n\t            if (key !== 'MESSAGE' && key.indexOf('PROBLEM_') !== 0) {\n\t                ge.append(\n\t                    $('<tr>').append(\n\t                        $('<td>').css('text-align', 'right').text(key),\n\t                        $('<td>').css('text-align', 'left').\n\t                            text(journal.printable(entry[key]))));\n\t            }\n\t        });\n\t\n\t        tab.html(ge_t);\n\t        tab.append(pi_t);\n\t        tab.append(pd_t);\n\t        tab.append(d_btn);\n\t        tab.append(r_btn);\n\t\n\t        var body = $('<th>');\n\t        body.append(tab);\n\t        body.append(ge);\n\t\n\t        out.html($('<tr>').append(body));\n\t        out.css(\"margin-bottom\", \"0px\");\n\t\n\t        create_problem_details(problem, pi, pd);\n\t    }\n\t\n\t    function create_problem_details(problem, pi, pd) {\n\t        service.GetProblemData(problem.path).done(function(args, options) {\n\t            var i, elem, val;\n\t            // Render first column of problem info\n\t            var c1 = $('<table>').css('display', 'inline-block')\n\t                               .css('padding-right', '200px')\n\t                               .css('vertical-align', 'top');\n\t            pi.append(c1);\n\t            for (i = 0; i < problem_info_1.length; i++) {\n\t                elem = problem_info_1[i];\n\t                if (elem in args){\n\t                    val = args[elem][2];\n\t                    c1.append(\n\t                        $('<tr>').append(\n\t                            $('<td>').css('text-align', 'right').text(elem),\n\t                            $('<td>').css('text-align', 'left')\n\t                                .text(String(val))));\n\t                }\n\t            }\n\t\n\t            // Render second column of problem info\n\t            var c2 = $('<table>').css('display', 'inline-block')\n\t                               .css('vertical-align', 'top');\n\t            pi.append(c2);\n\t            for (i = 0; i < problem_info_2.length; i++) {\n\t                elem = problem_info_2[i];\n\t                if (elem in args){\n\t                    val = args[elem][2];\n\t                    // Display date properly\n\t                    if (['last_occurrence', 'time'].indexOf(elem) !== -1){\n\t                        var d = new Date(val / 1000);\n\t                        val = d.toString();\n\t                    }\n\t                    c2.append(\n\t                        $('<tr>').append(\n\t                            $('<td>').css('text-align', 'right').text(elem),\n\t                            $('<td>').css('text-align', 'left')\n\t                                .text(String(val))));\n\t                }\n\t            }\n\t\n\t            // Render problem details\n\t            var problem_details_elems = Object.keys(problem_render_callbacks);\n\t            $.each(problem_details_elems, function(i, key) {\n\t                if (key in args){\n\t                    val = problem_render_callbacks[key](args[key]);\n\t                    pd.append(\n\t                        $('<div class=\"panel panel-default\">')\n\t                            .css(\"border-width\", \"0px 0px 2px 0px\")\n\t                            .append(\n\t                          $('<div class=\"panel-heading problem-panel\">')\n\t                            .attr('data-toggle', 'collapse')\n\t                            .attr('data-target', '#' + key)\n\t                            .attr('data-parent', '#accordion-markup')\n\t                            .append($('<h4 class=\"panel-title\">')\n\t                              .append($('<a class=\"accordion-toggle\">')\n\t                                .text(key))),\n\t                          $('<div class=\"panel-collapse collapse\">')\n\t                            .attr('id', key)\n\t                            .append(\n\t                              $('<div class=\"panel-body\">')\n\t                                    .html(val))));\n\t                }\n\t            });\n\t        });\n\t    }\n\t\n\t    function render_table_eq(orig) {\n\t        return render_table(orig, '=');\n\t    }\n\t\n\t    function render_table_co(orig) {\n\t        return render_table(orig, ':');\n\t    }\n\t\n\t    function render_table(orig, delimiter) {\n\t        var lines = orig[2].split('\\n');\n\t        var result;\n\t\n\t        for (var i = 0; i < lines.length - 1; i++) {\n\t            var line = lines[i].split(delimiter);\n\t            result += '<tr> <td class=\"text-right\">' + line[0];\n\t            result += '<td class=\"text-left\">' + line[1];\n\t            result += '</tr>';\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    function render_multiline(orig) {\n\t        var rendered = orig[2].replace(/\\n/g, '<br>');\n\t        return rendered;\n\t    }\n\t\n\t    function render_multitable(orig, delimiter) {\n\t        var rendered = orig.replace(RegExp(delimiter, 'g'), '</td><td>');\n\t        rendered = rendered.replace(/\\n/g, '</td></tr><tr><td>');\n\t        return '<tr><td>' + rendered + '</td></tr>';\n\t    }\n\t\n\t    function render_dso_list(orig) {\n\t        var rendered = orig[2].replace(/^(\\S+\\s+)(\\S+)(.*)$/gm, '$1<b>$2</b>$3');\n\t        return render_multitable(rendered, ' ');\n\t    }\n\t\n\t    function render_open_fds(orig) {\n\t        var lines = orig[2].split('\\n');\n\t        for (var i = 0; i < lines.length - 1; i++) {\n\t            if (i % 5 !== 0) {\n\t                lines[i] = ':' + lines[i];\n\t            }\n\t        }\n\t        return render_multitable(lines.join('\\n'), ':');\n\t    }\n\t\n\t    function render_cgroup(orig) {\n\t        return render_multitable(orig[2], ':');\n\t    }\n\t\n\t    function render_mountinfo(orig) {\n\t        return render_multitable(orig[2].replace(/  +/g, ':'), ' ');\n\t    }\n\t\n\t    function render_maps(orig) {\n\t        return render_multitable(orig[2].replace(/  +/g, ':'), ' ');\n\t    }\n\t\n\t    function render_limits(orig) {\n\t        var lines = orig[2].split('\\n');\n\t        lines[0] ='\":' + lines[0].replace(/(\\S+) (\\S+) /g, '$1:$2 ');\n\t        for (var i = 1; i < lines.length - 1; i++) {\n\t                lines[i] = lines[i].replace(/  +/g, ':');\n\t        }\n\t\n\t        return render_multitable(lines.join('\\n'), ':');\n\t    }\n\t\n\t    function render_backtrace(content) {\n\t        var content_json = JSON.parse(content[2]);\n\t\n\t        var crash_thread = null;\n\t        var other_threads = [];\n\t        var other_items = {};\n\t\n\t        for (var item in content_json) {\n\t\n\t            if (item === 'stacktrace') {\n\t\n\t                var threads = content_json[item];\n\t                for (var thread_key in threads) {\n\t\n\t                    var thread = threads[thread_key];\n\t\n\t                    if (thread.hasOwnProperty(\"crash_thread\") && thread['crash_thread']) {\n\t                        if (thread.hasOwnProperty('frames')) {\n\t                            crash_thread = thread['frames'];\n\t                        }\n\t                    }\n\t                    else {\n\t                        if (thread.hasOwnProperty('frames')) {\n\t                            other_threads.push(thread['frames']);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            else {\n\t                other_items[item] = content_json[item];\n\t            }\n\t        }\n\t        return create_detail_from_parsed_core_backtrace(crash_thread, other_threads, other_items);\n\t    }\n\t\n\t    function create_detail_from_parsed_core_backtrace(crash_thread, other_threads, other_items) {\n\t\n\t        var detail_content = '';\n\t        for (var item in other_items) {\n\t            detail_content += item;\n\t            detail_content += ': ' + other_items[item] + \"  \";\n\t        }\n\t\n\t        detail_content += create_table_from_thread(crash_thread);\n\t\n\t        if (other_threads.length !== 0) {\n\t            detail_content += '<div id=\"other_threads_btn_div\"><button class=\"btn btn-default other-threads-btn\" title=\"\">Show all threads</button></div>';\n\t            detail_content += '<div class=\"hidden other_threads\">';\n\t\n\t            var thread_num = 1;\n\t            for (var thread_key in other_threads) {\n\t                detail_content += '\\n';\n\t                detail_content += 'thread: ' + thread_num++ + '\\n';\n\t                detail_content += create_table_from_thread(other_threads[thread_key]);\n\t            }\n\t            detail_content += '</div>';\n\t        }\n\t\n\t        return detail_content;\n\t    }\n\t\n\t    function create_table_from_thread(thread) {\n\t        var all_keys = get_all_keys_from_frames(thread);\n\t\n\t        /* create table legend */\n\t        var table = '<table class=\"detail_table\"><thead><tr><th>Fr #</th>';\n\t        for (var key in all_keys) {\n\t            table += '<th>';\n\t            table += all_keys[key].replace(/_/g, ' ');\n\t            table += '</th>';\n\t        }\n\t        table += '</tr></thead><tbody>';\n\t\n\t        var frame_num = 1;\n\t        for (var frame_key in thread) {\n\t            table += '<tr>';\n\t            table += '<td>';\n\t            table += frame_num++;\n\t            table += '</td>';\n\t\n\t            var frame = thread[frame_key];\n\t            for (var key_key in all_keys) {\n\t                key = all_keys[key_key];\n\t\n\t                var title = '';\n\t                var row_content = '';\n\t                if (key in frame) {\n\t                    row_content = frame[key].toString();\n\t                    if (row_content.length > 8)\n\t                        title = row_content;\n\t                }\n\t                else\n\t                    row_content = '';\n\t\n\t                table += '<td title=\"' + title + '\">';\n\t                table += row_content;\n\t                table += '</td>';\n\t            }\n\t            table += '</tr>';\n\t        }\n\t\n\t        table += '</tbody></table>';\n\t        return table;\n\t    }\n\t\n\t    function get_all_keys_from_frames(thread) {\n\t        var all_keys = [];\n\t\n\t        for (var frame_key in thread) {\n\t            var frame = thread[frame_key];\n\t            var keys = Object.keys(frame);\n\t\n\t            for (var key in keys) {\n\t                if (all_keys.indexOf(keys[key]) === -1)\n\t                    all_keys.push(keys[key]);\n\t            }\n\t        }\n\t\n\t        /* order keys */\n\t        var desired_ordered_of_keys = ['function_name', 'file_name', 'address', 'build_id', 'build_id_offset'];\n\t\n\t        var all_ordered_keys = [];\n\t\n\t        for (var key_key in desired_ordered_of_keys) {\n\t            var in_key = desired_ordered_of_keys[key_key];\n\t            var key_index = all_keys.indexOf(in_key);\n\t            if (key_index !== -1) {\n\t                all_ordered_keys.push(in_key);\n\t                delete all_keys[key_index];\n\t            }\n\t        }\n\t\n\t        for(key_key in all_keys) {\n\t            all_ordered_keys.push(all_keys[key_key]);\n\t        }\n\t\n\t        return all_ordered_keys;\n\t    }\n\t\n\t    function update() {\n\t        var path = cockpit.location.path;\n\t        if (path.length === 0) {\n\t            $(\"#journal-entry\").hide();\n\t            update_query();\n\t            $(\"#journal\").show();\n\t        } else if (path.length == 1) {\n\t            stop_query();\n\t            $(\"#journal\").hide();\n\t            update_entry();\n\t            $(\"#journal-entry\").show();\n\t        } else { /* redirect */\n\t            console.warn(\"not a journal location: \" + path);\n\t            cockpit.location = '';\n\t        }\n\t        $(\"body\").show();\n\t    }\n\t\n\t    $(cockpit).on(\"locationchanged\", update);\n\t\n\t    $('#journal-current-day-menu a').on('click', function() {\n\t        cockpit.location.go([], $.extend(cockpit.location.options, { start: $(this).attr(\"data-op\") }));\n\t    });\n\t\n\t    $('#journal-box').on('click', '.cockpit-logline', function() {\n\t         var cursor = $(this).attr('data-cursor');\n\t         if (cursor)\n\t            cockpit.location.go([ cursor ]);\n\t    });\n\t\n\t    $('#journal-prio-menu a').on('click', function() {\n\t        cockpit.location.go([], $.extend(cockpit.location.options, { prio: $(this).attr('data-prio') }));\n\t    });\n\t\n\t    $('#journal-navigate-home').on(\"click\", function() {\n\t        cockpit.location.go('/');\n\t    });\n\t\n\t    update();\n\t});\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = jQuery;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = cockpit;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\n\t * This file is part of Cockpit.\n\t *\n\t * Copyright (C) 2015 Red Hat, Inc.\n\t *\n\t * Cockpit is free software; you can redistribute it and/or modify it\n\t * under the terms of the GNU Lesser General Public License as published by\n\t * the Free Software Foundation; either version 2.1 of the License, or\n\t * (at your option) any later version.\n\t *\n\t * Cockpit is distributed in the hope that it will be useful, but\n\t * WITHOUT ANY WARRANTY; without even the implied warranty of\n\t * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n\t * Lesser General Public License for more details.\n\t *\n\t * You should have received a copy of the GNU Lesser General Public License\n\t * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n\t */\n\t\n\t(function() {\n\t    \"use strict\";\n\t\n\t    var cockpit = __webpack_require__(3);\n\t    var Mustache = __webpack_require__(5);\n\t    var day_header_template = __webpack_require__(7);\n\t    var line_template = __webpack_require__(8);\n\t    var reboot_template = __webpack_require__(9);\n\t\n\t    var _ = cockpit.gettext;\n\t    var C_ = cockpit.gettext;\n\t\n\t    var journal = { };\n\t\n\t    /**\n\t     * journalctl([match, ...], [options])\n\t     * @match: any number of journal match strings\n\t     * @options: an object containing further options\n\t     *\n\t     * Load and (by default) stream journal entries as\n\t     * json objects. This function returns a jQuery deferred\n\t     * object which delivers the various journal entries.\n\t     *\n\t     * The various @match strings are journalctl matches.\n\t     * Zero, one or more can be specified. They must be in\n\t     * string format, or arrays of strings.\n\t     *\n\t     * The optional @options object can contain the following:\n\t     *  * \"host\": the host to load journal from\n\t     *  * \"count\": number of entries to load and/or pre-stream.\n\t     *    Default is 10\n\t     *  * \"follow\": if set to false just load entries and don't\n\t     *    stream further journal data. Default is true.\n\t     *  * \"directory\": optional directory to load journal files\n\t     *  * \"boot\": when set only list entries from this specific\n\t     *    boot id, or if null then the current boot.\n\t     *  * \"since\": if specified list entries since the date/time\n\t     *  * \"until\": if specified list entries until the date/time\n\t     *  * \"cursor\": a cursor to start listing entries from\n\t     *  * \"after\": a cursor to start listing entries after\n\t     *\n\t     * Returns a jQuery deferred promise. You can call these\n\t     * functions on the deferred to handle the responses. Note that\n\t     * there are additional non-jQuery methods.\n\t     *\n\t     *  .done(function(entries) { }): Called when done, @entries is\n\t     *         an array of all journal entries loaded. If .stream()\n\t     *         has been invoked then @entries will be empty.\n\t     *  .fail(funciton(ex) { }): called if the operation fails\n\t     *  .stream(function(entries) { }): called when we receive entries\n\t     *         entries. Called once per batch of journal @entries,\n\t     *         whether following or not.\n\t     *  .stop(): stop following or retrieving entries.\n\t     */\n\t\n\t    journal.journalctl = function journalctl(/* ... */) {\n\t        var matches = [];\n\t        var i, arg, options = { follow: true };\n\t        for (i = 0; i < arguments.length; i++) {\n\t            arg = arguments[i];\n\t            if (typeof arg == \"string\") {\n\t                matches.push(arg);\n\t            } else if (typeof arg == \"object\") {\n\t                if (arg instanceof Array) {\n\t                    matches.push.apply(matches, arg);\n\t                } else {\n\t                    cockpit.extend(options, arg);\n\t                    break;\n\t                }\n\t            } else {\n\t                console.warn(\"journal.journalctl called with invalid argument:\", arg);\n\t            }\n\t        }\n\t\n\t        if (options.count === undefined) {\n\t            if (options.follow)\n\t                options.count = 10;\n\t            else\n\t                options.count = null;\n\t        }\n\t\n\t        var cmd = [ \"journalctl\", \"-q\", \"--output=json\" ];\n\t        if (!options.count)\n\t            cmd.push(\"--no-tail\");\n\t        else\n\t            cmd.push(\"--lines=\" + options.count);\n\t        if (options.directory)\n\t            cmd.push(\"--directory=\" + options.directory);\n\t        if (options.boot)\n\t            cmd.push(\"--boot=\" + options.boot);\n\t        else if (options.boot !== undefined)\n\t            cmd.push(\"--boot\");\n\t        if (options.since)\n\t            cmd.push(\"--since=\" + options.since);\n\t        if (options.until)\n\t            cmd.push(\"--until=\" + options.until);\n\t        if (options.cursor)\n\t            cmd.push(\"--cursor=\" + options.cursor);\n\t        if (options.after)\n\t            cmd.push(\"--after=\" + options.after);\n\t\n\t        /* journalctl doesn't allow reverse and follow together */\n\t        if (options.reverse)\n\t            cmd.push(\"--reverse\");\n\t        else if (options.follow)\n\t            cmd.push(\"--follow\");\n\t\n\t        cmd.push(\"--\");\n\t        cmd.push.apply(cmd, matches);\n\t\n\t        var dfd = new cockpit.defer();\n\t        var promise;\n\t        var buffer = \"\";\n\t        var entries = [];\n\t        var streamers = [];\n\t        var interval = null;\n\t\n\t        function fire_streamers() {\n\t            var ents, i;\n\t            if (streamers.length && entries.length > 0) {\n\t                ents = entries;\n\t                entries = [];\n\t                for (i = 0; i < streamers.length; i++)\n\t                    streamers[i].apply(promise, [ents]);\n\t            } else {\n\t                window.clearInterval(interval);\n\t                interval = null;\n\t            }\n\t        }\n\t\n\t        var proc = cockpit.spawn(cmd, { host: options.host, batch: 8192, latency: 300, superuser: \"try\" }).\n\t            stream(function(data) {\n\t\n\t                if (buffer)\n\t                    data = buffer + data;\n\t                buffer = \"\";\n\t\n\t                var lines = data.split(\"\\n\");\n\t                var last = lines.length - 1;\n\t                lines.forEach(function(line, i) {\n\t                    if (i == last) {\n\t                        buffer = line;\n\t                    } else if (line && line.indexOf(\"-- \") !== 0) {\n\t                        try {\n\t                            entries.push(JSON.parse(line));\n\t                        } catch (e) {\n\t                            console.warn(e, line);\n\t                        }\n\t                    }\n\t                });\n\t\n\t                if (streamers.length && interval === null)\n\t                    interval = window.setInterval(fire_streamers, 300);\n\t            }).\n\t            done(function() {\n\t                fire_streamers();\n\t                dfd.resolve(entries);\n\t            }).\n\t            fail(function(ex) {\n\t                /* The journalctl command fails when no entries are matched\n\t                 * so we just ignore this status code */\n\t                if (ex.problem == \"cancelled\" ||\n\t                    ex.exit_status === 1) {\n\t                    fire_streamers();\n\t                    dfd.resolve(entries);\n\t                } else {\n\t                    dfd.reject(ex);\n\t                }\n\t            }).\n\t            always(function() {\n\t                window.clearInterval(interval);\n\t            });\n\t\n\t        promise = dfd.promise();\n\t        promise.stream = function stream(callback) {\n\t            streamers.push(callback);\n\t            return this;\n\t        };\n\t        promise.stop = function stop() {\n\t            proc.close(\"cancelled\");\n\t        };\n\t        return promise;\n\t    };\n\t\n\t    journal.printable = function printable(value) {\n\t        if (value === undefined || value === null)\n\t            return _(\"[no data]\");\n\t        else if (typeof(value) == \"string\")\n\t            return value;\n\t        else if (value.length !== undefined)\n\t            return cockpit.format(_(\"[$0 bytes of binary data]\"), value.length);\n\t        else\n\t            return _(\"[binary data]\");\n\t    };\n\t\n\t    function output_funcs_for_box(box) {\n\t        /* Dereference any jQuery object here */\n\t        if (box.jquery)\n\t            box = box[0];\n\t\n\t        Mustache.parse(day_header_template);\n\t        Mustache.parse(line_template);\n\t        Mustache.parse(reboot_template);\n\t\n\t        function render_line(ident, prio, message, count, time, entry) {\n\t            var parts = {\n\t                    'cursor': entry[\"__CURSOR\"],\n\t                    'time': time,\n\t                    'message': message,\n\t                    'service': ident\n\t                };\n\t            if (count > 1)\n\t                parts['count'] = count;\n\t            if (ident === 'abrt-notification') {\n\t                parts['problem'] = true;\n\t                parts['service'] = entry['PROBLEM_BINARY'];\n\t            }\n\t            else if (prio < 4)\n\t                parts['warning'] = true;\n\t            return Mustache.render(line_template, parts);\n\t        }\n\t\n\t        var reboot = _(\"Reboot\");\n\t        var reboot_line = Mustache.render(reboot_template, {'message': reboot} );\n\t\n\t        function render_reboot_separator() {\n\t            return reboot_line;\n\t        }\n\t\n\t        function render_day_header(day) {\n\t            return Mustache.render(day_header_template, {'day': day} );\n\t        }\n\t\n\t        function parse_html(string) {\n\t            var div = document.createElement(\"div\");\n\t            div.innerHTML = string.trim();\n\t            return div.children[0];\n\t        }\n\t\n\t        return {\n\t            render_line: render_line,\n\t            render_day_header: render_day_header,\n\t            render_reboot_separator: render_reboot_separator,\n\t\n\t            append: function(elt) {\n\t                if (typeof (elt) == \"string\")\n\t                    elt = parse_html(elt);\n\t                box.appendChild(elt);\n\t            },\n\t            prepend: function(elt) {\n\t                if (typeof (elt) == \"string\")\n\t                    elt = parse_html(elt);\n\t                if (box.firstChild)\n\t                    box.insertBefore(elt, box.firstChild);\n\t                else\n\t                    box.appendChild(elt);\n\t            },\n\t            remove_last: function() {\n\t                if (box.lastChild)\n\t                    box.removeChild(box.lastChild);\n\t            },\n\t            remove_first: function() {\n\t                if (box.firstChild)\n\t                    box.removeChild(box.firstChild);\n\t            },\n\t        };\n\t    }\n\t\n\t    var month_names = [\n\t        C_(\"month-name\", 'January'),\n\t        C_(\"month-name\", 'February'),\n\t        C_(\"month-name\", 'March'),\n\t        C_(\"month-name\", 'April'),\n\t        C_(\"month-name\", 'May'),\n\t        C_(\"month-name\", 'June'),\n\t        C_(\"month-name\", 'July'),\n\t        C_(\"month-name\", 'August'),\n\t        C_(\"month-name\", 'September'),\n\t        C_(\"month-name\", 'October'),\n\t        C_(\"month-name\", 'November'),\n\t        C_(\"month-name\", 'December')\n\t    ];\n\t\n\t    /* Render the journal entries by passing suitable HTML strings back to\n\t       the caller via the 'output_funcs'.\n\t\n\t       Rendering is context aware.  It will insert 'reboot' markers, for\n\t       example, and collapse repeated lines.  You can extend the output at\n\t       the bottom and also at the top.\n\t\n\t       A new renderer is created by calling 'journal.renderer' like\n\t       so:\n\t\n\t          var renderer = journal.renderer(funcs);\n\t\n\t       You can feed new entries into the renderer by calling various\n\t       methods on the returned object:\n\t\n\t          - renderer.append(journal_entry)\n\t          - renderer.append_flush()\n\t          - renderer.prepend(journal_entry)\n\t          - renderer.prepend_flush()\n\t\n\t       A 'journal_entry' is one element of the result array returned by a\n\t       call to 'Query' with the 'cockpit.journal_fields' as the fields to\n\t       return.\n\t\n\t       Calling 'append' will append the given entry to the end of the\n\t       output, naturally, and 'prepend' will prepend it to the start.\n\t\n\t       The output might lag behind what has been input via 'append' and\n\t       'prepend', and you need to call 'append_flush' and 'prepend_flush'\n\t       respectively to ensure that the output is up-to-date.  Flushing a\n\t       renderer does not introduce discontinuities into the output.  You\n\t       can continue to feed entries into the renderer after flushing and\n\t       repeated lines will be correctly collapsed across the flush, for\n\t       example.\n\t\n\t       The renderer will call methods of the 'output_funcs' object to\n\t       produce the desired output:\n\t\n\t          - output_funcs.append(rendered)\n\t          - output_funcs.remove_last()\n\t          - output_funcs.prepend(rendered)\n\t          - output_funcs.remove_first()\n\t\n\t       The 'rendered' argument is the return value of one of the rendering\n\t       functions described below.  The 'append' and 'prepend' methods\n\t       should add this element to the output, naturally, and 'remove_last'\n\t       and 'remove_first' should remove the indicated element.\n\t\n\t       If you never call 'prepend' on the renderer, 'output_func.prepend'\n\t       isn't called either.  If you never call 'renderer.prepend' after\n\t       'renderer.prepend_flush', then 'output_func.remove_first' will\n\t       never be called.  The same guarantees exist for the 'append' family\n\t       of functions.\n\t\n\t       The actual rendering is also done by calling methods on\n\t       'output_funcs':\n\t\n\t          - output_funcs.render_line(ident, prio, message, count, time, cursor)\n\t          - output_funcs.render_day_header(day)\n\t          - output_funcs.render_reboot_separator()\n\t\n\t    */\n\t\n\t    journal.renderer = function renderer(funcs_or_box) {\n\t        var output_funcs;\n\t        if (funcs_or_box.render_line)\n\t            output_funcs = funcs_or_box;\n\t        else\n\t            output_funcs = output_funcs_for_box(funcs_or_box);\n\t\n\t        function copy_object(o) {\n\t            var c = { }; for(var p in o) c[p] = o[p]; return c;\n\t        }\n\t\n\t        // A 'entry' object describes a journal entry in formatted form.\n\t        // It has fields 'bootid', 'ident', 'prio', 'message', 'time',\n\t        // 'day', all of which are strings.\n\t\n\t        function format_entry(journal_entry) {\n\t            function pad(n) {\n\t                var str = n.toFixed();\n\t                if(str.length == 1)\n\t                    str = '0' + str;\n\t                return str;\n\t            }\n\t\n\t            var d = new Date(journal_entry[\"__REALTIME_TIMESTAMP\"] / 1000);\n\t            return {\n\t                cursor: journal_entry[\"__CURSOR\"],\n\t                full: journal_entry,\n\t                day: month_names[d.getMonth()] + ' ' + d.getDate().toFixed() + ', ' + d.getFullYear().toFixed(),\n\t                time: pad(d.getHours()) + ':' + pad(d.getMinutes()),\n\t                bootid: journal_entry[\"_BOOT_ID\"],\n\t                ident: journal_entry[\"SYSLOG_IDENTIFIER\"] || journal_entry[\"_COMM\"],\n\t                prio: journal_entry[\"PRIORITY\"],\n\t                message: journal.printable(journal_entry[\"MESSAGE\"])\n\t            };\n\t        }\n\t\n\t        function entry_is_equal(a, b) {\n\t            return (a && b &&\n\t                    a.day == b.day &&\n\t                    a.bootid == b.bootid &&\n\t                    a.ident == b.ident &&\n\t                    a.prio == b.prio &&\n\t                    a.message == b.message);\n\t        }\n\t\n\t        // A state object describes a line that should be eventually\n\t        // output.  It has an 'entry' field as per description above, and\n\t        // also 'count', 'last_time', and 'first_time', which record\n\t        // repeated entries.  Additionally:\n\t        //\n\t        // line_present: When true, the line has been output already with\n\t        //     some preliminary data.  It needs to be removed before\n\t        //     outputting more recent data.\n\t        //\n\t        // header_present: The day header has been output preliminarily\n\t        //     before the actual log lines.  It needs to be removed before\n\t        //     prepending more lines.  If both line_present and\n\t        //     header_present are true, then the header comes first in the\n\t        //     output, followed by the line.\n\t\n\t        function render_state_line(state) {\n\t            return output_funcs.render_line(state.entry.ident,\n\t                                            state.entry.prio,\n\t                                            state.entry.message,\n\t                                            state.count,\n\t                                            state.last_time,\n\t                                            state.entry.full);\n\t        }\n\t\n\t        // We keep the state of the first and last journal lines,\n\t        // respectively, in order to collapse repeated lines, and to\n\t        // insert reboot markers and day headers.\n\t        //\n\t        // Normally, there are two state objects, but if only a single\n\t        // line has been output so far, top_state and bottom_state point\n\t        // to the same object.\n\t\n\t        var top_state, bottom_state;\n\t\n\t        top_state = bottom_state = { };\n\t\n\t        function start_new_line() {\n\t            // If we now have two lines, split the state\n\t            if (top_state === bottom_state && top_state.entry) {\n\t                top_state = copy_object(bottom_state);\n\t            }\n\t        }\n\t\n\t        function top_output() {\n\t            if (top_state.header_present) {\n\t                output_funcs.remove_first();\n\t                top_state.header_present = false;\n\t            }\n\t            if (top_state.line_present) {\n\t                output_funcs.remove_first();\n\t                top_state.line_present = false;\n\t            }\n\t            if (top_state.entry) {\n\t                output_funcs.prepend(render_state_line(top_state));\n\t                top_state.line_present = true;\n\t            }\n\t        }\n\t\n\t        function prepend(journal_entry) {\n\t            var entry = format_entry(journal_entry);\n\t\n\t            if (entry_is_equal(top_state.entry, entry)) {\n\t                top_state.count += 1;\n\t                top_state.first_time = entry.time;\n\t            } else {\n\t                top_output();\n\t\n\t                if (top_state.entry) {\n\t                    if (entry.bootid != top_state.entry.bootid)\n\t                        output_funcs.prepend(output_funcs.render_reboot_separator());\n\t                    if (entry.day != top_state.entry.day)\n\t                        output_funcs.prepend(output_funcs.render_day_header(top_state.entry.day));\n\t                }\n\t\n\t                start_new_line();\n\t                top_state.entry = entry;\n\t                top_state.count = 1;\n\t                top_state.first_time = top_state.last_time = entry.time;\n\t                top_state.line_present = false;\n\t            }\n\t        }\n\t\n\t        function prepend_flush() {\n\t            top_output();\n\t            if (top_state.entry) {\n\t                output_funcs.prepend(output_funcs.render_day_header(top_state.entry.day));\n\t                top_state.header_present = true;\n\t            }\n\t        }\n\t\n\t        function bottom_output() {\n\t            if (bottom_state.line_present) {\n\t                output_funcs.remove_last();\n\t                bottom_state.line_present = false;\n\t            }\n\t            if (bottom_state.entry) {\n\t                output_funcs.append(render_state_line(bottom_state));\n\t                bottom_state.line_present = true;\n\t            }\n\t        }\n\t\n\t        function append(journal_entry) {\n\t            var entry = format_entry(journal_entry);\n\t\n\t            if (entry_is_equal(bottom_state.entry, entry)) {\n\t                bottom_state.count += 1;\n\t                bottom_state.last_time = entry.time;\n\t            } else {\n\t                bottom_output();\n\t\n\t                if (!bottom_state.entry || entry.day != bottom_state.entry.day) {\n\t                    output_funcs.append(output_funcs.render_day_header(entry.day));\n\t                    bottom_state.header_present = true;\n\t                }\n\t                if (bottom_state.entry && entry.bootid != bottom_state.entry.bootid)\n\t                    output_funcs.append(output_funcs.render_reboot_separator());\n\t\n\t                start_new_line();\n\t                bottom_state.entry = entry;\n\t                bottom_state.count = 1;\n\t                bottom_state.first_time = bottom_state.last_time = entry.time;\n\t                bottom_state.line_present = false;\n\t            }\n\t        }\n\t\n\t        function append_flush() {\n\t            bottom_output();\n\t        }\n\t\n\t        return { prepend: prepend,\n\t                 prepend_flush: prepend_flush,\n\t                 append: append,\n\t                 append_flush: append_flush\n\t               };\n\t    };\n\t\n\t    journal.logbox = function logbox(match, max_entries) {\n\t        var entries = [ ];\n\t        var box = document.createElement(\"div\");\n\t\n\t        function render() {\n\t            var renderer = journal.renderer(box);\n\t            while(box.firstChild)\n\t                box.removeChild(box.firstChild);\n\t            for (var i = 0; i < entries.length; i++) {\n\t                renderer.prepend(entries[i]);\n\t            }\n\t            renderer.prepend_flush();\n\t            if (entries.length > 0)\n\t                box.removeAttribute(\"hidden\");\n\t            else\n\t                box.setAttribute(\"hidden\", \"hidden\");\n\t        }\n\t\n\t        render();\n\t\n\t        var promise = journal.journalctl(match, { count: max_entries }).\n\t            stream(function(tail) {\n\t                entries = entries.concat(tail);\n\t                if (entries.length > max_entries)\n\t                    entries = entries.slice(-max_entries);\n\t                render();\n\t            }).\n\t            fail(function(error) {\n\t                box.appendChild(document.createTextNode(error.message));\n\t                box.removeAttribute(\"hidden\");\n\t            });\n\t\n\t        /* Both a DOM element and a promise */\n\t        return promise.promise(box);\n\t    };\n\t\n\t    module.exports = journal;\n\t}());\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\n\t * This file is part of Cockpit.\n\t *\n\t * Copyright (C) 2016 Red Hat, Inc.\n\t *\n\t * Cockpit is free software; you can redistribute it and/or modify it\n\t * under the terms of the GNU Lesser General Public License as published by\n\t * the Free Software Foundation; either version 2.1 of the License, or\n\t * (at your option) any later version.\n\t *\n\t * Cockpit is distributed in the hope that it will be useful, but\n\t * WITHOUT ANY WARRANTY; without even the implied warranty of\n\t * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n\t * Lesser General Public License for more details.\n\t *\n\t * You should have received a copy of the GNU Lesser General Public License\n\t * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n\t */\n\t\n\tvar cockpit = __webpack_require__(3);\n\tvar mustache = __webpack_require__(6);\n\t\n\t/*\n\t * Turns a mustache template into a translated mustache template\n\t * by preparsing it and translating it.\n\t */\n\tvar cache = { };\n\t\n\tfunction translate(template) {\n\t    if (template in cache)\n\t        return cache[template];\n\t    var div = document.createElement(\"div\");\n\t    div.innerHTML = template;\n\t    cockpit.translate(div);\n\t    var result = div.innerHTML;\n\t    cache[template] = result;\n\t    return result;\n\t}\n\t\n\t/* Just like the mustache object, except for translated */\n\tmodule.exports = cockpit.extend({ }, mustache, {\n\t    render: function render(template, view, partials) {\n\t        return translate(mustache.render(template, view, partials));\n\t    },\n\t    to_html: function to_html(template, view, partials, send) {\n\t        return translate(mustache.to_html(template, view, partials, send));\n\t    },\n\t    clearCache: function clearCache() {\n\t        cache = { };\n\t        return mustache.clearCache();\n\t    }\n\t});\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t * mustache.js - Logic-less {{mustache}} templates with JavaScript\n\t * http://github.com/janl/mustache.js\n\t */\n\t\n\t/*global define: false*/\n\t\n\t(function (root, factory) {\n\t  if (typeof exports === \"object\" && exports) {\n\t    factory(exports); // CommonJS\n\t  } else {\n\t    var mustache = {};\n\t    factory(mustache);\n\t    if (true) {\n\t      !(__WEBPACK_AMD_DEFINE_FACTORY__ = (mustache), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD\n\t    } else {\n\t      root.Mustache = mustache; // <script>\n\t    }\n\t  }\n\t}(this, function (mustache) {\n\t\n\t  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n\t  // See https://github.com/janl/mustache.js/issues/189\n\t  var RegExp_test = RegExp.prototype.test;\n\t  function testRegExp(re, string) {\n\t    return RegExp_test.call(re, string);\n\t  }\n\t\n\t  var nonSpaceRe = /\\S/;\n\t  function isWhitespace(string) {\n\t    return !testRegExp(nonSpaceRe, string);\n\t  }\n\t\n\t  var Object_toString = Object.prototype.toString;\n\t  var isArray = Array.isArray || function (object) {\n\t    return Object_toString.call(object) === '[object Array]';\n\t  };\n\t\n\t  function isFunction(object) {\n\t    return typeof object === 'function';\n\t  }\n\t\n\t  function escapeRegExp(string) {\n\t    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n\t  }\n\t\n\t  var entityMap = {\n\t    \"&\": \"&amp;\",\n\t    \"<\": \"&lt;\",\n\t    \">\": \"&gt;\",\n\t    '\"': '&quot;',\n\t    \"'\": '&#39;',\n\t    \"/\": '&#x2F;'\n\t  };\n\t\n\t  function escapeHtml(string) {\n\t    return String(string).replace(/[&<>\"'\\/]/g, function (s) {\n\t      return entityMap[s];\n\t    });\n\t  }\n\t\n\t  function escapeTags(tags) {\n\t    if (!isArray(tags) || tags.length !== 2) {\n\t      throw new Error('Invalid tags: ' + tags);\n\t    }\n\t\n\t    return [\n\t      new RegExp(escapeRegExp(tags[0]) + \"\\\\s*\"),\n\t      new RegExp(\"\\\\s*\" + escapeRegExp(tags[1]))\n\t    ];\n\t  }\n\t\n\t  var whiteRe = /\\s*/;\n\t  var spaceRe = /\\s+/;\n\t  var equalsRe = /\\s*=/;\n\t  var curlyRe = /\\s*\\}/;\n\t  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\t\n\t  /**\n\t   * Breaks up the given `template` string into a tree of tokens. If the `tags`\n\t   * argument is given here it must be an array with two string values: the\n\t   * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n\t   * course, the default is to use mustaches (i.e. mustache.tags).\n\t   *\n\t   * A token is an array with at least 4 elements. The first element is the\n\t   * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n\t   * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n\t   * all text that appears outside a symbol this element is \"text\".\n\t   *\n\t   * The second element of a token is its \"value\". For mustache tags this is\n\t   * whatever else was inside the tag besides the opening symbol. For text tokens\n\t   * this is the text itself.\n\t   *\n\t   * The third and fourth elements of the token are the start and end indices,\n\t   * respectively, of the token in the original template.\n\t   *\n\t   * Tokens that are the root node of a subtree contain two more elements: 1) an\n\t   * array of tokens in the subtree and 2) the index in the original template at\n\t   * which the closing tag for that section begins.\n\t   */\n\t  function parseTemplate(template, tags) {\n\t    tags = tags || mustache.tags;\n\t    template = template || '';\n\t\n\t    if (typeof tags === 'string') {\n\t      tags = tags.split(spaceRe);\n\t    }\n\t\n\t    var tagRes = escapeTags(tags);\n\t    var scanner = new Scanner(template);\n\t\n\t    var sections = [];     // Stack to hold section tokens\n\t    var tokens = [];       // Buffer to hold the tokens\n\t    var spaces = [];       // Indices of whitespace tokens on the current line\n\t    var hasTag = false;    // Is there a {{tag}} on the current line?\n\t    var nonSpace = false;  // Is there a non-space char on the current line?\n\t\n\t    // Strips all whitespace tokens array for the current line\n\t    // if there was a {{#tag}} on it and otherwise only space.\n\t    function stripSpace() {\n\t      if (hasTag && !nonSpace) {\n\t        while (spaces.length) {\n\t          delete tokens[spaces.pop()];\n\t        }\n\t      } else {\n\t        spaces = [];\n\t      }\n\t\n\t      hasTag = false;\n\t      nonSpace = false;\n\t    }\n\t\n\t    var start, type, value, chr, token, openSection;\n\t    while (!scanner.eos()) {\n\t      start = scanner.pos;\n\t\n\t      // Match any text between tags.\n\t      value = scanner.scanUntil(tagRes[0]);\n\t      if (value) {\n\t        for (var i = 0, len = value.length; i < len; ++i) {\n\t          chr = value.charAt(i);\n\t\n\t          if (isWhitespace(chr)) {\n\t            spaces.push(tokens.length);\n\t          } else {\n\t            nonSpace = true;\n\t          }\n\t\n\t          tokens.push(['text', chr, start, start + 1]);\n\t          start += 1;\n\t\n\t          // Check for whitespace on the current line.\n\t          if (chr === '\\n') {\n\t            stripSpace();\n\t          }\n\t        }\n\t      }\n\t\n\t      // Match the opening tag.\n\t      if (!scanner.scan(tagRes[0])) break;\n\t      hasTag = true;\n\t\n\t      // Get the tag type.\n\t      type = scanner.scan(tagRe) || 'name';\n\t      scanner.scan(whiteRe);\n\t\n\t      // Get the tag value.\n\t      if (type === '=') {\n\t        value = scanner.scanUntil(equalsRe);\n\t        scanner.scan(equalsRe);\n\t        scanner.scanUntil(tagRes[1]);\n\t      } else if (type === '{') {\n\t        value = scanner.scanUntil(new RegExp('\\\\s*' + escapeRegExp('}' + tags[1])));\n\t        scanner.scan(curlyRe);\n\t        scanner.scanUntil(tagRes[1]);\n\t        type = '&';\n\t      } else {\n\t        value = scanner.scanUntil(tagRes[1]);\n\t      }\n\t\n\t      // Match the closing tag.\n\t      if (!scanner.scan(tagRes[1])) {\n\t        throw new Error('Unclosed tag at ' + scanner.pos);\n\t      }\n\t\n\t      token = [ type, value, start, scanner.pos ];\n\t      tokens.push(token);\n\t\n\t      if (type === '#' || type === '^') {\n\t        sections.push(token);\n\t      } else if (type === '/') {\n\t        // Check section nesting.\n\t        openSection = sections.pop();\n\t\n\t        if (!openSection) {\n\t          throw new Error('Unopened section \"' + value + '\" at ' + start);\n\t        }\n\t        if (openSection[1] !== value) {\n\t          throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n\t        }\n\t      } else if (type === 'name' || type === '{' || type === '&') {\n\t        nonSpace = true;\n\t      } else if (type === '=') {\n\t        // Set the tags for the next time around.\n\t        tagRes = escapeTags(tags = value.split(spaceRe));\n\t      }\n\t    }\n\t\n\t    // Make sure there are no open sections when we're done.\n\t    openSection = sections.pop();\n\t    if (openSection) {\n\t      throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\t    }\n\t\n\t    return nestTokens(squashTokens(tokens));\n\t  }\n\t\n\t  /**\n\t   * Combines the values of consecutive text tokens in the given `tokens` array\n\t   * to a single token.\n\t   */\n\t  function squashTokens(tokens) {\n\t    var squashedTokens = [];\n\t\n\t    var token, lastToken;\n\t    for (var i = 0, len = tokens.length; i < len; ++i) {\n\t      token = tokens[i];\n\t\n\t      if (token) {\n\t        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n\t          lastToken[1] += token[1];\n\t          lastToken[3] = token[3];\n\t        } else {\n\t          squashedTokens.push(token);\n\t          lastToken = token;\n\t        }\n\t      }\n\t    }\n\t\n\t    return squashedTokens;\n\t  }\n\t\n\t  /**\n\t   * Forms the given array of `tokens` into a nested tree structure where\n\t   * tokens that represent a section have two additional items: 1) an array of\n\t   * all tokens that appear in that section and 2) the index in the original\n\t   * template that represents the end of that section.\n\t   */\n\t  function nestTokens(tokens) {\n\t    var nestedTokens = [];\n\t    var collector = nestedTokens;\n\t    var sections = [];\n\t\n\t    var token, section;\n\t    for (var i = 0, len = tokens.length; i < len; ++i) {\n\t      token = tokens[i];\n\t\n\t      switch (token[0]) {\n\t      case '#':\n\t      case '^':\n\t        collector.push(token);\n\t        sections.push(token);\n\t        collector = token[4] = [];\n\t        break;\n\t      case '/':\n\t        section = sections.pop();\n\t        section[5] = token[2];\n\t        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n\t        break;\n\t      default:\n\t        collector.push(token);\n\t      }\n\t    }\n\t\n\t    return nestedTokens;\n\t  }\n\t\n\t  /**\n\t   * A simple string scanner that is used by the template parser to find\n\t   * tokens in template strings.\n\t   */\n\t  function Scanner(string) {\n\t    this.string = string;\n\t    this.tail = string;\n\t    this.pos = 0;\n\t  }\n\t\n\t  /**\n\t   * Returns `true` if the tail is empty (end of string).\n\t   */\n\t  Scanner.prototype.eos = function () {\n\t    return this.tail === \"\";\n\t  };\n\t\n\t  /**\n\t   * Tries to match the given regular expression at the current position.\n\t   * Returns the matched text if it can match, the empty string otherwise.\n\t   */\n\t  Scanner.prototype.scan = function (re) {\n\t    var match = this.tail.match(re);\n\t\n\t    if (match && match.index === 0) {\n\t      var string = match[0];\n\t      this.tail = this.tail.substring(string.length);\n\t      this.pos += string.length;\n\t      return string;\n\t    }\n\t\n\t    return \"\";\n\t  };\n\t\n\t  /**\n\t   * Skips all text until the given regular expression can be matched. Returns\n\t   * the skipped string, which is the entire tail if no match can be made.\n\t   */\n\t  Scanner.prototype.scanUntil = function (re) {\n\t    var index = this.tail.search(re), match;\n\t\n\t    switch (index) {\n\t    case -1:\n\t      match = this.tail;\n\t      this.tail = \"\";\n\t      break;\n\t    case 0:\n\t      match = \"\";\n\t      break;\n\t    default:\n\t      match = this.tail.substring(0, index);\n\t      this.tail = this.tail.substring(index);\n\t    }\n\t\n\t    this.pos += match.length;\n\t\n\t    return match;\n\t  };\n\t\n\t  /**\n\t   * Represents a rendering context by wrapping a view object and\n\t   * maintaining a reference to the parent context.\n\t   */\n\t  function Context(view, parentContext) {\n\t    this.view = view == null ? {} : view;\n\t    this.cache = { '.': this.view };\n\t    this.parent = parentContext;\n\t  }\n\t\n\t  /**\n\t   * Creates a new context using the given view with this context\n\t   * as the parent.\n\t   */\n\t  Context.prototype.push = function (view) {\n\t    return new Context(view, this);\n\t  };\n\t\n\t  /**\n\t   * Returns the value of the given name in this context, traversing\n\t   * up the context hierarchy if the value is absent in this context's view.\n\t   */\n\t  Context.prototype.lookup = function (name) {\n\t    var value;\n\t    if (name in this.cache) {\n\t      value = this.cache[name];\n\t    } else {\n\t      var context = this;\n\t\n\t      while (context) {\n\t        if (name.indexOf('.') > 0) {\n\t          value = context.view;\n\t\n\t          var names = name.split('.'), i = 0;\n\t          while (value != null && i < names.length) {\n\t            value = value[names[i++]];\n\t          }\n\t        } else {\n\t          value = context.view[name];\n\t        }\n\t\n\t        if (value != null) break;\n\t\n\t        context = context.parent;\n\t      }\n\t\n\t      this.cache[name] = value;\n\t    }\n\t\n\t    if (isFunction(value)) {\n\t      value = value.call(this.view);\n\t    }\n\t\n\t    return value;\n\t  };\n\t\n\t  /**\n\t   * A Writer knows how to take a stream of tokens and render them to a\n\t   * string, given a context. It also maintains a cache of templates to\n\t   * avoid the need to parse the same template twice.\n\t   */\n\t  function Writer() {\n\t    this.cache = {};\n\t  }\n\t\n\t  /**\n\t   * Clears all cached templates in this writer.\n\t   */\n\t  Writer.prototype.clearCache = function () {\n\t    this.cache = {};\n\t  };\n\t\n\t  /**\n\t   * Parses and caches the given `template` and returns the array of tokens\n\t   * that is generated from the parse.\n\t   */\n\t  Writer.prototype.parse = function (template, tags) {\n\t    var cache = this.cache;\n\t    var tokens = cache[template];\n\t\n\t    if (tokens == null) {\n\t      tokens = cache[template] = parseTemplate(template, tags);\n\t    }\n\t\n\t    return tokens;\n\t  };\n\t\n\t  /**\n\t   * High-level method that is used to render the given `template` with\n\t   * the given `view`.\n\t   *\n\t   * The optional `partials` argument may be an object that contains the\n\t   * names and templates of partials that are used in the template. It may\n\t   * also be a function that is used to load partial templates on the fly\n\t   * that takes a single argument: the name of the partial.\n\t   */\n\t  Writer.prototype.render = function (template, view, partials) {\n\t    var tokens = this.parse(template);\n\t    var context = (view instanceof Context) ? view : new Context(view);\n\t    return this.renderTokens(tokens, context, partials, template);\n\t  };\n\t\n\t  /**\n\t   * Low-level method that renders the given array of `tokens` using\n\t   * the given `context` and `partials`.\n\t   *\n\t   * Note: The `originalTemplate` is only ever used to extract the portion\n\t   * of the original template that was contained in a higher-order section.\n\t   * If the template doesn't use higher-order sections, this argument may\n\t   * be omitted.\n\t   */\n\t  Writer.prototype.renderTokens = function (tokens, context, partials, originalTemplate) {\n\t    var buffer = '';\n\t\n\t    // This function is used to render an arbitrary template\n\t    // in the current context by higher-order sections.\n\t    var self = this;\n\t    function subRender(template) {\n\t      return self.render(template, context, partials);\n\t    }\n\t\n\t    var token, value;\n\t    for (var i = 0, len = tokens.length; i < len; ++i) {\n\t      token = tokens[i];\n\t\n\t      switch (token[0]) {\n\t      case '#':\n\t        value = context.lookup(token[1]);\n\t        if (!value) continue;\n\t\n\t        if (isArray(value)) {\n\t          for (var j = 0, jlen = value.length; j < jlen; ++j) {\n\t            buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);\n\t          }\n\t        } else if (typeof value === 'object' || typeof value === 'string') {\n\t          buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);\n\t        } else if (isFunction(value)) {\n\t          if (typeof originalTemplate !== 'string') {\n\t            throw new Error('Cannot use higher-order sections without the original template');\n\t          }\n\t\n\t          // Extract the portion of the original template that the section contains.\n\t          value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n\t\n\t          if (value != null) buffer += value;\n\t        } else {\n\t          buffer += this.renderTokens(token[4], context, partials, originalTemplate);\n\t        }\n\t\n\t        break;\n\t      case '^':\n\t        value = context.lookup(token[1]);\n\t\n\t        // Use JavaScript's definition of falsy. Include empty arrays.\n\t        // See https://github.com/janl/mustache.js/issues/186\n\t        if (!value || (isArray(value) && value.length === 0)) {\n\t          buffer += this.renderTokens(token[4], context, partials, originalTemplate);\n\t        }\n\t\n\t        break;\n\t      case '>':\n\t        if (!partials) continue;\n\t        value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n\t        if (value != null) buffer += this.renderTokens(this.parse(value), context, partials, value);\n\t        break;\n\t      case '&':\n\t        value = context.lookup(token[1]);\n\t        if (value != null) buffer += value;\n\t        break;\n\t      case 'name':\n\t        value = context.lookup(token[1]);\n\t        if (value != null) buffer += mustache.escape(value);\n\t        break;\n\t      case 'text':\n\t        buffer += token[1];\n\t        break;\n\t      }\n\t    }\n\t\n\t    return buffer;\n\t  };\n\t\n\t  mustache.name = \"mustache.js\";\n\t  mustache.version = \"0.8.1\";\n\t  mustache.tags = [ \"{{\", \"}}\" ];\n\t\n\t  // All high-level mustache.* functions use this writer.\n\t  var defaultWriter = new Writer();\n\t\n\t  /**\n\t   * Clears all cached templates in the default writer.\n\t   */\n\t  mustache.clearCache = function () {\n\t    return defaultWriter.clearCache();\n\t  };\n\t\n\t  /**\n\t   * Parses and caches the given template in the default writer and returns the\n\t   * array of tokens it contains. Doing this ahead of time avoids the need to\n\t   * parse templates on the fly as they are rendered.\n\t   */\n\t  mustache.parse = function (template, tags) {\n\t    return defaultWriter.parse(template, tags);\n\t  };\n\t\n\t  /**\n\t   * Renders the `template` with the given `view` and `partials` using the\n\t   * default writer.\n\t   */\n\t  mustache.render = function (template, view, partials) {\n\t    return defaultWriter.render(template, view, partials);\n\t  };\n\t\n\t  // This is here for backwards compatibility with 0.4.x.\n\t  mustache.to_html = function (template, view, partials, send) {\n\t    var result = mustache.render(template, view, partials);\n\t\n\t    if (isFunction(send)) {\n\t      send(result);\n\t    } else {\n\t      return result;\n\t    }\n\t  };\n\t\n\t  // Export the escaping function so that the user may override it.\n\t  // See https://github.com/janl/mustache.js/issues/244\n\t  mustache.escape = escapeHtml;\n\t\n\t  // Export these mainly for testing, but also for advanced usage.\n\t  mustache.Scanner = Scanner;\n\t  mustache.Context = Context;\n\t  mustache.Writer = Writer;\n\t\n\t}));\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"panel-heading\\\">{{day}}</div>\\n\"\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"cockpit-logline\\\" data-cursor=\\\"{{cursor}}\\\">\\n  <div class=\\\"cockpit-log-warning\\\">{{#warning}}\\n    <i class=\\\"fa fa-exclamation-triangle\\\"></i>\\n  {{/warning}}{{#problem}}\\n    <i class=\\\"fa fa-times-circle-o\\\"></i>\\n  {{/problem}}\\n  </div>\\n  <div class=\\\"cockpit-log-time\\\">{{time}}</div>\\n  <span class=\\\"cockpit-log-message\\\">{{message}}</span>\\n  {{! if we have count (repeated messages), show service name and badge - otherwise just the service }}\\n  {{#count}}\\n  <div class=\\\"cockpit-log-service-container\\\">\\n    <div class=\\\"cockpit-log-service-reduced\\\">{{service}}</div>\\n    <span class=\\\"badge\\\">{{count}}&#160;<i class=\\\"fa fa-caret-right\\\"></i></span>\\n  </div>\\n  {{/count}}{{^count}}\\n  <div class=\\\"cockpit-log-service\\\">{{service}}</div>\\n  {{/count}}\\n</div>\\n\"\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"cockpit-logline\\\">\\n  {{! placeholders for correct message alignment }}\\n  <div class=\\\"cockpit-log-warning\\\"></div>\\n  <span class=\\\"cockpit-log-message cockpit-logmsg-reboot\\\">{{message}}</span>\\n</div>\\n\"\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// systemd/logs.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3dcd348b61d1e1c851e0","'use strict';\n\n/*\n * This file is part of Cockpit.\n *\n * Copyright (C) 2015 Red Hat, Inc.\n *\n * Cockpit is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * Cockpit is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n */\n\nvar $ = require(\"jquery\");\n$(function() {\n    \"use strict\";\n\n    var cockpit = require(\"cockpit\");\n\n    var journal = require(\"journal\");\n\n    cockpit.translate();\n    var _ = cockpit.gettext;\n\n    var problems_client = cockpit.dbus('org.freedesktop.problems', { superuser: \"try\" });\n    var service = problems_client.proxy('org.freedesktop.Problems2', '/org/freedesktop/Problems2');\n    var problems = problems_client.proxies('org.freedesktop.Problems2.Entry', '/org/freedesktop/Problems2/Entry');\n\n    // A map of ABRT's problems items and it's callback for rendering\n    var problem_render_callbacks = {'core_backtrace': render_backtrace,\n                                    'os_info': render_table_eq,\n                                    'environ': render_table_eq,\n                                    'limits': render_limits,\n                                    'cgroup': render_cgroup,\n                                    'namespaces': render_table_co,\n                                    'maps': render_maps,\n                                    'dso_list': render_dso_list,\n                                    'mountinfo': render_mountinfo,\n                                    'proc_pid_status': render_table_co,\n                                    'open_fds': render_open_fds,\n                                    'var_log_messages': render_multiline,\n                                    'not-reportable': render_multiline,\n                                    'exploitable': render_multiline,\n                                    'suspend_stats': render_table_co,\n                                    'dmesg': render_multiline,\n                                    'container_rootfs': render_multiline,\n                                    'docker_inspect': render_multiline\n                                    };\n\n    var problem_info_1 = ['reason', 'cmdline', 'executable', 'package', 'component',\n                          'crash_function', 'pid', 'pwd', 'hostname', 'count',\n                          'type', 'analyzer', 'rootdir', 'duphash', 'exception_type',\n                          'container', 'container_uuid', 'container_cmdline',\n                          'container_id', 'container_image' ];\n\n    var problem_info_2 = ['Directory', 'username', 'abrt_version', 'architecture', 'global_pid', 'kernel',\n                          'last_occurrence', 'os_release', 'pkg_fingerprint', 'pkg_vendor',\n                          'runlevel', 'tid', 'time', 'uid', 'uuid'];\n\n    var displayable_problems = {};\n\n    //Get list of all problems that can be displayed\n    var find_problems = function () {\n        var r = $.Deferred();\n        problems.wait(function() {\n            try {\n                service.GetProblems(0, {})\n                    .done(function(problem_paths, options) {\n                        update_problems(problem_paths);\n                        r.resolve();\n                    });\n            }\n            catch(err) {\n                //ABRT is not installed. Suggest installing?\n                r.resolve();\n            }\n        });\n        return r;\n    };\n\n    function update_problems(problem_paths) {\n        for (var i in problem_paths) {\n            var p = problems[problem_paths[i]];\n            displayable_problems[p.ID] = {'count': p.Count, 'problem_path': p.path};\n            displayable_problems[p.UUID] = {'count': p.Count, 'problem_path': p.path};\n            displayable_problems[p.Duphash] = {'count': p.Count, 'problem_path': p.path};\n        }\n    }\n\n    /* Not public API */\n    function journalbox(outer, start, match, day_box) {\n        var box = $('<div class=\"panel panel-default cockpit-log-panel\">');\n        var start_box = $('<div class=\"journal-start\">');\n\n        outer.empty().append(box, start_box);\n\n        var query_count = 5000;\n        var query_more = 1000;\n\n        var renderer = journal.renderer(box);\n        /* cache to store offsets for days */\n        var renderitems_day_cache = null;\n        var procs = [];\n\n        function query_error(error) {\n            /* TODO: blank slate */\n            console.warn(cockpit.message(error));\n        }\n\n        function prepend_entries(entries) {\n            for (var i = 0; i < entries.length; i++)\n                renderer.prepend(entries[i]);\n            renderer.prepend_flush();\n            /* empty cache for day offsets */\n            renderitems_day_cache = null;\n        }\n\n        function append_entries(entries) {\n            for (var i = 0; i < entries.length; i++)\n                renderer.append(entries[i]);\n            renderer.append_flush();\n            /* empty cache for day offsets */\n            renderitems_day_cache = null;\n        }\n\n        function didnt_reach_start(first) {\n            var button = $('<button id=\"journal-load-earlier\" class=\"btn btn-default\" data-inline=\"true\" data-mini=\"true\">' +\n                           _(\"Load earlier entries\") +\n                           '</button>');\n            start_box.html(button);\n            button.click(function() {\n                var count = 0;\n                var stopped = null;\n                start_box.text(_(\"Loading...\"));\n                procs.push(journal.journalctl(match, { follow: false, reverse: true, cursor: first }).\n                    fail(query_error).\n                    stream(function(entries) {\n                        if (entries[0][\"__CURSOR\"] == first)\n                            entries.shift();\n                        count += entries.length;\n                        append_entries(entries);\n                        if (count >= query_more) {\n                            stopped = entries[entries.length - 1][\"__CURSOR\"];\n                            didnt_reach_start(stopped);\n                            this.stop();\n                        }\n                    }).\n                    done(function() {\n                        if (start_box.text() == _(\"Loading...\"))\n                            start_box.empty();\n                    }));\n            });\n        }\n\n        function follow(cursor) {\n            procs.push(journal.journalctl(match, { follow: true, count: 0, cursor: cursor }).\n                fail(query_error).\n                stream(function(entries) {\n                    if (entries[0][\"__CURSOR\"] == cursor)\n                        entries.shift();\n                    prepend_entries(entries);\n                    update_day_box();\n                }));\n        }\n\n        function update_day_box() {\n            /* Build cache if empty\n             */\n            if (renderitems_day_cache === null) {\n                renderitems_day_cache = [];\n                for (var d = box[0].firstChild; d; d = d.nextSibling) {\n                    if ($(d).hasClass('panel-heading'))\n                        renderitems_day_cache.push([$(d).offset().top, $(d).text()]);\n                }\n            }\n            if (renderitems_day_cache.length > 0) {\n                /* Find the last day that begins above top\n                 */\n                var currentIndex = 0;\n                var top = window.scrollY;\n                while ((currentIndex + 1) < renderitems_day_cache.length &&\n                        renderitems_day_cache[currentIndex + 1][0] < top) {\n                    currentIndex++;\n                }\n                day_box.text(renderitems_day_cache[currentIndex][1]);\n            } else {\n                /* No visible day headers\n                 */\n                day_box.text(_(\"Go to\"));\n            }\n        }\n\n        start_box.text(_(\"Loading...\"));\n\n        $(window).on('scroll', update_day_box);\n\n        var options = {\n            follow: false,\n            reverse: true\n        };\n\n        var all = false;\n        if (start == 'boot') {\n            options[\"boot\"] = null;\n        } else if (start == 'last-24h') {\n            options[\"since\"] = \"-1days\";\n        } else if (start == 'last-week') {\n            options[\"since\"] = \"-7days\";\n        } else {\n            all = true;\n        }\n\n        var last = null;\n        var count = 0;\n        var stopped = null;\n\n        procs.push(journal.journalctl(match, options).\n            fail(query_error).\n            stream(function(entries) {\n                if (!last) {\n                    last = entries[0][\"__CURSOR\"];\n                    follow(last);\n                    update_day_box();\n                }\n                count += entries.length;\n                append_entries(entries);\n                if (count >= query_count) {\n                    stopped = entries[entries.length - 1][\"__CURSOR\"];\n                    didnt_reach_start(stopped);\n                    this.stop();\n                }\n            }).\n            done(function() {\n                if (start_box.text() == _(\"Loading...\"))\n                    start_box.empty();\n                if (!last) {\n                    procs.push(journal.journalctl(match, { follow: true, count: 0,\n                                                           boot: options[\"boot\"],\n                                                           since: options[\"since\"]\n                                                         }).\n                        fail(query_error).\n                        stream(function(entries) {\n                            prepend_entries(entries);\n                            update_day_box();\n                        }));\n                }\n                if (!all || stopped)\n                    didnt_reach_start();\n            }));\n\n        outer.stop = function stop() {\n            $(window).off('scroll', update_day_box);\n            $.each(procs, function(i, proc) {\n                proc.stop();\n            });\n        };\n\n        return outer;\n    }\n\n    var filler;\n\n    function stop_query() {\n        if (filler)\n            filler.stop();\n    }\n\n    function update_query() {\n        stop_query();\n\n        var match = [ ];\n\n        var query_prio = cockpit.location.options['prio'] || \"3\";\n        var prio_level = parseInt(query_prio, 10);\n\n        // Set selected item into priority dropdown menu\n        var all_prios = document.getElementById('prio-lists').childNodes;\n        var item;\n        for (var j = 0; j < all_prios.length; j++) {\n            if (all_prios[j].nodeName === 'LI') {\n                item = all_prios[j].childNodes[0];\n                if (item.getAttribute('data-prio') === query_prio) {\n                    $('#journal-prio').text(item.text);\n                    break;\n                }\n            }\n        }\n\n        if (prio_level) {\n            for (var i = 0; i <= prio_level; i++)\n                match.push('PRIORITY=' + i.toString());\n        }\n\n        // If item 'Only Problems' was selected, match only ABRT's problems\n        if (prio_level === 2) {\n            match.push('SYSLOG_IDENTIFIER=abrt-notification');\n        }\n\n        var options = cockpit.location.options;\n        if (options['service'])\n            match.push('_SYSTEMD_UNIT=' + options['service']);\n        else if (options['tag'])\n            match.push('SYSLOG_IDENTIFIER=' + options['tag']);\n\n        var query_start = cockpit.location.options['start'] || \"recent\";\n        if (query_start == 'recent')\n            $(window).scrollTop($(document).height());\n\n        journalbox($(\"#journal-box\"), query_start, match, $('#journal-current-day'));\n    }\n\n    function update_entry() {\n        var cursor = cockpit.location.path[0];\n        var out = $('#journal-entry-fields');\n\n        out.empty();\n\n        function show_entry(entry) {\n            var d = new Date(entry[\"__REALTIME_TIMESTAMP\"] / 1000);\n            $('#journal-entry-date').text(d.toString());\n\n            var id;\n            if (entry[\"SYSLOG_IDENTIFIER\"])\n                id = entry[\"SYSLOG_IDENTIFIER\"];\n            else if (entry[\"_SYSTEMD_UNIT\"])\n                id = entry[\"_SYSTEMD_UNIT\"];\n            else\n                id = _(\"Journal entry\");\n\n            var is_problem = false;\n            if (id === 'abrt-notification'){\n                is_problem = true;\n                id = entry['PROBLEM_BINARY'];\n            }\n\n            $('#journal-entry-id').text(id);\n\n            if (is_problem) {\n                find_problems().done(function() {\n                    create_problem(out, entry);\n                });\n            } else {\n                create_entry(out, entry);\n            }\n        }\n\n        function show_error(error) {\n            out.append(\n                $('<tr>').append(\n                    $('<td>').\n                        text(error)));\n        }\n\n        journal.journalctl({ cursor: cursor, count: 1, follow: false }).\n            done(function (entries) {\n                if (entries.length >= 1 && entries[0][\"__CURSOR\"] == cursor)\n                    show_entry(entries[0]);\n                else\n                    show_error(_(\"Journal entry not found\"));\n            }).\n            fail(function (error) {\n                show_error(error);\n            });\n    }\n\n    function create_entry(out, entry){\n        $('#journal-entry-message').text(journal.printable(entry['MESSAGE']));\n        var keys = Object.keys(entry).sort();\n        $.each(keys, function (i, key) {\n            if (key !== 'MESSAGE') {\n                out.append(\n                    $('<tr>').append(\n                        $('<td>').css('text-align', 'right').text(key),\n                        $('<td>').css('text-align', 'left')\n                            .text(journal.printable(entry[key]))));\n            }\n        });\n    }\n\n    function create_problem(out, entry) {\n        var problem = null;\n        var all_p = [entry['PROBLEM_DIR'], entry['PROBLEM_DUPHASH'], entry['PROBLEM_UUID']];\n        for (var i = 0; i < all_p.length; i++) {\n            if (all_p[i] in displayable_problems) {\n                problem = problems[displayable_problems[all_p[i]]['problem_path']];\n                break;\n            }\n        }\n\n        //Display unknown problems as standard logs\n        //unknown problem = deleted problem | problem of different user\n        if (problem === null){\n            create_entry(out, entry);\n            return;\n        }\n\n        function switch_tab(new_tab, new_content) {\n            out.find('li').removeClass('active');\n            new_tab.addClass('active');\n            out.find('div').first().replaceWith(new_content);\n        }\n\n        $('#journal-entry-message').text('');\n\n        var ge_t = $('<li class=\"active\">').append($('<a>').append($('<span translatable=\"yes\">').text('General')));\n        var pi_t = $('<li>').append($('<a>').append($('<span translatable=\"yes\">').text('Problem info')));\n        var pd_t = $('<li>').append($('<a>').append($('<span translatable=\"yes\">').text('Problem details')));\n\n        var ge = $('<div>');\n        var pi = $('<div>');\n        var pd = $('<div class=\"panel-group\" id=\"accordion-markup\">');\n        var tab = $('<ul class=\"nav nav-tabs nav-tabs-pf\">');\n\n        var d_btn =  $('<button class=\"btn btn-danger problem-btn btn-delete pficon pficon-delete\">');\n\n        var r_btn = $();\n        if (problem.IsReported){\n            for (var pid = 0; pid < problem.Reports.length; pid++) {\n                if (problem.Reports[pid][0] === 'ABRT Server') {\n                    var url = problem.Reports[pid][1]['URL']['v']['v'];\n                    r_btn = $('<a class=\"problem-btn\">')\n                            .attr('href', url)\n                            .attr(\"target\", \"_blank\")\n                            .text('Reported');\n                    break;\n                }\n            }\n        }\n\n        else if (problem.CanBeReported){\n            r_btn = $('<button class=\"btn btn-primary problem-btn\">').text('Report');\n\n            r_btn.click(function() {\n                tab.children(':last-child').replaceWith($('<div class=\"spinner problem-btn\">'));\n                var proc = cockpit.spawn(['reporter-ureport', '-d', problem.ID], { superuser: 'true' });\n                proc.done(function() {\n                    window.location.reload();\n                });\n                proc.fail(function(ex) {\n                    var message;\n                    // 70 is 'This problem has already been reported'\n                    if (ex.exit_status === 70) {\n                        window.location.reload();\n                        return;\n                    } else if (ex.problem === 'access-denied') {\n                        message = _(\"Not authorized to upload-report\");\n                    } else if (ex.problem === \"not-found\") {\n                        message = _(\"Reporter 'reporter-ureport' not found.\");\n                    } else {\n                        message = _(\"Reporting was unsucessful. Try running `reporter-ureport -d \"+ problem.ID +\"`\");\n                    }\n                    $('<div class=\"alert alert-danger\">')\n                        .append('<span class=\"pficon pficon-error-circle-o\">')\n                        .text(message).insertAfter(\".breadcrumb\");\n                    tab.children(':last-child').replaceWith($('<span>'));\n                });\n            });\n        }\n\n        ge_t.click(function() {\n            switch_tab(ge_t, ge);\n        });\n\n        pi_t.click(function() {\n            switch_tab(pi_t, pi);\n        });\n\n        pd_t.click(function() {\n            switch_tab(pd_t, pd);\n        });\n\n        d_btn.click(function() {\n            service.DeleteProblems([problem.path]);\n            displayable_problems = { };\n            find_problems().done(function() {\n                cockpit.location.go('/');\n            });\n        });\n\n        // write into general tab non-ABRT related items\n        var keys = Object.keys(entry).sort();\n        $.each(keys, function(i, key) {\n            if (key !== 'MESSAGE' && key.indexOf('PROBLEM_') !== 0) {\n                ge.append(\n                    $('<tr>').append(\n                        $('<td>').css('text-align', 'right').text(key),\n                        $('<td>').css('text-align', 'left').\n                            text(journal.printable(entry[key]))));\n            }\n        });\n\n        tab.html(ge_t);\n        tab.append(pi_t);\n        tab.append(pd_t);\n        tab.append(d_btn);\n        tab.append(r_btn);\n\n        var body = $('<th>');\n        body.append(tab);\n        body.append(ge);\n\n        out.html($('<tr>').append(body));\n        out.css(\"margin-bottom\", \"0px\");\n\n        create_problem_details(problem, pi, pd);\n    }\n\n    function create_problem_details(problem, pi, pd) {\n        service.GetProblemData(problem.path).done(function(args, options) {\n            var i, elem, val;\n            // Render first column of problem info\n            var c1 = $('<table>').css('display', 'inline-block')\n                               .css('padding-right', '200px')\n                               .css('vertical-align', 'top');\n            pi.append(c1);\n            for (i = 0; i < problem_info_1.length; i++) {\n                elem = problem_info_1[i];\n                if (elem in args){\n                    val = args[elem][2];\n                    c1.append(\n                        $('<tr>').append(\n                            $('<td>').css('text-align', 'right').text(elem),\n                            $('<td>').css('text-align', 'left')\n                                .text(String(val))));\n                }\n            }\n\n            // Render second column of problem info\n            var c2 = $('<table>').css('display', 'inline-block')\n                               .css('vertical-align', 'top');\n            pi.append(c2);\n            for (i = 0; i < problem_info_2.length; i++) {\n                elem = problem_info_2[i];\n                if (elem in args){\n                    val = args[elem][2];\n                    // Display date properly\n                    if (['last_occurrence', 'time'].indexOf(elem) !== -1){\n                        var d = new Date(val / 1000);\n                        val = d.toString();\n                    }\n                    c2.append(\n                        $('<tr>').append(\n                            $('<td>').css('text-align', 'right').text(elem),\n                            $('<td>').css('text-align', 'left')\n                                .text(String(val))));\n                }\n            }\n\n            // Render problem details\n            var problem_details_elems = Object.keys(problem_render_callbacks);\n            $.each(problem_details_elems, function(i, key) {\n                if (key in args){\n                    val = problem_render_callbacks[key](args[key]);\n                    pd.append(\n                        $('<div class=\"panel panel-default\">')\n                            .css(\"border-width\", \"0px 0px 2px 0px\")\n                            .append(\n                          $('<div class=\"panel-heading problem-panel\">')\n                            .attr('data-toggle', 'collapse')\n                            .attr('data-target', '#' + key)\n                            .attr('data-parent', '#accordion-markup')\n                            .append($('<h4 class=\"panel-title\">')\n                              .append($('<a class=\"accordion-toggle\">')\n                                .text(key))),\n                          $('<div class=\"panel-collapse collapse\">')\n                            .attr('id', key)\n                            .append(\n                              $('<div class=\"panel-body\">')\n                                    .html(val))));\n                }\n            });\n        });\n    }\n\n    function render_table_eq(orig) {\n        return render_table(orig, '=');\n    }\n\n    function render_table_co(orig) {\n        return render_table(orig, ':');\n    }\n\n    function render_table(orig, delimiter) {\n        var lines = orig[2].split('\\n');\n        var result;\n\n        for (var i = 0; i < lines.length - 1; i++) {\n            var line = lines[i].split(delimiter);\n            result += '<tr> <td class=\"text-right\">' + line[0];\n            result += '<td class=\"text-left\">' + line[1];\n            result += '</tr>';\n        }\n\n        return result;\n    }\n\n    function render_multiline(orig) {\n        var rendered = orig[2].replace(/\\n/g, '<br>');\n        return rendered;\n    }\n\n    function render_multitable(orig, delimiter) {\n        var rendered = orig.replace(RegExp(delimiter, 'g'), '</td><td>');\n        rendered = rendered.replace(/\\n/g, '</td></tr><tr><td>');\n        return '<tr><td>' + rendered + '</td></tr>';\n    }\n\n    function render_dso_list(orig) {\n        var rendered = orig[2].replace(/^(\\S+\\s+)(\\S+)(.*)$/gm, '$1<b>$2</b>$3');\n        return render_multitable(rendered, ' ');\n    }\n\n    function render_open_fds(orig) {\n        var lines = orig[2].split('\\n');\n        for (var i = 0; i < lines.length - 1; i++) {\n            if (i % 5 !== 0) {\n                lines[i] = ':' + lines[i];\n            }\n        }\n        return render_multitable(lines.join('\\n'), ':');\n    }\n\n    function render_cgroup(orig) {\n        return render_multitable(orig[2], ':');\n    }\n\n    function render_mountinfo(orig) {\n        return render_multitable(orig[2].replace(/  +/g, ':'), ' ');\n    }\n\n    function render_maps(orig) {\n        return render_multitable(orig[2].replace(/  +/g, ':'), ' ');\n    }\n\n    function render_limits(orig) {\n        var lines = orig[2].split('\\n');\n        lines[0] ='\":' + lines[0].replace(/(\\S+) (\\S+) /g, '$1:$2 ');\n        for (var i = 1; i < lines.length - 1; i++) {\n                lines[i] = lines[i].replace(/  +/g, ':');\n        }\n\n        return render_multitable(lines.join('\\n'), ':');\n    }\n\n    function render_backtrace(content) {\n        var content_json = JSON.parse(content[2]);\n\n        var crash_thread = null;\n        var other_threads = [];\n        var other_items = {};\n\n        for (var item in content_json) {\n\n            if (item === 'stacktrace') {\n\n                var threads = content_json[item];\n                for (var thread_key in threads) {\n\n                    var thread = threads[thread_key];\n\n                    if (thread.hasOwnProperty(\"crash_thread\") && thread['crash_thread']) {\n                        if (thread.hasOwnProperty('frames')) {\n                            crash_thread = thread['frames'];\n                        }\n                    }\n                    else {\n                        if (thread.hasOwnProperty('frames')) {\n                            other_threads.push(thread['frames']);\n                        }\n                    }\n                }\n            }\n            else {\n                other_items[item] = content_json[item];\n            }\n        }\n        return create_detail_from_parsed_core_backtrace(crash_thread, other_threads, other_items);\n    }\n\n    function create_detail_from_parsed_core_backtrace(crash_thread, other_threads, other_items) {\n\n        var detail_content = '';\n        for (var item in other_items) {\n            detail_content += item;\n            detail_content += ': ' + other_items[item] + \"  \";\n        }\n\n        detail_content += create_table_from_thread(crash_thread);\n\n        if (other_threads.length !== 0) {\n            detail_content += '<div id=\"other_threads_btn_div\"><button class=\"btn btn-default other-threads-btn\" title=\"\">Show all threads</button></div>';\n            detail_content += '<div class=\"hidden other_threads\">';\n\n            var thread_num = 1;\n            for (var thread_key in other_threads) {\n                detail_content += '\\n';\n                detail_content += 'thread: ' + thread_num++ + '\\n';\n                detail_content += create_table_from_thread(other_threads[thread_key]);\n            }\n            detail_content += '</div>';\n        }\n\n        return detail_content;\n    }\n\n    function create_table_from_thread(thread) {\n        var all_keys = get_all_keys_from_frames(thread);\n\n        /* create table legend */\n        var table = '<table class=\"detail_table\"><thead><tr><th>Fr #</th>';\n        for (var key in all_keys) {\n            table += '<th>';\n            table += all_keys[key].replace(/_/g, ' ');\n            table += '</th>';\n        }\n        table += '</tr></thead><tbody>';\n\n        var frame_num = 1;\n        for (var frame_key in thread) {\n            table += '<tr>';\n            table += '<td>';\n            table += frame_num++;\n            table += '</td>';\n\n            var frame = thread[frame_key];\n            for (var key_key in all_keys) {\n                key = all_keys[key_key];\n\n                var title = '';\n                var row_content = '';\n                if (key in frame) {\n                    row_content = frame[key].toString();\n                    if (row_content.length > 8)\n                        title = row_content;\n                }\n                else\n                    row_content = '';\n\n                table += '<td title=\"' + title + '\">';\n                table += row_content;\n                table += '</td>';\n            }\n            table += '</tr>';\n        }\n\n        table += '</tbody></table>';\n        return table;\n    }\n\n    function get_all_keys_from_frames(thread) {\n        var all_keys = [];\n\n        for (var frame_key in thread) {\n            var frame = thread[frame_key];\n            var keys = Object.keys(frame);\n\n            for (var key in keys) {\n                if (all_keys.indexOf(keys[key]) === -1)\n                    all_keys.push(keys[key]);\n            }\n        }\n\n        /* order keys */\n        var desired_ordered_of_keys = ['function_name', 'file_name', 'address', 'build_id', 'build_id_offset'];\n\n        var all_ordered_keys = [];\n\n        for (var key_key in desired_ordered_of_keys) {\n            var in_key = desired_ordered_of_keys[key_key];\n            var key_index = all_keys.indexOf(in_key);\n            if (key_index !== -1) {\n                all_ordered_keys.push(in_key);\n                delete all_keys[key_index];\n            }\n        }\n\n        for(key_key in all_keys) {\n            all_ordered_keys.push(all_keys[key_key]);\n        }\n\n        return all_ordered_keys;\n    }\n\n    function update() {\n        var path = cockpit.location.path;\n        if (path.length === 0) {\n            $(\"#journal-entry\").hide();\n            update_query();\n            $(\"#journal\").show();\n        } else if (path.length == 1) {\n            stop_query();\n            $(\"#journal\").hide();\n            update_entry();\n            $(\"#journal-entry\").show();\n        } else { /* redirect */\n            console.warn(\"not a journal location: \" + path);\n            cockpit.location = '';\n        }\n        $(\"body\").show();\n    }\n\n    $(cockpit).on(\"locationchanged\", update);\n\n    $('#journal-current-day-menu a').on('click', function() {\n        cockpit.location.go([], $.extend(cockpit.location.options, { start: $(this).attr(\"data-op\") }));\n    });\n\n    $('#journal-box').on('click', '.cockpit-logline', function() {\n         var cursor = $(this).attr('data-cursor');\n         if (cursor)\n            cockpit.location.go([ cursor ]);\n    });\n\n    $('#journal-prio-menu a').on('click', function() {\n        cockpit.location.go([], $.extend(cockpit.location.options, { prio: $(this).attr('data-prio') }));\n    });\n\n    $('#journal-navigate-home').on(\"click\", function() {\n        cockpit.location.go('/');\n    });\n\n    update();\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../pkg/systemd/logs.js\n// module id = 1\n// module chunks = 0","module.exports = jQuery;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"jQuery\"\n// module id = 2\n// module chunks = 0 1 2","module.exports = cockpit;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"cockpit\"\n// module id = 3\n// module chunks = 0 1 2 3","'use strict';\n\n/*\n * This file is part of Cockpit.\n *\n * Copyright (C) 2015 Red Hat, Inc.\n *\n * Cockpit is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * Cockpit is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n */\n\n(function() {\n    \"use strict\";\n\n    var cockpit = require(\"cockpit\");\n    var Mustache = require(\"mustache\");\n    var day_header_template = require('raw!journal_day_header.mustache');\n    var line_template = require('raw!journal_line.mustache');\n    var reboot_template = require('raw!journal_reboot.mustache');\n\n    var _ = cockpit.gettext;\n    var C_ = cockpit.gettext;\n\n    var journal = { };\n\n    /**\n     * journalctl([match, ...], [options])\n     * @match: any number of journal match strings\n     * @options: an object containing further options\n     *\n     * Load and (by default) stream journal entries as\n     * json objects. This function returns a jQuery deferred\n     * object which delivers the various journal entries.\n     *\n     * The various @match strings are journalctl matches.\n     * Zero, one or more can be specified. They must be in\n     * string format, or arrays of strings.\n     *\n     * The optional @options object can contain the following:\n     *  * \"host\": the host to load journal from\n     *  * \"count\": number of entries to load and/or pre-stream.\n     *    Default is 10\n     *  * \"follow\": if set to false just load entries and don't\n     *    stream further journal data. Default is true.\n     *  * \"directory\": optional directory to load journal files\n     *  * \"boot\": when set only list entries from this specific\n     *    boot id, or if null then the current boot.\n     *  * \"since\": if specified list entries since the date/time\n     *  * \"until\": if specified list entries until the date/time\n     *  * \"cursor\": a cursor to start listing entries from\n     *  * \"after\": a cursor to start listing entries after\n     *\n     * Returns a jQuery deferred promise. You can call these\n     * functions on the deferred to handle the responses. Note that\n     * there are additional non-jQuery methods.\n     *\n     *  .done(function(entries) { }): Called when done, @entries is\n     *         an array of all journal entries loaded. If .stream()\n     *         has been invoked then @entries will be empty.\n     *  .fail(funciton(ex) { }): called if the operation fails\n     *  .stream(function(entries) { }): called when we receive entries\n     *         entries. Called once per batch of journal @entries,\n     *         whether following or not.\n     *  .stop(): stop following or retrieving entries.\n     */\n\n    journal.journalctl = function journalctl(/* ... */) {\n        var matches = [];\n        var i, arg, options = { follow: true };\n        for (i = 0; i < arguments.length; i++) {\n            arg = arguments[i];\n            if (typeof arg == \"string\") {\n                matches.push(arg);\n            } else if (typeof arg == \"object\") {\n                if (arg instanceof Array) {\n                    matches.push.apply(matches, arg);\n                } else {\n                    cockpit.extend(options, arg);\n                    break;\n                }\n            } else {\n                console.warn(\"journal.journalctl called with invalid argument:\", arg);\n            }\n        }\n\n        if (options.count === undefined) {\n            if (options.follow)\n                options.count = 10;\n            else\n                options.count = null;\n        }\n\n        var cmd = [ \"journalctl\", \"-q\", \"--output=json\" ];\n        if (!options.count)\n            cmd.push(\"--no-tail\");\n        else\n            cmd.push(\"--lines=\" + options.count);\n        if (options.directory)\n            cmd.push(\"--directory=\" + options.directory);\n        if (options.boot)\n            cmd.push(\"--boot=\" + options.boot);\n        else if (options.boot !== undefined)\n            cmd.push(\"--boot\");\n        if (options.since)\n            cmd.push(\"--since=\" + options.since);\n        if (options.until)\n            cmd.push(\"--until=\" + options.until);\n        if (options.cursor)\n            cmd.push(\"--cursor=\" + options.cursor);\n        if (options.after)\n            cmd.push(\"--after=\" + options.after);\n\n        /* journalctl doesn't allow reverse and follow together */\n        if (options.reverse)\n            cmd.push(\"--reverse\");\n        else if (options.follow)\n            cmd.push(\"--follow\");\n\n        cmd.push(\"--\");\n        cmd.push.apply(cmd, matches);\n\n        var dfd = new cockpit.defer();\n        var promise;\n        var buffer = \"\";\n        var entries = [];\n        var streamers = [];\n        var interval = null;\n\n        function fire_streamers() {\n            var ents, i;\n            if (streamers.length && entries.length > 0) {\n                ents = entries;\n                entries = [];\n                for (i = 0; i < streamers.length; i++)\n                    streamers[i].apply(promise, [ents]);\n            } else {\n                window.clearInterval(interval);\n                interval = null;\n            }\n        }\n\n        var proc = cockpit.spawn(cmd, { host: options.host, batch: 8192, latency: 300, superuser: \"try\" }).\n            stream(function(data) {\n\n                if (buffer)\n                    data = buffer + data;\n                buffer = \"\";\n\n                var lines = data.split(\"\\n\");\n                var last = lines.length - 1;\n                lines.forEach(function(line, i) {\n                    if (i == last) {\n                        buffer = line;\n                    } else if (line && line.indexOf(\"-- \") !== 0) {\n                        try {\n                            entries.push(JSON.parse(line));\n                        } catch (e) {\n                            console.warn(e, line);\n                        }\n                    }\n                });\n\n                if (streamers.length && interval === null)\n                    interval = window.setInterval(fire_streamers, 300);\n            }).\n            done(function() {\n                fire_streamers();\n                dfd.resolve(entries);\n            }).\n            fail(function(ex) {\n                /* The journalctl command fails when no entries are matched\n                 * so we just ignore this status code */\n                if (ex.problem == \"cancelled\" ||\n                    ex.exit_status === 1) {\n                    fire_streamers();\n                    dfd.resolve(entries);\n                } else {\n                    dfd.reject(ex);\n                }\n            }).\n            always(function() {\n                window.clearInterval(interval);\n            });\n\n        promise = dfd.promise();\n        promise.stream = function stream(callback) {\n            streamers.push(callback);\n            return this;\n        };\n        promise.stop = function stop() {\n            proc.close(\"cancelled\");\n        };\n        return promise;\n    };\n\n    journal.printable = function printable(value) {\n        if (value === undefined || value === null)\n            return _(\"[no data]\");\n        else if (typeof(value) == \"string\")\n            return value;\n        else if (value.length !== undefined)\n            return cockpit.format(_(\"[$0 bytes of binary data]\"), value.length);\n        else\n            return _(\"[binary data]\");\n    };\n\n    function output_funcs_for_box(box) {\n        /* Dereference any jQuery object here */\n        if (box.jquery)\n            box = box[0];\n\n        Mustache.parse(day_header_template);\n        Mustache.parse(line_template);\n        Mustache.parse(reboot_template);\n\n        function render_line(ident, prio, message, count, time, entry) {\n            var parts = {\n                    'cursor': entry[\"__CURSOR\"],\n                    'time': time,\n                    'message': message,\n                    'service': ident\n                };\n            if (count > 1)\n                parts['count'] = count;\n            if (ident === 'abrt-notification') {\n                parts['problem'] = true;\n                parts['service'] = entry['PROBLEM_BINARY'];\n            }\n            else if (prio < 4)\n                parts['warning'] = true;\n            return Mustache.render(line_template, parts);\n        }\n\n        var reboot = _(\"Reboot\");\n        var reboot_line = Mustache.render(reboot_template, {'message': reboot} );\n\n        function render_reboot_separator() {\n            return reboot_line;\n        }\n\n        function render_day_header(day) {\n            return Mustache.render(day_header_template, {'day': day} );\n        }\n\n        function parse_html(string) {\n            var div = document.createElement(\"div\");\n            div.innerHTML = string.trim();\n            return div.children[0];\n        }\n\n        return {\n            render_line: render_line,\n            render_day_header: render_day_header,\n            render_reboot_separator: render_reboot_separator,\n\n            append: function(elt) {\n                if (typeof (elt) == \"string\")\n                    elt = parse_html(elt);\n                box.appendChild(elt);\n            },\n            prepend: function(elt) {\n                if (typeof (elt) == \"string\")\n                    elt = parse_html(elt);\n                if (box.firstChild)\n                    box.insertBefore(elt, box.firstChild);\n                else\n                    box.appendChild(elt);\n            },\n            remove_last: function() {\n                if (box.lastChild)\n                    box.removeChild(box.lastChild);\n            },\n            remove_first: function() {\n                if (box.firstChild)\n                    box.removeChild(box.firstChild);\n            },\n        };\n    }\n\n    var month_names = [\n        C_(\"month-name\", 'January'),\n        C_(\"month-name\", 'February'),\n        C_(\"month-name\", 'March'),\n        C_(\"month-name\", 'April'),\n        C_(\"month-name\", 'May'),\n        C_(\"month-name\", 'June'),\n        C_(\"month-name\", 'July'),\n        C_(\"month-name\", 'August'),\n        C_(\"month-name\", 'September'),\n        C_(\"month-name\", 'October'),\n        C_(\"month-name\", 'November'),\n        C_(\"month-name\", 'December')\n    ];\n\n    /* Render the journal entries by passing suitable HTML strings back to\n       the caller via the 'output_funcs'.\n\n       Rendering is context aware.  It will insert 'reboot' markers, for\n       example, and collapse repeated lines.  You can extend the output at\n       the bottom and also at the top.\n\n       A new renderer is created by calling 'journal.renderer' like\n       so:\n\n          var renderer = journal.renderer(funcs);\n\n       You can feed new entries into the renderer by calling various\n       methods on the returned object:\n\n          - renderer.append(journal_entry)\n          - renderer.append_flush()\n          - renderer.prepend(journal_entry)\n          - renderer.prepend_flush()\n\n       A 'journal_entry' is one element of the result array returned by a\n       call to 'Query' with the 'cockpit.journal_fields' as the fields to\n       return.\n\n       Calling 'append' will append the given entry to the end of the\n       output, naturally, and 'prepend' will prepend it to the start.\n\n       The output might lag behind what has been input via 'append' and\n       'prepend', and you need to call 'append_flush' and 'prepend_flush'\n       respectively to ensure that the output is up-to-date.  Flushing a\n       renderer does not introduce discontinuities into the output.  You\n       can continue to feed entries into the renderer after flushing and\n       repeated lines will be correctly collapsed across the flush, for\n       example.\n\n       The renderer will call methods of the 'output_funcs' object to\n       produce the desired output:\n\n          - output_funcs.append(rendered)\n          - output_funcs.remove_last()\n          - output_funcs.prepend(rendered)\n          - output_funcs.remove_first()\n\n       The 'rendered' argument is the return value of one of the rendering\n       functions described below.  The 'append' and 'prepend' methods\n       should add this element to the output, naturally, and 'remove_last'\n       and 'remove_first' should remove the indicated element.\n\n       If you never call 'prepend' on the renderer, 'output_func.prepend'\n       isn't called either.  If you never call 'renderer.prepend' after\n       'renderer.prepend_flush', then 'output_func.remove_first' will\n       never be called.  The same guarantees exist for the 'append' family\n       of functions.\n\n       The actual rendering is also done by calling methods on\n       'output_funcs':\n\n          - output_funcs.render_line(ident, prio, message, count, time, cursor)\n          - output_funcs.render_day_header(day)\n          - output_funcs.render_reboot_separator()\n\n    */\n\n    journal.renderer = function renderer(funcs_or_box) {\n        var output_funcs;\n        if (funcs_or_box.render_line)\n            output_funcs = funcs_or_box;\n        else\n            output_funcs = output_funcs_for_box(funcs_or_box);\n\n        function copy_object(o) {\n            var c = { }; for(var p in o) c[p] = o[p]; return c;\n        }\n\n        // A 'entry' object describes a journal entry in formatted form.\n        // It has fields 'bootid', 'ident', 'prio', 'message', 'time',\n        // 'day', all of which are strings.\n\n        function format_entry(journal_entry) {\n            function pad(n) {\n                var str = n.toFixed();\n                if(str.length == 1)\n                    str = '0' + str;\n                return str;\n            }\n\n            var d = new Date(journal_entry[\"__REALTIME_TIMESTAMP\"] / 1000);\n            return {\n                cursor: journal_entry[\"__CURSOR\"],\n                full: journal_entry,\n                day: month_names[d.getMonth()] + ' ' + d.getDate().toFixed() + ', ' + d.getFullYear().toFixed(),\n                time: pad(d.getHours()) + ':' + pad(d.getMinutes()),\n                bootid: journal_entry[\"_BOOT_ID\"],\n                ident: journal_entry[\"SYSLOG_IDENTIFIER\"] || journal_entry[\"_COMM\"],\n                prio: journal_entry[\"PRIORITY\"],\n                message: journal.printable(journal_entry[\"MESSAGE\"])\n            };\n        }\n\n        function entry_is_equal(a, b) {\n            return (a && b &&\n                    a.day == b.day &&\n                    a.bootid == b.bootid &&\n                    a.ident == b.ident &&\n                    a.prio == b.prio &&\n                    a.message == b.message);\n        }\n\n        // A state object describes a line that should be eventually\n        // output.  It has an 'entry' field as per description above, and\n        // also 'count', 'last_time', and 'first_time', which record\n        // repeated entries.  Additionally:\n        //\n        // line_present: When true, the line has been output already with\n        //     some preliminary data.  It needs to be removed before\n        //     outputting more recent data.\n        //\n        // header_present: The day header has been output preliminarily\n        //     before the actual log lines.  It needs to be removed before\n        //     prepending more lines.  If both line_present and\n        //     header_present are true, then the header comes first in the\n        //     output, followed by the line.\n\n        function render_state_line(state) {\n            return output_funcs.render_line(state.entry.ident,\n                                            state.entry.prio,\n                                            state.entry.message,\n                                            state.count,\n                                            state.last_time,\n                                            state.entry.full);\n        }\n\n        // We keep the state of the first and last journal lines,\n        // respectively, in order to collapse repeated lines, and to\n        // insert reboot markers and day headers.\n        //\n        // Normally, there are two state objects, but if only a single\n        // line has been output so far, top_state and bottom_state point\n        // to the same object.\n\n        var top_state, bottom_state;\n\n        top_state = bottom_state = { };\n\n        function start_new_line() {\n            // If we now have two lines, split the state\n            if (top_state === bottom_state && top_state.entry) {\n                top_state = copy_object(bottom_state);\n            }\n        }\n\n        function top_output() {\n            if (top_state.header_present) {\n                output_funcs.remove_first();\n                top_state.header_present = false;\n            }\n            if (top_state.line_present) {\n                output_funcs.remove_first();\n                top_state.line_present = false;\n            }\n            if (top_state.entry) {\n                output_funcs.prepend(render_state_line(top_state));\n                top_state.line_present = true;\n            }\n        }\n\n        function prepend(journal_entry) {\n            var entry = format_entry(journal_entry);\n\n            if (entry_is_equal(top_state.entry, entry)) {\n                top_state.count += 1;\n                top_state.first_time = entry.time;\n            } else {\n                top_output();\n\n                if (top_state.entry) {\n                    if (entry.bootid != top_state.entry.bootid)\n                        output_funcs.prepend(output_funcs.render_reboot_separator());\n                    if (entry.day != top_state.entry.day)\n                        output_funcs.prepend(output_funcs.render_day_header(top_state.entry.day));\n                }\n\n                start_new_line();\n                top_state.entry = entry;\n                top_state.count = 1;\n                top_state.first_time = top_state.last_time = entry.time;\n                top_state.line_present = false;\n            }\n        }\n\n        function prepend_flush() {\n            top_output();\n            if (top_state.entry) {\n                output_funcs.prepend(output_funcs.render_day_header(top_state.entry.day));\n                top_state.header_present = true;\n            }\n        }\n\n        function bottom_output() {\n            if (bottom_state.line_present) {\n                output_funcs.remove_last();\n                bottom_state.line_present = false;\n            }\n            if (bottom_state.entry) {\n                output_funcs.append(render_state_line(bottom_state));\n                bottom_state.line_present = true;\n            }\n        }\n\n        function append(journal_entry) {\n            var entry = format_entry(journal_entry);\n\n            if (entry_is_equal(bottom_state.entry, entry)) {\n                bottom_state.count += 1;\n                bottom_state.last_time = entry.time;\n            } else {\n                bottom_output();\n\n                if (!bottom_state.entry || entry.day != bottom_state.entry.day) {\n                    output_funcs.append(output_funcs.render_day_header(entry.day));\n                    bottom_state.header_present = true;\n                }\n                if (bottom_state.entry && entry.bootid != bottom_state.entry.bootid)\n                    output_funcs.append(output_funcs.render_reboot_separator());\n\n                start_new_line();\n                bottom_state.entry = entry;\n                bottom_state.count = 1;\n                bottom_state.first_time = bottom_state.last_time = entry.time;\n                bottom_state.line_present = false;\n            }\n        }\n\n        function append_flush() {\n            bottom_output();\n        }\n\n        return { prepend: prepend,\n                 prepend_flush: prepend_flush,\n                 append: append,\n                 append_flush: append_flush\n               };\n    };\n\n    journal.logbox = function logbox(match, max_entries) {\n        var entries = [ ];\n        var box = document.createElement(\"div\");\n\n        function render() {\n            var renderer = journal.renderer(box);\n            while(box.firstChild)\n                box.removeChild(box.firstChild);\n            for (var i = 0; i < entries.length; i++) {\n                renderer.prepend(entries[i]);\n            }\n            renderer.prepend_flush();\n            if (entries.length > 0)\n                box.removeAttribute(\"hidden\");\n            else\n                box.setAttribute(\"hidden\", \"hidden\");\n        }\n\n        render();\n\n        var promise = journal.journalctl(match, { count: max_entries }).\n            stream(function(tail) {\n                entries = entries.concat(tail);\n                if (entries.length > max_entries)\n                    entries = entries.slice(-max_entries);\n                render();\n            }).\n            fail(function(error) {\n                box.appendChild(document.createTextNode(error.message));\n                box.removeAttribute(\"hidden\");\n            });\n\n        /* Both a DOM element and a promise */\n        return promise.promise(box);\n    };\n\n    module.exports = journal;\n}());\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../pkg/lib/journal.js\n// module id = 4\n// module chunks = 0 1","'use strict';\n\n/*\n * This file is part of Cockpit.\n *\n * Copyright (C) 2016 Red Hat, Inc.\n *\n * Cockpit is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * Cockpit is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n */\n\nvar cockpit = require(\"cockpit\");\nvar mustache = require(\"mustache/mustache\");\n\n/*\n * Turns a mustache template into a translated mustache template\n * by preparsing it and translating it.\n */\nvar cache = { };\n\nfunction translate(template) {\n    if (template in cache)\n        return cache[template];\n    var div = document.createElement(\"div\");\n    div.innerHTML = template;\n    cockpit.translate(div);\n    var result = div.innerHTML;\n    cache[template] = result;\n    return result;\n}\n\n/* Just like the mustache object, except for translated */\nmodule.exports = cockpit.extend({ }, mustache, {\n    render: function render(template, view, partials) {\n        return translate(mustache.render(template, view, partials));\n    },\n    to_html: function to_html(template, view, partials, send) {\n        return translate(mustache.to_html(template, view, partials, send));\n    },\n    clearCache: function clearCache() {\n        cache = { };\n        return mustache.clearCache();\n    }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../pkg/lib/mustache.js\n// module id = 5\n// module chunks = 0 1 2","/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false*/\n\n(function (root, factory) {\n  if (typeof exports === \"object\" && exports) {\n    factory(exports); // CommonJS\n  } else {\n    var mustache = {};\n    factory(mustache);\n    if (typeof define === \"function\" && define.amd) {\n      define(mustache); // AMD\n    } else {\n      root.Mustache = mustache; // <script>\n    }\n  }\n}(this, function (mustache) {\n\n  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n  var RegExp_test = RegExp.prototype.test;\n  function testRegExp(re, string) {\n    return RegExp_test.call(re, string);\n  }\n\n  var nonSpaceRe = /\\S/;\n  function isWhitespace(string) {\n    return !testRegExp(nonSpaceRe, string);\n  }\n\n  var Object_toString = Object.prototype.toString;\n  var isArray = Array.isArray || function (object) {\n    return Object_toString.call(object) === '[object Array]';\n  };\n\n  function isFunction(object) {\n    return typeof object === 'function';\n  }\n\n  function escapeRegExp(string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n  }\n\n  var entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    \"/\": '&#x2F;'\n  };\n\n  function escapeHtml(string) {\n    return String(string).replace(/[&<>\"'\\/]/g, function (s) {\n      return entityMap[s];\n    });\n  }\n\n  function escapeTags(tags) {\n    if (!isArray(tags) || tags.length !== 2) {\n      throw new Error('Invalid tags: ' + tags);\n    }\n\n    return [\n      new RegExp(escapeRegExp(tags[0]) + \"\\\\s*\"),\n      new RegExp(\"\\\\s*\" + escapeRegExp(tags[1]))\n    ];\n  }\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var equalsRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n  /**\n   * Breaks up the given `template` string into a tree of tokens. If the `tags`\n   * argument is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n   * course, the default is to use mustaches (i.e. mustache.tags).\n   *\n   * A token is an array with at least 4 elements. The first element is the\n   * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n   * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n   * all text that appears outside a symbol this element is \"text\".\n   *\n   * The second element of a token is its \"value\". For mustache tags this is\n   * whatever else was inside the tag besides the opening symbol. For text tokens\n   * this is the text itself.\n   *\n   * The third and fourth elements of the token are the start and end indices,\n   * respectively, of the token in the original template.\n   *\n   * Tokens that are the root node of a subtree contain two more elements: 1) an\n   * array of tokens in the subtree and 2) the index in the original template at\n   * which the closing tag for that section begins.\n   */\n  function parseTemplate(template, tags) {\n    tags = tags || mustache.tags;\n    template = template || '';\n\n    if (typeof tags === 'string') {\n      tags = tags.split(spaceRe);\n    }\n\n    var tagRes = escapeTags(tags);\n    var scanner = new Scanner(template);\n\n    var sections = [];     // Stack to hold section tokens\n    var tokens = [];       // Buffer to hold the tokens\n    var spaces = [];       // Indices of whitespace tokens on the current line\n    var hasTag = false;    // Is there a {{tag}} on the current line?\n    var nonSpace = false;  // Is there a non-space char on the current line?\n\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace() {\n      if (hasTag && !nonSpace) {\n        while (spaces.length) {\n          delete tokens[spaces.pop()];\n        }\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var start, type, value, chr, token, openSection;\n    while (!scanner.eos()) {\n      start = scanner.pos;\n\n      // Match any text between tags.\n      value = scanner.scanUntil(tagRes[0]);\n      if (value) {\n        for (var i = 0, len = value.length; i < len; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push(['text', chr, start, start + 1]);\n          start += 1;\n\n          // Check for whitespace on the current line.\n          if (chr === '\\n') {\n            stripSpace();\n          }\n        }\n      }\n\n      // Match the opening tag.\n      if (!scanner.scan(tagRes[0])) break;\n      hasTag = true;\n\n      // Get the tag type.\n      type = scanner.scan(tagRe) || 'name';\n      scanner.scan(whiteRe);\n\n      // Get the tag value.\n      if (type === '=') {\n        value = scanner.scanUntil(equalsRe);\n        scanner.scan(equalsRe);\n        scanner.scanUntil(tagRes[1]);\n      } else if (type === '{') {\n        value = scanner.scanUntil(new RegExp('\\\\s*' + escapeRegExp('}' + tags[1])));\n        scanner.scan(curlyRe);\n        scanner.scanUntil(tagRes[1]);\n        type = '&';\n      } else {\n        value = scanner.scanUntil(tagRes[1]);\n      }\n\n      // Match the closing tag.\n      if (!scanner.scan(tagRes[1])) {\n        throw new Error('Unclosed tag at ' + scanner.pos);\n      }\n\n      token = [ type, value, start, scanner.pos ];\n      tokens.push(token);\n\n      if (type === '#' || type === '^') {\n        sections.push(token);\n      } else if (type === '/') {\n        // Check section nesting.\n        openSection = sections.pop();\n\n        if (!openSection) {\n          throw new Error('Unopened section \"' + value + '\" at ' + start);\n        }\n        if (openSection[1] !== value) {\n          throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n        }\n      } else if (type === 'name' || type === '{' || type === '&') {\n        nonSpace = true;\n      } else if (type === '=') {\n        // Set the tags for the next time around.\n        tagRes = escapeTags(tags = value.split(spaceRe));\n      }\n    }\n\n    // Make sure there are no open sections when we're done.\n    openSection = sections.pop();\n    if (openSection) {\n      throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n    }\n\n    return nestTokens(squashTokens(tokens));\n  }\n\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n  function squashTokens(tokens) {\n    var squashedTokens = [];\n\n    var token, lastToken;\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n\n      if (token) {\n        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n          lastToken[1] += token[1];\n          lastToken[3] = token[3];\n        } else {\n          squashedTokens.push(token);\n          lastToken = token;\n        }\n      }\n    }\n\n    return squashedTokens;\n  }\n\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have two additional items: 1) an array of\n   * all tokens that appear in that section and 2) the index in the original\n   * template that represents the end of that section.\n   */\n  function nestTokens(tokens) {\n    var nestedTokens = [];\n    var collector = nestedTokens;\n    var sections = [];\n\n    var token, section;\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n\n      switch (token[0]) {\n      case '#':\n      case '^':\n        collector.push(token);\n        sections.push(token);\n        collector = token[4] = [];\n        break;\n      case '/':\n        section = sections.pop();\n        section[5] = token[2];\n        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n        break;\n      default:\n        collector.push(token);\n      }\n    }\n\n    return nestedTokens;\n  }\n\n  /**\n   * A simple string scanner that is used by the template parser to find\n   * tokens in template strings.\n   */\n  function Scanner(string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n  Scanner.prototype.eos = function () {\n    return this.tail === \"\";\n  };\n\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n  Scanner.prototype.scan = function (re) {\n    var match = this.tail.match(re);\n\n    if (match && match.index === 0) {\n      var string = match[0];\n      this.tail = this.tail.substring(string.length);\n      this.pos += string.length;\n      return string;\n    }\n\n    return \"\";\n  };\n\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n  Scanner.prototype.scanUntil = function (re) {\n    var index = this.tail.search(re), match;\n\n    switch (index) {\n    case -1:\n      match = this.tail;\n      this.tail = \"\";\n      break;\n    case 0:\n      match = \"\";\n      break;\n    default:\n      match = this.tail.substring(0, index);\n      this.tail = this.tail.substring(index);\n    }\n\n    this.pos += match.length;\n\n    return match;\n  };\n\n  /**\n   * Represents a rendering context by wrapping a view object and\n   * maintaining a reference to the parent context.\n   */\n  function Context(view, parentContext) {\n    this.view = view == null ? {} : view;\n    this.cache = { '.': this.view };\n    this.parent = parentContext;\n  }\n\n  /**\n   * Creates a new context using the given view with this context\n   * as the parent.\n   */\n  Context.prototype.push = function (view) {\n    return new Context(view, this);\n  };\n\n  /**\n   * Returns the value of the given name in this context, traversing\n   * up the context hierarchy if the value is absent in this context's view.\n   */\n  Context.prototype.lookup = function (name) {\n    var value;\n    if (name in this.cache) {\n      value = this.cache[name];\n    } else {\n      var context = this;\n\n      while (context) {\n        if (name.indexOf('.') > 0) {\n          value = context.view;\n\n          var names = name.split('.'), i = 0;\n          while (value != null && i < names.length) {\n            value = value[names[i++]];\n          }\n        } else {\n          value = context.view[name];\n        }\n\n        if (value != null) break;\n\n        context = context.parent;\n      }\n\n      this.cache[name] = value;\n    }\n\n    if (isFunction(value)) {\n      value = value.call(this.view);\n    }\n\n    return value;\n  };\n\n  /**\n   * A Writer knows how to take a stream of tokens and render them to a\n   * string, given a context. It also maintains a cache of templates to\n   * avoid the need to parse the same template twice.\n   */\n  function Writer() {\n    this.cache = {};\n  }\n\n  /**\n   * Clears all cached templates in this writer.\n   */\n  Writer.prototype.clearCache = function () {\n    this.cache = {};\n  };\n\n  /**\n   * Parses and caches the given `template` and returns the array of tokens\n   * that is generated from the parse.\n   */\n  Writer.prototype.parse = function (template, tags) {\n    var cache = this.cache;\n    var tokens = cache[template];\n\n    if (tokens == null) {\n      tokens = cache[template] = parseTemplate(template, tags);\n    }\n\n    return tokens;\n  };\n\n  /**\n   * High-level method that is used to render the given `template` with\n   * the given `view`.\n   *\n   * The optional `partials` argument may be an object that contains the\n   * names and templates of partials that are used in the template. It may\n   * also be a function that is used to load partial templates on the fly\n   * that takes a single argument: the name of the partial.\n   */\n  Writer.prototype.render = function (template, view, partials) {\n    var tokens = this.parse(template);\n    var context = (view instanceof Context) ? view : new Context(view);\n    return this.renderTokens(tokens, context, partials, template);\n  };\n\n  /**\n   * Low-level method that renders the given array of `tokens` using\n   * the given `context` and `partials`.\n   *\n   * Note: The `originalTemplate` is only ever used to extract the portion\n   * of the original template that was contained in a higher-order section.\n   * If the template doesn't use higher-order sections, this argument may\n   * be omitted.\n   */\n  Writer.prototype.renderTokens = function (tokens, context, partials, originalTemplate) {\n    var buffer = '';\n\n    // This function is used to render an arbitrary template\n    // in the current context by higher-order sections.\n    var self = this;\n    function subRender(template) {\n      return self.render(template, context, partials);\n    }\n\n    var token, value;\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n\n      switch (token[0]) {\n      case '#':\n        value = context.lookup(token[1]);\n        if (!value) continue;\n\n        if (isArray(value)) {\n          for (var j = 0, jlen = value.length; j < jlen; ++j) {\n            buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);\n          }\n        } else if (typeof value === 'object' || typeof value === 'string') {\n          buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);\n        } else if (isFunction(value)) {\n          if (typeof originalTemplate !== 'string') {\n            throw new Error('Cannot use higher-order sections without the original template');\n          }\n\n          // Extract the portion of the original template that the section contains.\n          value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n\n          if (value != null) buffer += value;\n        } else {\n          buffer += this.renderTokens(token[4], context, partials, originalTemplate);\n        }\n\n        break;\n      case '^':\n        value = context.lookup(token[1]);\n\n        // Use JavaScript's definition of falsy. Include empty arrays.\n        // See https://github.com/janl/mustache.js/issues/186\n        if (!value || (isArray(value) && value.length === 0)) {\n          buffer += this.renderTokens(token[4], context, partials, originalTemplate);\n        }\n\n        break;\n      case '>':\n        if (!partials) continue;\n        value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n        if (value != null) buffer += this.renderTokens(this.parse(value), context, partials, value);\n        break;\n      case '&':\n        value = context.lookup(token[1]);\n        if (value != null) buffer += value;\n        break;\n      case 'name':\n        value = context.lookup(token[1]);\n        if (value != null) buffer += mustache.escape(value);\n        break;\n      case 'text':\n        buffer += token[1];\n        break;\n      }\n    }\n\n    return buffer;\n  };\n\n  mustache.name = \"mustache.js\";\n  mustache.version = \"0.8.1\";\n  mustache.tags = [ \"{{\", \"}}\" ];\n\n  // All high-level mustache.* functions use this writer.\n  var defaultWriter = new Writer();\n\n  /**\n   * Clears all cached templates in the default writer.\n   */\n  mustache.clearCache = function () {\n    return defaultWriter.clearCache();\n  };\n\n  /**\n   * Parses and caches the given template in the default writer and returns the\n   * array of tokens it contains. Doing this ahead of time avoids the need to\n   * parse templates on the fly as they are rendered.\n   */\n  mustache.parse = function (template, tags) {\n    return defaultWriter.parse(template, tags);\n  };\n\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n  mustache.render = function (template, view, partials) {\n    return defaultWriter.render(template, view, partials);\n  };\n\n  // This is here for backwards compatibility with 0.4.x.\n  mustache.to_html = function (template, view, partials, send) {\n    var result = mustache.render(template, view, partials);\n\n    if (isFunction(send)) {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n  // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n  mustache.escape = escapeHtml;\n\n  // Export these mainly for testing, but also for advanced usage.\n  mustache.Scanner = Scanner;\n  mustache.Context = Context;\n  mustache.Writer = Writer;\n\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/mustache/mustache.js\n// module id = 6\n// module chunks = 0 1 2","module.exports = \"<div class=\\\"panel-heading\\\">{{day}}</div>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/raw-loader!../pkg/lib/journal_day_header.mustache\n// module id = 7\n// module chunks = 0 1","module.exports = \"<div class=\\\"cockpit-logline\\\" data-cursor=\\\"{{cursor}}\\\">\\n  <div class=\\\"cockpit-log-warning\\\">{{#warning}}\\n    <i class=\\\"fa fa-exclamation-triangle\\\"></i>\\n  {{/warning}}{{#problem}}\\n    <i class=\\\"fa fa-times-circle-o\\\"></i>\\n  {{/problem}}\\n  </div>\\n  <div class=\\\"cockpit-log-time\\\">{{time}}</div>\\n  <span class=\\\"cockpit-log-message\\\">{{message}}</span>\\n  {{! if we have count (repeated messages), show service name and badge - otherwise just the service }}\\n  {{#count}}\\n  <div class=\\\"cockpit-log-service-container\\\">\\n    <div class=\\\"cockpit-log-service-reduced\\\">{{service}}</div>\\n    <span class=\\\"badge\\\">{{count}}&#160;<i class=\\\"fa fa-caret-right\\\"></i></span>\\n  </div>\\n  {{/count}}{{^count}}\\n  <div class=\\\"cockpit-log-service\\\">{{service}}</div>\\n  {{/count}}\\n</div>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/raw-loader!../pkg/lib/journal_line.mustache\n// module id = 8\n// module chunks = 0 1","module.exports = \"<div class=\\\"cockpit-logline\\\">\\n  {{! placeholders for correct message alignment }}\\n  <div class=\\\"cockpit-log-warning\\\"></div>\\n  <span class=\\\"cockpit-log-message cockpit-logmsg-reboot\\\">{{message}}</span>\\n</div>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/raw-loader!../pkg/lib/journal_reboot.mustache\n// module id = 9\n// module chunks = 0 1"],"sourceRoot":""}