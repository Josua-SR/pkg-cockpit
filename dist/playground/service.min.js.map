{"version":3,"sources":["webpack:///playground/service.min.js","webpack:///webpack/bootstrap c07ace068123c6158792?3781*****","webpack:///external \"cockpit\"?478e*****","webpack:///external \"jQuery\"?0cb8***","webpack:///../pkg/playground/service.js","webpack:///../pkg/lib/service.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","0","2","cockpit","4","jQuery","42","$","service","navigate","show","s","t","text","JSON","stringify","proxy","location","path","on","b","fail","error","console","43","wait_valid","callback","wait","valid","with_systemd_manager","done","systemd_manager","systemd_client","dbus","superuser","Subscribe","name","warn","update_from_unit","self","exists","unit","LoadState","ActiveState","state","undefined","UnitFileState","enabled","dispatchEvent","wait_callbacks","resolve","update_from_service","refresh","refresh_interface","iface","log","result","props","v","ifaces","data","notify","on_job_new_removed_refresh","event","number","unit_id","promise","then","call_manager","method","args","call_manager_with_job","dfd","defer","results","pending_jobs","reject","call_manager_with_reload","start","stop","restart","tryRestart","enable","disable","event_target","indexOf","LoadUnit","addEventListener","reloading"],"mappings":"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","file":"playground/service.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(42);\n\n\n/***/ },\n\n/***/ 2:\n/***/ function(module, exports) {\n\n\tmodule.exports = cockpit;\n\n/***/ },\n\n/***/ 4:\n/***/ function(module, exports) {\n\n\tmodule.exports = jQuery;\n\n/***/ },\n\n/***/ 42:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\"use strict\";\n\t\n\t(function () {\n\t    \"use strict\";\n\t\n\t    var $ = __webpack_require__(4);\n\t    var cockpit = __webpack_require__(2);\n\t\n\t    var service = __webpack_require__(43);\n\t\n\t    $(function () {\n\t        var proxy;\n\t\n\t        function navigate() {\n\t            proxy = service.proxy(cockpit.location.path[0] || \"\");\n\t\n\t            function show() {\n\t                function s(t) {\n\t                    $('#' + t).text(JSON.stringify(proxy[t]));\n\t                }\n\t                s('exists');\n\t                s('state');\n\t                s('enabled');\n\t            }\n\t\n\t            $(proxy).on('changed', show);\n\t            show();\n\t\n\t            $(\"body\").show();\n\t        }\n\t\n\t        function b(t) {\n\t            $('#' + t).on('click', function () {\n\t                proxy[t]().fail(function (error) {\n\t                    console.error(\"action\", t, \"failed:\", JSON.stringify(error));\n\t                });\n\t            });\n\t        }\n\t\n\t        b('start');\n\t        b('stop');\n\t        b('enable');\n\t        b('disable');\n\t\n\t        $(cockpit).on('locationchanged', navigate);\n\t        navigate();\n\t    });\n\t})();\n\n/***/ },\n\n/***/ 43:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\"use strict\";\n\t\n\t(function () {\n\t    \"use strict\";\n\t\n\t    var cockpit = __webpack_require__(2);\n\t\n\t    /* SERVICE MANAGEMENT API\n\t     *\n\t     * The \"service\" module lets you monitor and manage a\n\t     * system service on localhost in a simple way.\n\t     *\n\t     * It mainly exists because talking to the systemd D-Bus API is\n\t     * not trivial enough to do it directly.\n\t     *\n\t     * - proxy = service.proxy(name)\n\t     *\n\t     * Create a proxy that represents the service named NAME.\n\t     *\n\t     * The proxy has properties and methods (described below) that\n\t     * allow you to monitor the state of the service, and perform\n\t     * simple actions on it.\n\t     *\n\t     * Initially, any of the properties can be \"null\" until their\n\t     * actual values have been retrieved in the background.\n\t     *\n\t     * - $(proxy).on('changed', function (event) { ... })\n\t     *\n\t     * The 'changed' event is emitted whenever one of the properties\n\t     * of the proxy changes.\n\t     *\n\t     * - proxy.exists\n\t     *\n\t     * A boolean that tells whether the service is known or not.  A\n\t     * proxy with 'exists == false' will have 'state == undefined' and\n\t     * 'enabled == undefined'.\n\t     *\n\t     * - proxy.state\n\t     *\n\t     * Either 'undefined' when the state can't be retrieved, or a\n\t     * string that has one of the values \"starting\", \"running\",\n\t     * \"stopping\", \"stopped\", or \"failed\".\n\t     *\n\t     * - proxy.enabled\n\t     *\n\t     * Either 'undefined' when the value can't be retrieved, or a\n\t     * boolean that tells whether the service is started 'enabled'.\n\t     * What it means exactly for a service to be enabled depends on\n\t     * the service, but a enabled service is usually started on boot,\n\t     * no matter wether other services need it or not.  A disabled\n\t     * service is usually only started when it is needed by some other\n\t     * service.\n\t     *\n\t     * - proxy.unit\n\t     * - proxy.service\n\t     *\n\t     * The raw org.freedesktop.systemd1.Unit and Service D-Bus\n\t     * interface proxies for the service.\n\t     *\n\t     * - promise = proxy.start()\n\t     *\n\t     * Start the service.  The return value is a standard jQuery\n\t     * promise as returned from DBusClient.call.\n\t     *\n\t     * - promise =  proxy.restart()\n\t     *\n\t     * Restart the service.\n\t     *\n\t     * - promise = proxy.tryRestart()\n\t     *\n\t     * Try to restart the service if it's running or starting\n\t     *\n\t     * - promise = proxy.stop()\n\t     *\n\t     * Stop the service.\n\t     *\n\t     * - promise = proxy.enable()\n\t     *\n\t     * Enable the service.\n\t     *\n\t     * - promise = proxy.disable()\n\t     *\n\t     * Disable the service.\n\t     */\n\t\n\t    var systemd_client;\n\t    var systemd_manager;\n\t\n\t    function wait_valid(proxy, callback) {\n\t        proxy.wait(function () {\n\t            if (proxy.valid) callback();\n\t        });\n\t    }\n\t\n\t    function with_systemd_manager(done) {\n\t        if (!systemd_manager) {\n\t            systemd_client = cockpit.dbus(\"org.freedesktop.systemd1\", { superuser: \"try\" });\n\t            systemd_manager = systemd_client.proxy(\"org.freedesktop.systemd1.Manager\", \"/org/freedesktop/systemd1\");\n\t            wait_valid(systemd_manager, function () {\n\t                systemd_manager.Subscribe().fail(function (error) {\n\t                    if (error.name != \"org.freedesktop.systemd1.AlreadySubscribed\" && error.name != \"org.freedesktop.DBus.Error.FileExists\") console.warn(\"Subscribing to systemd signals failed\", error);\n\t                });\n\t            });\n\t        }\n\t        wait_valid(systemd_manager, done);\n\t    }\n\t\n\t    function proxy(name) {\n\t        var self = {\n\t            exists: null,\n\t            state: null,\n\t            enabled: null,\n\t\n\t            wait: wait,\n\t\n\t            start: start,\n\t            stop: stop,\n\t            restart: restart,\n\t            tryRestart: tryRestart,\n\t\n\t            enable: enable,\n\t            disable: disable\n\t        };\n\t\n\t        cockpit.event_target(self);\n\t\n\t        var unit, service;\n\t        var wait_callbacks = cockpit.defer();\n\t\n\t        if (name.indexOf(\".\") == -1) name = name + \".service\";\n\t\n\t        function update_from_unit() {\n\t            self.exists = unit.LoadState != \"not-found\" || unit.ActiveState != \"inactive\";\n\t\n\t            if (unit.ActiveState == \"activating\") self.state = \"starting\";else if (unit.ActiveState == \"deactivating\") self.state = \"stopping\";else if (unit.ActiveState == \"active\" || unit.ActiveState == \"reloading\") self.state = \"running\";else if (unit.ActiveState == \"failed\") self.state = \"failed\";else if (unit.ActiveState == \"inactive\" && self.exists) self.state = \"stopped\";else self.state = undefined;\n\t\n\t            if (unit.UnitFileState == \"enabled\" || unit.UnitFileState == \"linked\") self.enabled = true;else if (unit.UnitFileState == \"disabled\" || unit.UnitFileState == \"masked\") self.enabled = false;else self.enabled = undefined;\n\t\n\t            self.unit = unit;\n\t\n\t            self.dispatchEvent(\"changed\");\n\t            wait_callbacks.resolve();\n\t        }\n\t\n\t        function update_from_service() {\n\t            self.service = service;\n\t            self.dispatchEvent(\"changed\");\n\t        }\n\t\n\t        with_systemd_manager(function () {\n\t            systemd_manager.LoadUnit(name).done(function (path) {\n\t                unit = systemd_client.proxy('org.freedesktop.systemd1.Unit', path);\n\t                unit.addEventListener('changed', update_from_unit);\n\t                wait_valid(unit, update_from_unit);\n\t\n\t                service = systemd_client.proxy('org.freedesktop.systemd1.Service', path);\n\t                service.addEventListener('changed', update_from_service);\n\t                wait_valid(service, update_from_service);\n\t            }).fail(function () {\n\t                self.exists = false;\n\t                self.dispatchEvent('changed');\n\t            });\n\t        });\n\t\n\t        function refresh() {\n\t            if (!unit || !service) return;\n\t\n\t            function refresh_interface(path, iface) {\n\t                systemd_client.call(path, \"org.freedesktop.DBus.Properties\", \"GetAll\", [iface]).fail(function (error) {\n\t                    console.log(error);\n\t                }).done(function (result) {\n\t                    var props = {};\n\t                    for (var p in result[0]) {\n\t                        props[p] = result[0][p].v;\n\t                    }var ifaces = {};\n\t                    ifaces[iface] = props;\n\t                    var data = {};\n\t                    data[unit.path] = ifaces;\n\t                    systemd_client.notify(data);\n\t                });\n\t            }\n\t\n\t            refresh_interface(unit.path, \"org.freedesktop.systemd1.Unit\");\n\t            refresh_interface(service.path, \"org.freedesktop.systemd1.Service\");\n\t        }\n\t\n\t        function on_job_new_removed_refresh(event, number, path, unit_id, result) {\n\t            if (unit_id == name) refresh();\n\t        }\n\t\n\t        /* HACK - https://bugs.freedesktop.org/show_bug.cgi?id=69575\n\t         *\n\t         * We need to explicitly get new property values when getting\n\t         * a UnitNew signal since UnitNew doesn't carry them.\n\t         * However, reacting to UnitNew with GetAll could lead to an\n\t         * infinite loop since systemd emits a UnitNew in reaction to\n\t         * GetAll for units that it doesn't want to keep loaded, such\n\t         * as units without unit files.\n\t         *\n\t         * So we ignore UnitNew and instead assume that the unit state\n\t         * only changes in interesting ways when there is a job for it\n\t         * or when the daemon is reloaded (or when we get a property\n\t         * change notification, of course).\n\t         */\n\t\n\t        // This is what we want to do:\n\t        // systemd_manager.addEventListener(\"UnitNew\", function (event, unit_id, path) {\n\t        //     if (unit_id == name)\n\t        //         refresh();\n\t        // });\n\t\n\t        // This is what we have to do:\n\t        systemd_manager.addEventListener(\"Reloading\", function (event, reloading) {\n\t            if (!reloading) refresh();\n\t        });\n\t\n\t        systemd_manager.addEventListener(\"JobNew\", on_job_new_removed_refresh);\n\t        systemd_manager.addEventListener(\"JobRemoved\", on_job_new_removed_refresh);\n\t\n\t        function wait(callback) {\n\t            wait_callbacks.promise.then(callback);\n\t        }\n\t\n\t        /* Actions\n\t         *\n\t         * We don't call methods on the D-Bus proxies here since they\n\t         * might not be ready when these functions are called.\n\t         */\n\t\n\t        var pending_jobs = {};\n\t\n\t        systemd_manager.addEventListener(\"JobRemoved\", function (event, number, path, unit_id, result) {\n\t            if (pending_jobs[path]) {\n\t                if (result == \"done\") pending_jobs[path].resolve();else pending_jobs[path].reject(result);\n\t                delete pending_jobs[path];\n\t            }\n\t        });\n\t\n\t        function call_manager(method, args) {\n\t            return systemd_client.call(\"/org/freedesktop/systemd1\", \"org.freedesktop.systemd1.Manager\", method, args);\n\t        }\n\t\n\t        function call_manager_with_job(method, args) {\n\t            var dfd = cockpit.defer();\n\t            call_manager(method, args).done(function (results) {\n\t                var path = results[0];\n\t                pending_jobs[path] = dfd;\n\t            }).fail(function (error) {\n\t                dfd.reject(error);\n\t            });\n\t            return dfd.promise();\n\t        }\n\t\n\t        function call_manager_with_reload(method, args) {\n\t            return call_manager(method, args).then(function () {\n\t                var dfd = cockpit.defer();\n\t                call_manager(\"Reload\", []).done(function () {\n\t                    dfd.resolve();\n\t                }).fail(function (error) {\n\t                    // HACK: https://bugzilla.redhat.com/show_bug.cgi?id=1560549\n\t                    // some systemd versions disconnect too fast from the bus\n\t                    if (error.name === \"org.freedesktop.DBus.Error.NoReply\") {\n\t                        refresh();\n\t                        dfd.resolve();\n\t                    } else {\n\t                        dfd.reject(error);\n\t                    }\n\t                });\n\t                return dfd.promise();\n\t            });\n\t        }\n\t\n\t        function start() {\n\t            return call_manager_with_job(\"StartUnit\", [name, \"replace\"]);\n\t        }\n\t\n\t        function stop() {\n\t            return call_manager_with_job(\"StopUnit\", [name, \"replace\"]);\n\t        }\n\t\n\t        function restart() {\n\t            return call_manager_with_job(\"RestartUnit\", [name, \"replace\"]);\n\t        }\n\t\n\t        function tryRestart() {\n\t            return call_manager_with_job(\"TryRestartUnit\", [name, \"replace\"]);\n\t        }\n\t\n\t        function enable() {\n\t            return call_manager_with_reload(\"EnableUnitFiles\", [[name], false, false]);\n\t        }\n\t\n\t        function disable() {\n\t            return call_manager_with_reload(\"DisableUnitFiles\", [[name], false]);\n\t        }\n\t\n\t        return self;\n\t    }\n\t\n\t    module.exports = {\n\t        proxy: proxy\n\t    };\n\t})();\n\n/***/ }\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// playground/service.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c07ace068123c6158792","module.exports = cockpit;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"cockpit\"\n// module id = 2\n// module chunks = 0 1 2 3 4 5 6 7 8 9","module.exports = jQuery;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"jQuery\"\n// module id = 4\n// module chunks = 1 2 3 4 6 8 9","(function() {\n    \"use strict\";\n\n    var $ = require(\"jquery\");\n    var cockpit = require(\"cockpit\");\n\n    var service = require(\"service\");\n\n    $(function() {\n        var proxy;\n\n        function navigate() {\n            proxy = service.proxy(cockpit.location.path[0] || \"\");\n\n            function show() {\n                function s(t) {\n                    $('#' + t).text(JSON.stringify(proxy[t]));\n                }\n                s('exists');\n                s('state');\n                s('enabled');\n            }\n\n            $(proxy).on('changed', show);\n            show();\n\n            $(\"body\").show();\n        }\n\n        function b(t) {\n            $('#' + t).on('click', function () {\n                proxy[t]()\n                        .fail(function (error) {\n                            console.error(\"action\", t, \"failed:\", JSON.stringify(error));\n                        });\n            });\n        }\n\n        b('start');\n        b('stop');\n        b('enable');\n        b('disable');\n\n        $(cockpit).on('locationchanged', navigate);\n        navigate();\n    });\n}());\n\n\n\n// WEBPACK FOOTER //\n// ../pkg/playground/service.js","(function() {\n    \"use strict\";\n\n    var cockpit = require(\"cockpit\");\n\n    /* SERVICE MANAGEMENT API\n     *\n     * The \"service\" module lets you monitor and manage a\n     * system service on localhost in a simple way.\n     *\n     * It mainly exists because talking to the systemd D-Bus API is\n     * not trivial enough to do it directly.\n     *\n     * - proxy = service.proxy(name)\n     *\n     * Create a proxy that represents the service named NAME.\n     *\n     * The proxy has properties and methods (described below) that\n     * allow you to monitor the state of the service, and perform\n     * simple actions on it.\n     *\n     * Initially, any of the properties can be \"null\" until their\n     * actual values have been retrieved in the background.\n     *\n     * - $(proxy).on('changed', function (event) { ... })\n     *\n     * The 'changed' event is emitted whenever one of the properties\n     * of the proxy changes.\n     *\n     * - proxy.exists\n     *\n     * A boolean that tells whether the service is known or not.  A\n     * proxy with 'exists == false' will have 'state == undefined' and\n     * 'enabled == undefined'.\n     *\n     * - proxy.state\n     *\n     * Either 'undefined' when the state can't be retrieved, or a\n     * string that has one of the values \"starting\", \"running\",\n     * \"stopping\", \"stopped\", or \"failed\".\n     *\n     * - proxy.enabled\n     *\n     * Either 'undefined' when the value can't be retrieved, or a\n     * boolean that tells whether the service is started 'enabled'.\n     * What it means exactly for a service to be enabled depends on\n     * the service, but a enabled service is usually started on boot,\n     * no matter wether other services need it or not.  A disabled\n     * service is usually only started when it is needed by some other\n     * service.\n     *\n     * - proxy.unit\n     * - proxy.service\n     *\n     * The raw org.freedesktop.systemd1.Unit and Service D-Bus\n     * interface proxies for the service.\n     *\n     * - promise = proxy.start()\n     *\n     * Start the service.  The return value is a standard jQuery\n     * promise as returned from DBusClient.call.\n     *\n     * - promise =  proxy.restart()\n     *\n     * Restart the service.\n     *\n     * - promise = proxy.tryRestart()\n     *\n     * Try to restart the service if it's running or starting\n     *\n     * - promise = proxy.stop()\n     *\n     * Stop the service.\n     *\n     * - promise = proxy.enable()\n     *\n     * Enable the service.\n     *\n     * - promise = proxy.disable()\n     *\n     * Disable the service.\n     */\n\n    var systemd_client;\n    var systemd_manager;\n\n    function wait_valid(proxy, callback) {\n        proxy.wait(function() {\n            if (proxy.valid)\n                callback();\n        });\n    }\n\n    function with_systemd_manager(done) {\n        if (!systemd_manager) {\n            systemd_client = cockpit.dbus(\"org.freedesktop.systemd1\", { superuser: \"try\" });\n            systemd_manager = systemd_client.proxy(\"org.freedesktop.systemd1.Manager\",\n                                                   \"/org/freedesktop/systemd1\");\n            wait_valid(systemd_manager, function() {\n                systemd_manager.Subscribe()\n                        .fail(function (error) {\n                            if (error.name != \"org.freedesktop.systemd1.AlreadySubscribed\" &&\n                            error.name != \"org.freedesktop.DBus.Error.FileExists\")\n                                console.warn(\"Subscribing to systemd signals failed\", error);\n                        });\n            });\n        }\n        wait_valid(systemd_manager, done);\n    }\n\n    function proxy(name) {\n        var self = {\n            exists: null,\n            state: null,\n            enabled: null,\n\n            wait: wait,\n\n            start: start,\n            stop: stop,\n            restart: restart,\n            tryRestart: tryRestart,\n\n            enable: enable,\n            disable: disable\n        };\n\n        cockpit.event_target(self);\n\n        var unit, service;\n        var wait_callbacks = cockpit.defer();\n\n        if (name.indexOf(\".\") == -1)\n            name = name + \".service\";\n\n        function update_from_unit() {\n            self.exists = (unit.LoadState != \"not-found\" || unit.ActiveState != \"inactive\");\n\n            if (unit.ActiveState == \"activating\")\n                self.state = \"starting\";\n            else if (unit.ActiveState == \"deactivating\")\n                self.state = \"stopping\";\n            else if (unit.ActiveState == \"active\" || unit.ActiveState == \"reloading\")\n                self.state = \"running\";\n            else if (unit.ActiveState == \"failed\")\n                self.state = \"failed\";\n            else if (unit.ActiveState == \"inactive\" && self.exists)\n                self.state = \"stopped\";\n            else\n                self.state = undefined;\n\n            if (unit.UnitFileState == \"enabled\" || unit.UnitFileState == \"linked\")\n                self.enabled = true;\n            else if (unit.UnitFileState == \"disabled\" || unit.UnitFileState == \"masked\")\n                self.enabled = false;\n            else\n                self.enabled = undefined;\n\n            self.unit = unit;\n\n            self.dispatchEvent(\"changed\");\n            wait_callbacks.resolve();\n        }\n\n        function update_from_service() {\n            self.service = service;\n            self.dispatchEvent(\"changed\");\n        }\n\n        with_systemd_manager(function () {\n            systemd_manager.LoadUnit(name)\n                    .done(function (path) {\n                        unit = systemd_client.proxy('org.freedesktop.systemd1.Unit', path);\n                        unit.addEventListener('changed', update_from_unit);\n                        wait_valid(unit, update_from_unit);\n\n                        service = systemd_client.proxy('org.freedesktop.systemd1.Service', path);\n                        service.addEventListener('changed', update_from_service);\n                        wait_valid(service, update_from_service);\n                    })\n                    .fail(function () {\n                        self.exists = false;\n                        self.dispatchEvent('changed');\n                    });\n        });\n\n        function refresh() {\n            if (!unit || !service)\n                return;\n\n            function refresh_interface(path, iface) {\n                systemd_client.call(path,\n                                    \"org.freedesktop.DBus.Properties\", \"GetAll\", [ iface ])\n                        .fail(function (error) {\n                            console.log(error);\n                        })\n                        .done(function (result) {\n                            var props = { };\n                            for (var p in result[0])\n                                props[p] = result[0][p].v;\n                            var ifaces = { };\n                            ifaces[iface] = props;\n                            var data = { };\n                            data[unit.path] = ifaces;\n                            systemd_client.notify(data);\n                        });\n            }\n\n            refresh_interface(unit.path, \"org.freedesktop.systemd1.Unit\");\n            refresh_interface(service.path, \"org.freedesktop.systemd1.Service\");\n        }\n\n        function on_job_new_removed_refresh(event, number, path, unit_id, result) {\n            if (unit_id == name)\n                refresh();\n        }\n\n        /* HACK - https://bugs.freedesktop.org/show_bug.cgi?id=69575\n         *\n         * We need to explicitly get new property values when getting\n         * a UnitNew signal since UnitNew doesn't carry them.\n         * However, reacting to UnitNew with GetAll could lead to an\n         * infinite loop since systemd emits a UnitNew in reaction to\n         * GetAll for units that it doesn't want to keep loaded, such\n         * as units without unit files.\n         *\n         * So we ignore UnitNew and instead assume that the unit state\n         * only changes in interesting ways when there is a job for it\n         * or when the daemon is reloaded (or when we get a property\n         * change notification, of course).\n         */\n\n        // This is what we want to do:\n        // systemd_manager.addEventListener(\"UnitNew\", function (event, unit_id, path) {\n        //     if (unit_id == name)\n        //         refresh();\n        // });\n\n        // This is what we have to do:\n        systemd_manager.addEventListener(\"Reloading\", function (event, reloading) {\n            if (!reloading)\n                refresh();\n        });\n\n        systemd_manager.addEventListener(\"JobNew\", on_job_new_removed_refresh);\n        systemd_manager.addEventListener(\"JobRemoved\", on_job_new_removed_refresh);\n\n        function wait(callback) {\n            wait_callbacks.promise.then(callback);\n        }\n\n        /* Actions\n         *\n         * We don't call methods on the D-Bus proxies here since they\n         * might not be ready when these functions are called.\n         */\n\n        var pending_jobs = { };\n\n        systemd_manager.addEventListener(\"JobRemoved\", function (event, number, path, unit_id, result) {\n            if (pending_jobs[path]) {\n                if (result == \"done\")\n                    pending_jobs[path].resolve();\n                else\n                    pending_jobs[path].reject(result);\n                delete pending_jobs[path];\n            }\n        });\n\n        function call_manager(method, args) {\n            return systemd_client.call(\"/org/freedesktop/systemd1\",\n                                       \"org.freedesktop.systemd1.Manager\",\n                                       method, args);\n        }\n\n        function call_manager_with_job(method, args) {\n            var dfd = cockpit.defer();\n            call_manager(method, args)\n                    .done(function (results) {\n                        var path = results[0];\n                        pending_jobs[path] = dfd;\n                    })\n                    .fail(function (error) {\n                        dfd.reject(error);\n                    });\n            return dfd.promise();\n        }\n\n        function call_manager_with_reload(method, args) {\n            return call_manager(method, args).then(function () {\n                var dfd = cockpit.defer();\n                call_manager(\"Reload\", [ ])\n                        .done(function () { dfd.resolve() })\n                        .fail(function (error) {\n                        // HACK: https://bugzilla.redhat.com/show_bug.cgi?id=1560549\n                        // some systemd versions disconnect too fast from the bus\n                            if (error.name === \"org.freedesktop.DBus.Error.NoReply\") {\n                                refresh();\n                                dfd.resolve();\n                            } else {\n                                dfd.reject(error);\n                            }\n                        });\n                return dfd.promise();\n            });\n        }\n\n        function start() {\n            return call_manager_with_job(\"StartUnit\", [ name, \"replace\" ]);\n        }\n\n        function stop() {\n            return call_manager_with_job(\"StopUnit\", [ name, \"replace\" ]);\n        }\n\n        function restart() {\n            return call_manager_with_job(\"RestartUnit\", [ name, \"replace\" ]);\n        }\n\n        function tryRestart() {\n            return call_manager_with_job(\"TryRestartUnit\", [ name, \"replace\" ]);\n        }\n\n        function enable() {\n            return call_manager_with_reload(\"EnableUnitFiles\", [ [ name ], false, false ]);\n        }\n\n        function disable() {\n            return call_manager_with_reload(\"DisableUnitFiles\", [ [ name ], false ]);\n        }\n\n        return self;\n    }\n\n    module.exports = {\n        proxy: proxy\n    };\n}());\n\n\n\n// WEBPACK FOOTER //\n// ../pkg/lib/service.js"],"sourceRoot":""}