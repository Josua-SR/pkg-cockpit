{"version":3,"sources":["webpack:///playground/service.min.js","webpack:///webpack/bootstrap b23d9aa3f4538545c1f7?a51c*****","webpack:///external \"cockpit\"?478e*****","webpack:///external \"jQuery\"?0cb8***","webpack:///../pkg/playground/service.js","webpack:///../pkg/lib/service.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","0","2","cockpit","4","jQuery","49","$","service","navigate","show","s","t","text","JSON","stringify","proxy","location","path","on","b","fail","error","console","50","wait_valid","callback","wait","valid","with_systemd_manager","done","systemd_manager","systemd_client","dbus","superuser","Subscribe","name","warn","update_from_unit","self","exists","unit","LoadState","ActiveState","state","undefined","UnitFileState","enabled","dispatchEvent","wait_callbacks","resolve","update_from_service","refresh","refresh_interface","iface","log","result","props","v","ifaces","data","notify","on_job_new_removed_refresh","event","number","unit_id","promise","then","call_manager","method","args","call_manager_with_job","dfd","defer","results","pending_jobs","reject","call_manager_with_reload","start","stop","restart","tryRestart","enable","disable","event_target","indexOf","LoadUnit","addEventListener","reloading"],"mappings":"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","file":"playground/service.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(49);\n\n\n/***/ },\n\n/***/ 2:\n/***/ function(module, exports) {\n\n\tmodule.exports = cockpit;\n\n/***/ },\n\n/***/ 4:\n/***/ function(module, exports) {\n\n\tmodule.exports = jQuery;\n\n/***/ },\n\n/***/ 49:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t(function() {\n\t    \"use strict\";\n\t\n\t    var $ = __webpack_require__(4);\n\t    var cockpit = __webpack_require__(2);\n\t\n\t    var service = __webpack_require__(50);\n\t\n\t    $(function() {\n\t        var proxy;\n\t\n\t        function navigate() {\n\t\n\t            proxy = service.proxy(cockpit.location.path[0] || \"\");\n\t\n\t            function show() {\n\t                function s(t) {\n\t                    $('#' + t).text(JSON.stringify(proxy[t]));\n\t                }\n\t                s('exists');\n\t                s('state');\n\t                s('enabled');\n\t            }\n\t\n\t            $(proxy).on('changed', show);\n\t            show();\n\t\n\t            $(\"body\").show();\n\t        }\n\t\n\t        function b(t) {\n\t            $('#' + t).on('click', function () {\n\t                proxy[t]().\n\t                    fail(function (error) {\n\t                        console.error(\"action\", t, \"failed:\", JSON.stringify(error));\n\t                    });\n\t            });\n\t        }\n\t\n\t        b('start');\n\t        b('stop');\n\t        b('enable');\n\t        b('disable');\n\t\n\t        $(cockpit).on('locationchanged', navigate);\n\t        navigate();\n\t    });\n\t}());\n\n\n/***/ },\n\n/***/ 50:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t(function() {\n\t    \"use strict\";\n\t\n\t    var cockpit = __webpack_require__(2);\n\t\n\t    /* SERVICE MANAGEMENT API\n\t     *\n\t     * The \"service\" module lets you monitor and manage a\n\t     * system service on localhost in a simple way.\n\t     *\n\t     * It mainly exists because talking to the systemd D-Bus API is\n\t     * not trivial enough to do it directly.\n\t     *\n\t     * - proxy = service.proxy(name)\n\t     *\n\t     * Create a proxy that represents the service named NAME.\n\t     *\n\t     * The proxy has properties and methods (described below) that\n\t     * allow you to monitor the state of the service, and perform\n\t     * simple actions on it.\n\t     *\n\t     * Initially, any of the properties can be \"null\" until their\n\t     * actual values have been retrieved in the background.\n\t     *\n\t     * - $(proxy).on('changed', function (event) { ... })\n\t     *\n\t     * The 'changed' event is emitted whenever one of the properties\n\t     * of the proxy changes.\n\t     *\n\t     * - proxy.exists\n\t     *\n\t     * A boolean that tells whether the service is known or not.  A\n\t     * proxy with 'exists == false' will have 'state == undefined' and\n\t     * 'enabled == undefined'.\n\t     *\n\t     * - proxy.state\n\t     *\n\t     * Either 'undefined' when the state can't be retrieved, or a\n\t     * string that has one of the values \"starting\", \"running\",\n\t     * \"stopping\", \"stopped\", or \"failed\".\n\t     *\n\t     * - proxy.enabled\n\t     *\n\t     * Either 'undefined' when the value can't be retrieved, or a\n\t     * boolean that tells whether the service is started 'enabled'.\n\t     * What it means exactly for a service to be enabled depends on\n\t     * the service, but a enabled service is usually started on boot,\n\t     * no matter wether other services need it or not.  A disabled\n\t     * service is usually only started when it is needed by some other\n\t     * service.\n\t     *\n\t     * - proxy.unit\n\t     * - proxy.service\n\t     *\n\t     * The raw org.freedesktop.systemd1.Unit and Service D-Bus\n\t     * interface proxies for the service.\n\t     *\n\t     * - promise = proxy.start()\n\t     *\n\t     * Start the service.  The return value is a standard jQuery\n\t     * promise as returned from DBusClient.call.\n\t     *\n\t     * - promise =  proxy.restart()\n\t     *\n\t     * Restart the service.\n\t     *\n\t     * - promise = proxy.tryRestart()\n\t     * \n\t     * Try to restart the service if it's running or starting\n\t     *\n\t     * - promise = proxy.stop()\n\t     *\n\t     * Stop the service.\n\t     *\n\t     * - promise = proxy.enable()\n\t     *\n\t     * Enable the service.\n\t     *\n\t     * - promise = proxy.disable()\n\t     *\n\t     * Disable the service.\n\t     */\n\t\n\t    var systemd_client;\n\t    var systemd_manager;\n\t\n\t    function wait_valid(proxy, callback) {\n\t        proxy.wait(function() {\n\t            if (proxy.valid)\n\t                callback();\n\t        });\n\t    }\n\t\n\t    function with_systemd_manager(done) {\n\t        if (!systemd_manager) {\n\t            systemd_client = cockpit.dbus(\"org.freedesktop.systemd1\", { superuser: \"try\" });\n\t            systemd_manager = systemd_client.proxy(\"org.freedesktop.systemd1.Manager\",\n\t                                                   \"/org/freedesktop/systemd1\");\n\t            wait_valid(systemd_manager, function() {\n\t                systemd_manager.Subscribe().\n\t                    fail(function (error) {\n\t                        if (error.name != \"org.freedesktop.systemd1.AlreadySubscribed\" &&\n\t                            error.name != \"org.freedesktop.DBus.Error.FileExists\")\n\t                            console.warn(\"Subscribing to systemd signals failed\", error);\n\t                    });\n\t            });\n\t        }\n\t        wait_valid(systemd_manager, done);\n\t    }\n\t\n\t    function proxy(name) {\n\t        var self = {\n\t            exists: null,\n\t            state: null,\n\t            enabled: null,\n\t\n\t            wait: wait,\n\t\n\t            start: start,\n\t            stop: stop,\n\t            restart: restart,\n\t            tryRestart: tryRestart,\n\t\n\t            enable: enable,\n\t            disable: disable\n\t        };\n\t\n\t        cockpit.event_target(self);\n\t\n\t        var unit, service;\n\t        var wait_callbacks = cockpit.defer();\n\t\n\t        if (name.indexOf(\".\") == -1)\n\t            name = name + \".service\";\n\t\n\t        function update_from_unit() {\n\t            self.exists = (unit.LoadState != \"not-found\" || unit.ActiveState != \"inactive\");\n\t\n\t            if (unit.ActiveState == \"activating\")\n\t                self.state = \"starting\";\n\t            else if (unit.ActiveState == \"deactivating\")\n\t                self.state = \"stopping\";\n\t            else if (unit.ActiveState == \"active\" || unit.ActiveState == \"reloading\")\n\t                self.state = \"running\";\n\t            else if (unit.ActiveState == \"failed\")\n\t                self.state = \"failed\";\n\t            else if (unit.ActiveState == \"inactive\" && self.exists)\n\t                self.state = \"stopped\";\n\t            else\n\t                self.state = undefined;\n\t\n\t            if (unit.UnitFileState == \"enabled\" || unit.UnitFileState == \"linked\")\n\t                self.enabled = true;\n\t            else if (unit.UnitFileState == \"disabled\" || unit.UnitFileState == \"masked\")\n\t                self.enabled = false;\n\t            else\n\t                self.enabled = undefined;\n\t\n\t            self.unit = unit;\n\t\n\t            self.dispatchEvent(\"changed\");\n\t            wait_callbacks.resolve();\n\t        }\n\t\n\t        function update_from_service() {\n\t            self.service = service;\n\t            self.dispatchEvent(\"changed\");\n\t        }\n\t\n\t        with_systemd_manager(function () {\n\t            systemd_manager.LoadUnit(name).\n\t                done(function (path) {\n\t                    unit = systemd_client.proxy('org.freedesktop.systemd1.Unit', path);\n\t                    unit.addEventListener('changed', update_from_unit);\n\t                    wait_valid(unit, update_from_unit);\n\t\n\t                    service = systemd_client.proxy('org.freedesktop.systemd1.Service', path);\n\t                    service.addEventListener('changed', update_from_service);\n\t                    wait_valid(service, update_from_service);\n\t                }).\n\t                fail(function (error) {\n\t                    self.exists = false;\n\t                    self.dispatchEvent('changed');\n\t                });\n\t        });\n\t\n\t        function refresh() {\n\t            if (!unit || !service)\n\t                return;\n\t\n\t            function refresh_interface(path, iface) {\n\t                systemd_client.call(path,\n\t                                    \"org.freedesktop.DBus.Properties\", \"GetAll\", [ iface ]).\n\t                    fail(function (error) {\n\t                        console.log(error);\n\t                    }).\n\t                    done(function (result) {\n\t                        var props = { };\n\t                        for (var p in result[0])\n\t                            props[p] = result[0][p].v;\n\t                        var ifaces = { };\n\t                        ifaces[iface] = props;\n\t                        var data = { };\n\t                        data[unit.path] = ifaces;\n\t                        systemd_client.notify(data);\n\t                    });\n\t            }\n\t\n\t            refresh_interface(unit.path, \"org.freedesktop.systemd1.Unit\");\n\t            refresh_interface(service.path, \"org.freedesktop.systemd1.Service\");\n\t        }\n\t\n\t        function on_job_new_removed_refresh(event, number, path, unit_id, result) {\n\t            if (unit_id == name)\n\t                refresh();\n\t        }\n\t\n\t        /* HACK - https://bugs.freedesktop.org/show_bug.cgi?id=69575\n\t         *\n\t         * We need to explicitly get new property values when getting\n\t         * a UnitNew signal since UnitNew doesn't carry them.\n\t         * However, reacting to UnitNew with GetAll could lead to an\n\t         * infinite loop since systemd emits a UnitNew in reaction to\n\t         * GetAll for units that it doesn't want to keep loaded, such\n\t         * as units without unit files.\n\t         *\n\t         * So we ignore UnitNew and instead assume that the unit state\n\t         * only changes in interesting ways when there is a job for it\n\t         * or when the daemon is reloaded (or when we get a property\n\t         * change notification, of course).\n\t         */\n\t\n\t        if (false) {\n\t            // This is what we want to do.\n\t\n\t            systemd_manager.addEventListener(\"UnitNew\", function (event, unit_id, path) {\n\t                if (unit_id == name)\n\t                    refresh();\n\t            });\n\t        } else {\n\t            // This is what we have to do.\n\t\n\t            systemd_manager.addEventListener(\"Reloading\", function (event, reloading) {\n\t                if (!reloading)\n\t                    refresh();\n\t            });\n\t\n\t            systemd_manager.addEventListener(\"JobNew\", on_job_new_removed_refresh);\n\t            systemd_manager.addEventListener(\"JobRemoved\", on_job_new_removed_refresh);\n\t        }\n\t\n\t        function wait(callback) {\n\t            wait_callbacks.promise.then(callback);\n\t        }\n\t\n\t        /* Actions\n\t         *\n\t         * We don't call methods on the D-Bus proxies here since they\n\t         * might not be ready when these functions are called.\n\t         */\n\t\n\t        var pending_jobs = { };\n\t\n\t        systemd_manager.addEventListener(\"JobRemoved\", function (event, number, path, unit_id, result) {\n\t            if (pending_jobs[path]) {\n\t                if (result == \"done\")\n\t                    pending_jobs[path].resolve();\n\t                else\n\t                    pending_jobs[path].reject(result);\n\t                delete pending_jobs[path];\n\t            }\n\t        });\n\t\n\t        function call_manager(method, args) {\n\t            return systemd_client.call(\"/org/freedesktop/systemd1\",\n\t                                       \"org.freedesktop.systemd1.Manager\",\n\t                                       method, args);\n\t        }\n\t\n\t        function call_manager_with_job(method, args) {\n\t            var dfd = cockpit.defer();\n\t            call_manager(method, args).\n\t                done(function (results) {\n\t                    var path = results[0];\n\t                    pending_jobs[path] = dfd;\n\t                }).\n\t                fail(function (error) {\n\t                    dfd.reject(error);\n\t                });\n\t            return dfd.promise();\n\t        }\n\t\n\t        function call_manager_with_reload(method, args) {\n\t            return call_manager(method, args).then(function () {\n\t                var dfd = cockpit.defer();\n\t                call_manager(\"Reload\", [ ]).\n\t                    done(function () { dfd.resolve() }).\n\t                    fail(function (error) {\n\t                        // HACK: https://bugzilla.redhat.com/show_bug.cgi?id=1560549\n\t                        // some systemd versions disconnect too fast from the bus\n\t                        if (error.name === \"org.freedesktop.DBus.Error.NoReply\") {\n\t                            refresh();\n\t                            dfd.resolve();\n\t                        } else {\n\t                            dfd.reject(error);\n\t                        }\n\t                    });\n\t                return dfd.promise();\n\t            });\n\t        }\n\t\n\t        function start() {\n\t            return call_manager_with_job(\"StartUnit\", [ name, \"replace\" ]);\n\t        }\n\t\n\t        function stop() {\n\t            return call_manager_with_job(\"StopUnit\", [ name, \"replace\" ]);\n\t        }\n\t\n\t        function restart() {\n\t            return call_manager_with_job(\"RestartUnit\", [ name, \"replace\" ]);\n\t        }\n\t\n\t        function tryRestart() {\n\t            return call_manager_with_job(\"TryRestartUnit\", [ name, \"replace\" ]);\n\t        }\n\t\n\t        function enable() {\n\t            return call_manager_with_reload(\"EnableUnitFiles\", [ [ name ], false, false ]);\n\t        }\n\t\n\t        function disable() {\n\t            return call_manager_with_reload(\"DisableUnitFiles\", [ [ name ], false ]);\n\t        }\n\t\n\t        return self;\n\t    }\n\t\n\t    module.exports = {\n\t        proxy: proxy\n\t    };\n\t}());\n\n\n/***/ }\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// playground/service.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b23d9aa3f4538545c1f7","module.exports = cockpit;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"cockpit\"\n// module id = 2\n// module chunks = 0 1 2 3 4 5 6 7 8 9","module.exports = jQuery;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"jQuery\"\n// module id = 4\n// module chunks = 1 2 3 4 6 8 9","'use strict';\n\n(function() {\n    \"use strict\";\n\n    var $ = require(\"jquery\");\n    var cockpit = require(\"cockpit\");\n\n    var service = require(\"service\");\n\n    $(function() {\n        var proxy;\n\n        function navigate() {\n\n            proxy = service.proxy(cockpit.location.path[0] || \"\");\n\n            function show() {\n                function s(t) {\n                    $('#' + t).text(JSON.stringify(proxy[t]));\n                }\n                s('exists');\n                s('state');\n                s('enabled');\n            }\n\n            $(proxy).on('changed', show);\n            show();\n\n            $(\"body\").show();\n        }\n\n        function b(t) {\n            $('#' + t).on('click', function () {\n                proxy[t]().\n                    fail(function (error) {\n                        console.error(\"action\", t, \"failed:\", JSON.stringify(error));\n                    });\n            });\n        }\n\n        b('start');\n        b('stop');\n        b('enable');\n        b('disable');\n\n        $(cockpit).on('locationchanged', navigate);\n        navigate();\n    });\n}());\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../pkg/playground/service.js\n// module id = 49\n// module chunks = 6","'use strict';\n\n(function() {\n    \"use strict\";\n\n    var cockpit = require(\"cockpit\");\n\n    /* SERVICE MANAGEMENT API\n     *\n     * The \"service\" module lets you monitor and manage a\n     * system service on localhost in a simple way.\n     *\n     * It mainly exists because talking to the systemd D-Bus API is\n     * not trivial enough to do it directly.\n     *\n     * - proxy = service.proxy(name)\n     *\n     * Create a proxy that represents the service named NAME.\n     *\n     * The proxy has properties and methods (described below) that\n     * allow you to monitor the state of the service, and perform\n     * simple actions on it.\n     *\n     * Initially, any of the properties can be \"null\" until their\n     * actual values have been retrieved in the background.\n     *\n     * - $(proxy).on('changed', function (event) { ... })\n     *\n     * The 'changed' event is emitted whenever one of the properties\n     * of the proxy changes.\n     *\n     * - proxy.exists\n     *\n     * A boolean that tells whether the service is known or not.  A\n     * proxy with 'exists == false' will have 'state == undefined' and\n     * 'enabled == undefined'.\n     *\n     * - proxy.state\n     *\n     * Either 'undefined' when the state can't be retrieved, or a\n     * string that has one of the values \"starting\", \"running\",\n     * \"stopping\", \"stopped\", or \"failed\".\n     *\n     * - proxy.enabled\n     *\n     * Either 'undefined' when the value can't be retrieved, or a\n     * boolean that tells whether the service is started 'enabled'.\n     * What it means exactly for a service to be enabled depends on\n     * the service, but a enabled service is usually started on boot,\n     * no matter wether other services need it or not.  A disabled\n     * service is usually only started when it is needed by some other\n     * service.\n     *\n     * - proxy.unit\n     * - proxy.service\n     *\n     * The raw org.freedesktop.systemd1.Unit and Service D-Bus\n     * interface proxies for the service.\n     *\n     * - promise = proxy.start()\n     *\n     * Start the service.  The return value is a standard jQuery\n     * promise as returned from DBusClient.call.\n     *\n     * - promise =  proxy.restart()\n     *\n     * Restart the service.\n     *\n     * - promise = proxy.tryRestart()\n     * \n     * Try to restart the service if it's running or starting\n     *\n     * - promise = proxy.stop()\n     *\n     * Stop the service.\n     *\n     * - promise = proxy.enable()\n     *\n     * Enable the service.\n     *\n     * - promise = proxy.disable()\n     *\n     * Disable the service.\n     */\n\n    var systemd_client;\n    var systemd_manager;\n\n    function wait_valid(proxy, callback) {\n        proxy.wait(function() {\n            if (proxy.valid)\n                callback();\n        });\n    }\n\n    function with_systemd_manager(done) {\n        if (!systemd_manager) {\n            systemd_client = cockpit.dbus(\"org.freedesktop.systemd1\", { superuser: \"try\" });\n            systemd_manager = systemd_client.proxy(\"org.freedesktop.systemd1.Manager\",\n                                                   \"/org/freedesktop/systemd1\");\n            wait_valid(systemd_manager, function() {\n                systemd_manager.Subscribe().\n                    fail(function (error) {\n                        if (error.name != \"org.freedesktop.systemd1.AlreadySubscribed\" &&\n                            error.name != \"org.freedesktop.DBus.Error.FileExists\")\n                            console.warn(\"Subscribing to systemd signals failed\", error);\n                    });\n            });\n        }\n        wait_valid(systemd_manager, done);\n    }\n\n    function proxy(name) {\n        var self = {\n            exists: null,\n            state: null,\n            enabled: null,\n\n            wait: wait,\n\n            start: start,\n            stop: stop,\n            restart: restart,\n            tryRestart: tryRestart,\n\n            enable: enable,\n            disable: disable\n        };\n\n        cockpit.event_target(self);\n\n        var unit, service;\n        var wait_callbacks = cockpit.defer();\n\n        if (name.indexOf(\".\") == -1)\n            name = name + \".service\";\n\n        function update_from_unit() {\n            self.exists = (unit.LoadState != \"not-found\" || unit.ActiveState != \"inactive\");\n\n            if (unit.ActiveState == \"activating\")\n                self.state = \"starting\";\n            else if (unit.ActiveState == \"deactivating\")\n                self.state = \"stopping\";\n            else if (unit.ActiveState == \"active\" || unit.ActiveState == \"reloading\")\n                self.state = \"running\";\n            else if (unit.ActiveState == \"failed\")\n                self.state = \"failed\";\n            else if (unit.ActiveState == \"inactive\" && self.exists)\n                self.state = \"stopped\";\n            else\n                self.state = undefined;\n\n            if (unit.UnitFileState == \"enabled\" || unit.UnitFileState == \"linked\")\n                self.enabled = true;\n            else if (unit.UnitFileState == \"disabled\" || unit.UnitFileState == \"masked\")\n                self.enabled = false;\n            else\n                self.enabled = undefined;\n\n            self.unit = unit;\n\n            self.dispatchEvent(\"changed\");\n            wait_callbacks.resolve();\n        }\n\n        function update_from_service() {\n            self.service = service;\n            self.dispatchEvent(\"changed\");\n        }\n\n        with_systemd_manager(function () {\n            systemd_manager.LoadUnit(name).\n                done(function (path) {\n                    unit = systemd_client.proxy('org.freedesktop.systemd1.Unit', path);\n                    unit.addEventListener('changed', update_from_unit);\n                    wait_valid(unit, update_from_unit);\n\n                    service = systemd_client.proxy('org.freedesktop.systemd1.Service', path);\n                    service.addEventListener('changed', update_from_service);\n                    wait_valid(service, update_from_service);\n                }).\n                fail(function (error) {\n                    self.exists = false;\n                    self.dispatchEvent('changed');\n                });\n        });\n\n        function refresh() {\n            if (!unit || !service)\n                return;\n\n            function refresh_interface(path, iface) {\n                systemd_client.call(path,\n                                    \"org.freedesktop.DBus.Properties\", \"GetAll\", [ iface ]).\n                    fail(function (error) {\n                        console.log(error);\n                    }).\n                    done(function (result) {\n                        var props = { };\n                        for (var p in result[0])\n                            props[p] = result[0][p].v;\n                        var ifaces = { };\n                        ifaces[iface] = props;\n                        var data = { };\n                        data[unit.path] = ifaces;\n                        systemd_client.notify(data);\n                    });\n            }\n\n            refresh_interface(unit.path, \"org.freedesktop.systemd1.Unit\");\n            refresh_interface(service.path, \"org.freedesktop.systemd1.Service\");\n        }\n\n        function on_job_new_removed_refresh(event, number, path, unit_id, result) {\n            if (unit_id == name)\n                refresh();\n        }\n\n        /* HACK - https://bugs.freedesktop.org/show_bug.cgi?id=69575\n         *\n         * We need to explicitly get new property values when getting\n         * a UnitNew signal since UnitNew doesn't carry them.\n         * However, reacting to UnitNew with GetAll could lead to an\n         * infinite loop since systemd emits a UnitNew in reaction to\n         * GetAll for units that it doesn't want to keep loaded, such\n         * as units without unit files.\n         *\n         * So we ignore UnitNew and instead assume that the unit state\n         * only changes in interesting ways when there is a job for it\n         * or when the daemon is reloaded (or when we get a property\n         * change notification, of course).\n         */\n\n        if (false) {\n            // This is what we want to do.\n\n            systemd_manager.addEventListener(\"UnitNew\", function (event, unit_id, path) {\n                if (unit_id == name)\n                    refresh();\n            });\n        } else {\n            // This is what we have to do.\n\n            systemd_manager.addEventListener(\"Reloading\", function (event, reloading) {\n                if (!reloading)\n                    refresh();\n            });\n\n            systemd_manager.addEventListener(\"JobNew\", on_job_new_removed_refresh);\n            systemd_manager.addEventListener(\"JobRemoved\", on_job_new_removed_refresh);\n        }\n\n        function wait(callback) {\n            wait_callbacks.promise.then(callback);\n        }\n\n        /* Actions\n         *\n         * We don't call methods on the D-Bus proxies here since they\n         * might not be ready when these functions are called.\n         */\n\n        var pending_jobs = { };\n\n        systemd_manager.addEventListener(\"JobRemoved\", function (event, number, path, unit_id, result) {\n            if (pending_jobs[path]) {\n                if (result == \"done\")\n                    pending_jobs[path].resolve();\n                else\n                    pending_jobs[path].reject(result);\n                delete pending_jobs[path];\n            }\n        });\n\n        function call_manager(method, args) {\n            return systemd_client.call(\"/org/freedesktop/systemd1\",\n                                       \"org.freedesktop.systemd1.Manager\",\n                                       method, args);\n        }\n\n        function call_manager_with_job(method, args) {\n            var dfd = cockpit.defer();\n            call_manager(method, args).\n                done(function (results) {\n                    var path = results[0];\n                    pending_jobs[path] = dfd;\n                }).\n                fail(function (error) {\n                    dfd.reject(error);\n                });\n            return dfd.promise();\n        }\n\n        function call_manager_with_reload(method, args) {\n            return call_manager(method, args).then(function () {\n                var dfd = cockpit.defer();\n                call_manager(\"Reload\", [ ]).\n                    done(function () { dfd.resolve() }).\n                    fail(function (error) {\n                        // HACK: https://bugzilla.redhat.com/show_bug.cgi?id=1560549\n                        // some systemd versions disconnect too fast from the bus\n                        if (error.name === \"org.freedesktop.DBus.Error.NoReply\") {\n                            refresh();\n                            dfd.resolve();\n                        } else {\n                            dfd.reject(error);\n                        }\n                    });\n                return dfd.promise();\n            });\n        }\n\n        function start() {\n            return call_manager_with_job(\"StartUnit\", [ name, \"replace\" ]);\n        }\n\n        function stop() {\n            return call_manager_with_job(\"StopUnit\", [ name, \"replace\" ]);\n        }\n\n        function restart() {\n            return call_manager_with_job(\"RestartUnit\", [ name, \"replace\" ]);\n        }\n\n        function tryRestart() {\n            return call_manager_with_job(\"TryRestartUnit\", [ name, \"replace\" ]);\n        }\n\n        function enable() {\n            return call_manager_with_reload(\"EnableUnitFiles\", [ [ name ], false, false ]);\n        }\n\n        function disable() {\n            return call_manager_with_reload(\"DisableUnitFiles\", [ [ name ], false ]);\n        }\n\n        return self;\n    }\n\n    module.exports = {\n        proxy: proxy\n    };\n}());\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../pkg/lib/service.js\n// module id = 50\n// module chunks = 6"],"sourceRoot":""}