!function(t) {
    function e(n) {
        if (i[n]) return i[n].exports;
        var o = i[n] = {
            exports: {},
            id: n,
            loaded: !1
        };
        return t[n].call(o.exports, o, o.exports, e), o.loaded = !0, o.exports;
    }
    var i = {};
    return e.m = t, e.c = i, e.p = "", e(0);
}([ function(t, e, i) {
    t.exports = i(14);
}, , function(t, e) {
    t.exports = cockpit;
}, , function(t, e) {
    t.exports = jQuery;
}, , , , , , , , function(t, e) {}, , function(t, e, i) {
    "use strict";
    var n = i(4), o = i(15);
    i(12);
    var r = new o.Plot(n("#plot"), 300);
    r.set_options(o.plot_simple_template()), r.add_metrics_sum_series({
        direct: [ "mem.util.used" ]
    }, {}), n(function() {
        n("body").show(), r.resize();
        var t = o.setup_plot_controls(n("body"), n("#toolbar"));
        t.reset([ r ]);
    });
}, function(t, e, i) {
    "use strict";
    function n(t, e) {
        if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !e || "object" != typeof e && "function" != typeof e ? t : e;
    }
    function o(t, e) {
        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
        t.prototype = Object.create(e && e.prototype, {
            constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }
    function r(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
    }
    function a() {
        var t = [ "#39a5dc", "#008ff0", "#2daaff", "#69c2ff", "#a5daff", "#e1f3ff", "#00243c", "#004778" ];
        return {
            colors: t,
            legend: {
                show: !1
            },
            series: {
                shadowSize: 0,
                lines: {
                    lineWidth: 2,
                    fill: 1
                }
            },
            xaxis: {
                tickLength: 0,
                mode: "time",
                tickFormatter: l,
                minTickSize: [ 1, "minute" ],
                reserveSpace: !1
            },
            yaxis: {
                tickColor: "#d1d1d1",
                min: 0
            },
            points: {
                radius: 0
            },
            grid: {
                borderWidth: 1,
                aboveData: !1,
                color: "black",
                borderColor: _.color.parse("black").scale("a", .22).toString(),
                labelMargin: 0
            }
        };
    }
    function s(t) {
        for (var e = Math.pow(2, Math.ceil(Math.log(t.max / 5) / Math.LN2)), i = [], n = 0; n < t.max; n += e) i.push(n);
        return i;
    }
    function l(t, e) {
        function i(t) {
            var e = t.toFixed();
            return 1 == e.length && (e = "0" + e), e;
        }
        var n, o, r = 0, a = 1, s = 2, l = 3, c = e.tickSize[1];
        o = "minute" == c || "hour" == c ? l : "day" == c ? s : "month" == c ? a : r;
        var h = new Date(), u = new Date(e.min);
        n = r, u.getFullYear() == h.getFullYear() && (n = a, u.getMonth() == h.getMonth() && (n = s, 
        u.getDate() == h.getDate() && (n = l))), n > o && (n = o), n == s && (n = a);
        var f = new Date(t), d = " ";
        return r >= n && r <= o && (d += f.getFullYear().toFixed() + " "), a >= n && a <= o && (d += W[f.getMonth()] + " "), 
        s >= n && s <= o && (d += f.getDate().toFixed() + " "), l >= n && l <= o && (d += i(f.getHours()) + ":" + i(f.getMinutes()) + " "), 
        d.substr(0, d.length - 1);
    }
    function c(t) {
        return w.format_bytes(t.max, 1024, !0)[1];
    }
    function h(t, e) {
        return w.format_bytes(t, c(e), !0)[0];
    }
    function u(t, e) {
        return w.format_bytes(t, 1024);
    }
    function f(t) {
        return w.format_bytes_per_sec(t.max, 1024, !0)[1];
    }
    function d(t, e) {
        return w.format_bytes_per_sec(t, f(e), !0)[0];
    }
    function m(t, e) {
        return w.format_bytes_per_sec(t, 1024);
    }
    function p(t) {
        return w.format_bits_per_sec(8 * t.max, 1e3, !0)[1];
    }
    function g(t, e) {
        return w.format_bits_per_sec(8 * t, p(e), !0)[0];
    }
    function v(t, e) {
        return w.format_bits_per_sec(8 * t, 1e3);
    }
    function x(t, e, i) {
        function n() {
            void 0 === u && (i.forEach(function(t) {
                t.stop_walking();
            }), u = new Date().getTime() / 1e3, s());
        }
        function o(t, e) {
            p.push(m), m = t, u = e, c();
        }
        function r() {
            var t = p.pop();
            if (void 0 === t) {
                var e;
                for (e = 0; e < d.length - 1 && !(d[e] > m); e++) ;
                t = d[e];
            }
            void 0 !== u && (u += (t - m) / 2), m = t, c();
        }
        function a(t) {
            var e;
            return t >= 31536e3 ? (e = Math.ceil(t / 31536e3), w.format(w.ngettext("$0 year", "$0 years", e), e)) : t >= 2592e3 ? (e = Math.ceil(t / 2592e3), 
            w.format(w.ngettext("$0 month", "$0 months", e), e)) : t >= 604800 ? (e = Math.ceil(t / 604800), 
            w.format(w.ngettext("$0 week", "$0 weeks", e), e)) : t >= 86400 ? (e = Math.ceil(t / 86400), 
            w.format(w.ngettext("$0 day", "$0 days", e), e)) : t >= 3600 ? (e = Math.ceil(t / 3600), 
            w.format(w.ngettext("$0 hour", "$0 hours", e), e)) : (e = Math.ceil(t / 60), w.format(w.ngettext("$0 minute", "$0 minutes", e), e));
        }
        function s() {
            e.find('[data-action="scroll-right"]').attr("disabled", void 0 === u), e.find('[data-action="zoom-out"]').attr("disabled", m >= d[d.length - 1]);
        }
        function l() {
            var e;
            t.hasClass("show-zoom-controls") && m > f ? (t.addClass("show-zoom-cursor"), e = "x") : (t.removeClass("show-zoom-cursor"), 
            e = null), i.forEach(function(t) {
                var i = t.get_options();
                i.selection && i.selection.mode == e || (i.selection = {
                    mode: e,
                    color: "#edf8ff"
                }, t.set_options(i), t.refresh());
            });
        }
        function c() {
            m < f && (u += (f - m) / 2, m = f), u >= new Date().getTime() / 1e3 - 10 && (u = void 0), 
            e.find(".dropdown-toggle span:first-child").text(a(m)), i.forEach(function(e) {
                function i() {
                    e.archives && (t.addClass("show-zoom-controls"), l());
                }
                e.stop_walking(), e.reset(m, u), e.refresh(), void 0 === u && e.start_walking(), 
                _(e).on("changed", i), i();
            }), s(), l();
        }
        function h(t) {
            void 0 === t && (t = []), i = t, i.forEach(function(t) {
                _(t).on("zoomstart", function(t) {
                    n();
                }), _(t).on("zoom", function(t, e, i) {
                    o(e, i);
                });
            }), c();
        }
        var u, f = 300, d = [ 300, 3600, 21600, 86400, 604800, 2592e3, 31536e3 ], m = 300, p = [];
        return e.find("[data-range]").click(function() {
            p = [], m = parseInt(_(this).attr("data-range"), 10), c();
        }), e.find('[data-action="goto-now"]').click(function() {
            u = void 0, c();
        }), e.find('[data-action="scroll-left"]').click(function() {
            var t = m / 10;
            void 0 === u && (u = new Date().getTime() / 1e3), u -= t, c();
        }), e.find('[data-action="scroll-right"]').click(function() {
            var t = m / 10;
            void 0 !== u && (u += t, c());
        }), e.find('[data-action="zoom-out"]').click(function() {
            r();
        }), h(i), {
            reset: h
        };
    }
    function b(t, e, i, n) {
        function o() {
            v.width(g.width()), v.height(g.height());
        }
        function r(t) {
            f ? (f.getAxes().yaxis.options.max = t, c()) : m.yaxis.max = t;
        }
        function a() {
            p = !0, s();
        }
        function s() {
            p && g.width() > 0 && g.height() > 0 ? (f ? h() : (o(), f = _.plot(v, i, m)), x && window.clearInterval(x)) : x || (x = window.setInterval(s, 500));
        }
        function l() {
            p = !1;
        }
        function c() {
            f && p && (f.setData(i), n.setup_hook && n.setup_hook(f), f.setupGrid(), f.draw(), 
            n.post_hook && n.post_hook(f));
        }
        function h() {
            f && p && (o(), v.width() > 0 && v.height() > 0 && f.resize(), c());
        }
        function u() {
            _(d).trigger("destroyed"), _(window).off("resize", h), _(g).empty(), f = null;
        }
        var f, d, m = {
            colors: [ "#0099d3" ],
            legend: {
                show: !1
            },
            series: {
                shadowSize: 0,
                lines: {
                    lineWidth: 0,
                    fill: 1
                }
            },
            xaxis: {
                tickFormatter: function() {
                    return "";
                }
            },
            yaxis: {
                tickFormatter: function() {
                    return "";
                }
            },
            points: {
                radius: 0
            },
            grid: {
                borderWidth: 1,
                aboveData: !0,
                color: "black",
                borderColor: _.color.parse("black").scale("a", .22).toString(),
                labelMargin: 0
            }
        }, p = !1;
        _.extend(!0, m, n);
        var g = _(t), v = _("<div/>"), x = null;
        return g.empty(), g.append(v), _(e).on("notify", c), _(window).on("resize", h), 
        s(), d = {
            start: a,
            stop: l,
            resize: h,
            element: v[0],
            set_yaxis_max: r,
            destroy: u
        };
    }
    function y(t, e, i, n) {
        function o(t, e) {
            return t.add(function(t, i, n) {
                for (var o = 0; o < n; o++) t[i + o] = [ o, e[i + o] || 0 ];
            });
        }
        function r(t, e, i) {
            return t.add(function(t, n, o) {
                var r, a, s, l;
                for (r = 0; r < o; r++) s = 0, i && (a = i[n + r], s = a ? a[1] : 0), l = e[n + r] || 0, 
                t[n + r] = [ r, l + s, s ];
            });
        }
        function a(t, e, i, n) {
            var o = n || 1;
            return t.add(function(t, n, r) {
                for (var a = 0; a < r; a++) t[n + a] = [ a, i + o * (e[n + a] || 0), i ];
            });
        }
        var s = null;
        return i.forEach(function(t, i) {
            t.offset ? t.data = a(e, t.row, t.offset, t.factor) : n.x_rh_stack_graphs ? t.data = r(e, t.row, s) : t.data = o(e, t.row), 
            s = t.data;
        }), b(t, e, i, n);
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var k = function() {
        function t(t, e) {
            for (var i = 0; i < e.length; i++) {
                var n = e[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), 
                Object.defineProperty(t, n.key, n);
            }
        }
        return function(e, i, n) {
            return i && t(e.prototype, i), n && t(e, n), e;
        };
    }();
    e.plot_simple_template = a, e.memory_ticks = s, e.format_date_tick = l, e.bytes_tick_unit = c, 
    e.format_bytes_tick_no_unit = h, e.format_bytes_tick = u, e.bytes_per_sec_tick_unit = f, 
    e.format_bytes_per_sec_tick_no_unit = d, e.format_bytes_per_sec_tick = m, e.bits_per_sec_tick_unit = p, 
    e.format_bits_per_sec_tick_no_unit = g, e.format_bits_per_sec_tick = v, e.setup_plot_controls = x, 
    e.setup_plot = b, e.setup_complicated_plot = y;
    var _ = i(4), w = i(2);
    i(16), i(17), i(18);
    var M = w.gettext, S = function() {
        function t(e, i, n, o, a) {
            r(this, t), this.desc = e, this.options = i, this.grid = n, this.flot_data = o, 
            this.interval = a, this.channel = null, this.chanopts_list = [];
        }
        return k(t, [ {
            key: "stop",
            value: function() {
                this.channel && this.channel.close();
            }
        }, {
            key: "remove_series",
            value: function() {
                var t = this.flot_data.indexOf(this.options);
                t >= 0 && this.flot_data.splice(t, 1);
            }
        }, {
            key: "remove",
            value: function() {
                this.stop(), this.remove_series(), _(self).triggerHandler("removed");
            }
        }, {
            key: "build_metric",
            value: function(t) {
                return {
                    name: t,
                    units: this.desc.units,
                    derive: this.desc.derive
                };
            }
        }, {
            key: "hover_hit",
            value: function(t, e) {
                return !(!e || e.series.data != this.options.data);
            }
        }, {
            key: "hover",
            value: function(t) {
                _(this).triggerHandler("hover", [ t ]);
            }
        }, {
            key: "move_to_front",
            value: function() {
                var t = this.flot_data.indexOf(this.options);
                t >= 0 && (this.flot_data.splice(t, 1), this.flot_data.push(this.options));
            }
        }, {
            key: "check_archives",
            value: function() {
                this.channel.archives && _(this).triggerHandler("changed");
            }
        } ]), t;
    }(), z = function(t) {
        function e(t, i, o, a, s) {
            r(this, e);
            var l = n(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i, o, a, s));
            return l.desc.direct && l.chanopts_list.push({
                source: "direct",
                archive_source: "pcp-archive",
                metrics: l.desc.direct.map(l.build_metric, l),
                instances: l.desc.instances,
                "omit-instances": l.desc["omit-instances"],
                host: l.desc.host
            }), l.desc.internal && l.chanopts_list.push({
                source: "internal",
                metrics: l.desc.internal.map(l.build_metric, l),
                instances: l.desc.instances,
                "omit-instances": l.desc["omit-instances"],
                host: l.desc.host
            }), l;
        }
        return o(e, t), k(e, [ {
            key: "flat_sum",
            value: function(t) {
                var e;
                if (!t) return 0;
                if (void 0 !== t.length) {
                    e = 0;
                    for (var i = 0; i < t.length; i++) e += this.flat_sum(t[i]);
                    return e;
                }
                return t;
            }
        }, {
            key: "reset_series",
            value: function() {
                var t = this;
                this.channel && this.channel.close(), this.channel = w.metrics(this.interval, this.chanopts_list);
                var e = this.grid.add(this.channel, []), i = this.desc.factor || 1, n = this.desc.threshold || null, o = this.desc.offset || 0;
                this.options.data = this.grid.add(function(r, a, s) {
                    for (var l = 0; l < s; l++) {
                        var c = o + t.flat_sum(e[a + l]) * i;
                        null !== n ? r[a + l] = [ (t.grid.beg + a + l) * t.interval, Math.abs(c) > n ? c : null, n ] : r[a + l] = [ (t.grid.beg + a + l) * t.interval, c ];
                    }
                }), _(this.channel).on("changed", this.check_archives.bind(this)), this.check_archives();
            }
        } ]), e;
    }(S), T = function(t) {
        function e(t, i, o, a, s) {
            r(this, e);
            var l = n(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i, o, a, s));
            return l.desc.direct && l.chanopts_list.push({
                source: "direct",
                archive_source: "pcp-archive",
                metrics: l.desc.direct.map(l.build_metric, l),
                instances: l.desc.instances,
                "omit-instances": l.desc["omit-instances"],
                host: l.desc.host
            }), l.desc.internal && l.chanopts_list.push({
                source: "internal",
                metrics: l.desc.internal.map(l.build_metric, l),
                instances: l.desc.instances,
                "omit-instances": l.desc["omit-instances"],
                host: l.desc.host
            }), l;
        }
        return o(e, t), k(e, [ {
            key: "flat_difference",
            value: function(t) {
                var e;
                if (!t) return 0;
                if (void 0 !== t.length) {
                    e = t[0];
                    for (var i = 1; i < t.length; i++) e -= this.flat_difference(t[i]);
                    return e;
                }
                return t;
            }
        }, {
            key: "reset_series",
            value: function() {
                var t = this;
                this.channel && this.channel.close(), this.channel = w.metrics(this.interval, this.chanopts_list);
                var e = this.grid.add(this.channel, []), i = this.desc.factor || 1, n = this.desc.threshold || null, o = this.desc.offset || 0;
                this.options.data = this.grid.add(function(r, a, s) {
                    for (var l = 0; l < s; l++) {
                        var c = o + t.flat_difference(e[a + l]) * i;
                        null !== n ? r[a + l] = [ (t.grid.beg + a + l) * t.interval, Math.abs(c) > n ? c : null, n ] : r[a + l] = [ (t.grid.beg + a + l) * t.interval, c ];
                    }
                }), _(this.channel).on("changed", this.check_archives.bind(this)), this.check_archives();
            }
        } ]), e;
    }(S), C = function(t) {
        function e(t, i, o, a, s) {
            r(this, e);
            var l = n(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i, o, a, s));
            return l.instances = {}, l.last_instance = null, l.desc.direct && l.chanopts_list.push({
                source: "direct",
                archive_source: "pcp-archive",
                metrics: [ l.build_metric(l.desc.direct) ],
                metrics_path_names: [ "a" ],
                instances: l.desc.instances,
                "omit-instances": l.desc["omit-instances"],
                host: l.desc.host
            }), l.desc.internal && l.chanopts_list.push({
                source: "internal",
                metrics: [ l.build_metric(l.desc.internal) ],
                metrics_path_names: [ "a" ],
                instances: l.desc.instances,
                "omit-instances": l.desc["omit-instances"],
                host: l.desc.host
            }), l;
        }
        return o(e, t), k(e, [ {
            key: "reset_series",
            value: function() {
                this.channel && this.channel.close(), this.channel = w.metrics(this.interval, this.chanopts_list), 
                _(this.channel).on("changed", this.check_archives.bind(this)), this.check_archives();
                for (var t in this.instances) this.instances[t].reset();
            }
        }, {
            key: "add_instance",
            value: function(t, e) {
                function i() {
                    var e = this;
                    o = this.grid.add(this.channel, [ "a", t ]), r.data = this.grid.add(function(t, i, n) {
                        for (var r = 0; r < n; r++) {
                            var c = (o[i + r] || 0) * a, h = (e.grid.beg + i + r) * e.interval, u = 0;
                            l && (u = l.data[i + r][1] ? l.data[i + r][1] : l.data[i + r][2]), Math.abs(c) > s ? (t[i + r] = [ h, u + c, u ], 
                            t[i + r - 1] && null === t[i + r - 1][1] && (t[i + r - 1][1] = t[i + r - 1][2])) : (t[i + r] = [ h, null, u ], 
                            t[i + r - 1] && null !== t[i + r - 1][1] && (t[i + r - 1][1] = t[i + r - 1][2]));
                        }
                    });
                }
                function n() {
                    this.grid.remove(o), this.grid.remove(r.data);
                    var t = this.flot_data.indexOf(r);
                    t >= 0 && this.flot_data.splice(t, 1);
                }
                if (!this.instances[t]) {
                    var o, r = _.extend({
                        selector: e
                    }, this.options), a = this.desc.factor || 1, s = this.desc.threshold || 0, l = this.last_instance;
                    r.reset = i.bind(this), r.remove = n.bind(this), this.last_instance = r, this.instances[t] = r, 
                    r.reset(), this.flot_data.push(r), this.grid.sync();
                }
            }
        }, {
            key: "clear_instances",
            value: function() {
                for (var t in this.instances) this.instances[t].remove();
                this.instances = {}, this.last_instance = null;
            }
        }, {
            key: "hover_hit",
            value: function(t, e) {
                var i;
                if (!this.grid) return !1;
                i = Math.round(t.x / this.interval) - this.grid.beg, i < 0 && (i = 0);
                for (var n in this.instances) {
                    var o = this.instances[n].data;
                    if (o[i] && o[i][1] && o[i][2] <= t.y && t.y <= o[i][1]) return this.instances[n].selector || n;
                }
                return !1;
            }
        } ]), e;
    }(S), W = (e.Plot = function() {
        function t(e, i, n) {
            r(this, t), this.element = e, this.options = {}, this.series = [], this.flot_data = [], 
            this.flot = null, this.interval = 1e3 * Math.ceil(i / 1e3), this.grid = null, this.refresh_pending = !1, 
            this.sync_suppressed = 0, this.archives = !1, this.cur_hover_series = null, this.cur_hover_val = !1, 
            _(this.element).on("plothover", null, this, this.hover_on), _(this.element).on("mouseleave", null, this, this.hover_off), 
            _(this.element).on("plotselecting", null, this, this.selecting), _(this.element).on("plotselected", null, this, this.selected), 
            _(this.element).data("flot_data", this.flot_data), this.reset(i, n);
        }
        return k(t, [ {
            key: "refresh_now",
            value: function() {
                if (0 !== this.element.height() && 0 !== this.element.width()) {
                    null === this.flot && (this.flot = _.plot(this.element, this.flot_data, this.options)), 
                    this.flot.setData(this.flot_data);
                    var t = this.flot.getAxes();
                    t.xaxis.options.min = this.grid.beg * this.interval, t.xaxis.options.max = (this.grid.end - 2) * this.interval, 
                    this.options.setup_hook && this.options.setup_hook(this.flot), t.xaxis.show = !0, 
                    t.xaxis.used = !0, t.yaxis.show = !0, t.yaxis.used = !0, this.flot.setupGrid(), 
                    this.flot.draw(), this.options.post_hook && this.options.post_hook(this.flot);
                }
            }
        }, {
            key: "refresh",
            value: function() {
                var t = this;
                this.refresh_pending || (this.refresh_pending = !0, window.setTimeout(function() {
                    t.refresh_pending = !1, t.refresh_now();
                }, 0));
            }
        }, {
            key: "start_walking",
            value: function() {
                this.grid.walk();
            }
        }, {
            key: "stop_walking",
            value: function() {
                this.grid.move(this.grid.beg, this.grid.end);
            }
        }, {
            key: "reset",
            value: function(t, e) {
                var i = this;
                this.flot && this.flot.clearSelection(!0), this.interval = 1e3 * Math.ceil(t / 1e3);
                var n;
                n = void 0 !== e ? new Date().getTime() - 1e3 * e : 0;
                var o = -Math.ceil((1e3 * t + n) / this.interval), r = -Math.floor(n / this.interval);
                if (this.grid && this.grid.interval == this.interval) this.grid.move(o, r); else {
                    this.grid && this.grid.close(), this.grid = w.grid(this.interval, o, r), this.sync_suppressed++;
                    for (var a = 0; a < this.series.length; a++) this.series[a].stop(), this.series[a].interval = this.interval, 
                    this.series[a].grid = this.grid, this.series[a].reset_series();
                    this.sync_suppressed--, this.sync(), _(this.grid).on("notify", function(t, e, n) {
                        i.refresh();
                    });
                }
            }
        }, {
            key: "sync",
            value: function() {
                0 === this.sync_suppressed && this.grid.sync();
            }
        }, {
            key: "destroy",
            value: function() {
                this.grid.close();
                for (var t = 0; t < this.series.length; t++) this.series[t].stop();
                this.options = {}, this.series = [], this.flot_data = [], this.flot = null, _(this.element).empty(), 
                _(this.element).data("flot_data", null);
            }
        }, {
            key: "resize",
            value: function() {
                0 !== this.element.height() && 0 !== this.element.width() && (this.flot && this.flot.resize(), 
                this.refresh());
            }
        }, {
            key: "set_options",
            value: function(t) {
                this.options = t, this.flot = null;
            }
        }, {
            key: "get_options",
            value: function() {
                return this.options;
            }
        }, {
            key: "check_archives",
            value: function() {
                this.archives || (this.archives = !0, _(this).triggerHandler("changed"));
            }
        }, {
            key: "add_metrics_sum_series",
            value: function(t, e) {
                var i = new z(t, e, this.grid, this.flot_data, this.interval);
                return _(i).on("removed", this.refresh.bind(this)), _(i).on("changed", this.check_archives.bind(this)), 
                i.reset_series(), i.check_archives(), this.series.push(i), this.sync(), this.flot_data.push(e), 
                i;
            }
        }, {
            key: "add_metrics_difference_series",
            value: function(t, e) {
                var i = new T(t, e, this.grid, this.flot_data, this.interval);
                return _(i).on("removed", this.refresh.bind(this)), _(i).on("changed", this.check_archives.bind(this)), 
                i.reset_series(), i.check_archives(), this.series.push(i), this.sync(), this.flot_data.push(e), 
                i;
            }
        }, {
            key: "add_metrics_stacked_instances_series",
            value: function(t, e) {
                var i = new C(t, e, this.grid, this.flot_data, this.interval);
                _(i).on("removed", this.refresh.bind(this)), _(i).on("changed", this.check_archives.bind(this)), 
                i.reset_series(), i.check_archives(), this.series.push(i), this.sync_suppressed++;
                for (var n in i.instances) i.instances[n].reset();
                return this.sync_suppressed--, this.sync(), i;
            }
        }, {
            key: "hover",
            value: function(t, e) {
                this.cur_hover_series != t ? (this.cur_hover_series && this.cur_hover_series.hover(!1), 
                this.cur_hover_series = t, this.cur_hover_val = e, this.cur_hover_series && this.cur_hover_series.hover(this.cur_hover_val)) : this.cur_hover_val != e && (this.cur_hover_val = e, 
                this.cur_hover_series && this.cur_hover_series.hover(this.cur_hover_val));
            }
        }, {
            key: "hover_on",
            value: function(t, e, i) {
                for (var n = null, o = !1, r = 0; r < t.data.series.length; r++) if (o = t.data.series[r].hover_hit(e, i)) {
                    n = t.data.series[r];
                    break;
                }
                t.data.hover(n, o);
            }
        }, {
            key: "hover_off",
            value: function(t) {
                t.data.hover(null, !1);
            }
        }, {
            key: "selecting",
            value: function(t, e) {
                e && _(t.data).triggerHandler("zoomstart", []);
            }
        }, {
            key: "selected",
            value: function(t, e) {
                t.data.flot.clearSelection(!0), _(t.data).triggerHandler("zoom", [ (e.xaxis.to - e.xaxis.from) / 1e3, e.xaxis.to / 1e3 ]);
            }
        } ]), t;
    }(), [ M("month-name", "Jan"), M("month-name", "Feb"), M("month-name", "Mar"), M("month-name", "Apr"), M("month-name", "May"), M("month-name", "Jun"), M("month-name", "Jul"), M("month-name", "Aug"), M("month-name", "Sep"), M("month-name", "Oct"), M("month-name", "Nov"), M("month-name", "Dec") ]);
}, function(t, e) {
    !function(t) {
        t.color = {}, t.color.make = function(e, i, n, o) {
            var r = {};
            return r.r = e || 0, r.g = i || 0, r.b = n || 0, r.a = null != o ? o : 1, r.add = function(t, e) {
                for (var i = 0; i < t.length; ++i) r[t.charAt(i)] += e;
                return r.normalize();
            }, r.scale = function(t, e) {
                for (var i = 0; i < t.length; ++i) r[t.charAt(i)] *= e;
                return r.normalize();
            }, r.toString = function() {
                return r.a >= 1 ? "rgb(" + [ r.r, r.g, r.b ].join(",") + ")" : "rgba(" + [ r.r, r.g, r.b, r.a ].join(",") + ")";
            }, r.normalize = function() {
                function t(t, e, i) {
                    return e < t ? t : e > i ? i : e;
                }
                return r.r = t(0, parseInt(r.r), 255), r.g = t(0, parseInt(r.g), 255), r.b = t(0, parseInt(r.b), 255), 
                r.a = t(0, r.a, 1), r;
            }, r.clone = function() {
                return t.color.make(r.r, r.b, r.g, r.a);
            }, r.normalize();
        }, t.color.extract = function(e, i) {
            var n;
            do {
                if (n = e.css(i).toLowerCase(), "" != n && "transparent" != n) break;
                e = e.parent();
            } while (e.length && !t.nodeName(e.get(0), "body"));
            return "rgba(0, 0, 0, 0)" == n && (n = "transparent"), t.color.parse(n);
        }, t.color.parse = function(i) {
            var n, o = t.color.make;
            if (n = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(i)) return o(parseInt(n[1], 10), parseInt(n[2], 10), parseInt(n[3], 10));
            if (n = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(i)) return o(parseInt(n[1], 10), parseInt(n[2], 10), parseInt(n[3], 10), parseFloat(n[4]));
            if (n = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(i)) return o(2.55 * parseFloat(n[1]), 2.55 * parseFloat(n[2]), 2.55 * parseFloat(n[3]));
            if (n = /rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(i)) return o(2.55 * parseFloat(n[1]), 2.55 * parseFloat(n[2]), 2.55 * parseFloat(n[3]), parseFloat(n[4]));
            if (n = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(i)) return o(parseInt(n[1], 16), parseInt(n[2], 16), parseInt(n[3], 16));
            if (n = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(i)) return o(parseInt(n[1] + n[1], 16), parseInt(n[2] + n[2], 16), parseInt(n[3] + n[3], 16));
            var r = t.trim(i).toLowerCase();
            return "transparent" == r ? o(255, 255, 255, 0) : (n = e[r] || [ 0, 0, 0 ], o(n[0], n[1], n[2]));
        };
        var e = {
            aqua: [ 0, 255, 255 ],
            azure: [ 240, 255, 255 ],
            beige: [ 245, 245, 220 ],
            black: [ 0, 0, 0 ],
            blue: [ 0, 0, 255 ],
            brown: [ 165, 42, 42 ],
            cyan: [ 0, 255, 255 ],
            darkblue: [ 0, 0, 139 ],
            darkcyan: [ 0, 139, 139 ],
            darkgrey: [ 169, 169, 169 ],
            darkgreen: [ 0, 100, 0 ],
            darkkhaki: [ 189, 183, 107 ],
            darkmagenta: [ 139, 0, 139 ],
            darkolivegreen: [ 85, 107, 47 ],
            darkorange: [ 255, 140, 0 ],
            darkorchid: [ 153, 50, 204 ],
            darkred: [ 139, 0, 0 ],
            darksalmon: [ 233, 150, 122 ],
            darkviolet: [ 148, 0, 211 ],
            fuchsia: [ 255, 0, 255 ],
            gold: [ 255, 215, 0 ],
            green: [ 0, 128, 0 ],
            indigo: [ 75, 0, 130 ],
            khaki: [ 240, 230, 140 ],
            lightblue: [ 173, 216, 230 ],
            lightcyan: [ 224, 255, 255 ],
            lightgreen: [ 144, 238, 144 ],
            lightgrey: [ 211, 211, 211 ],
            lightpink: [ 255, 182, 193 ],
            lightyellow: [ 255, 255, 224 ],
            lime: [ 0, 255, 0 ],
            magenta: [ 255, 0, 255 ],
            maroon: [ 128, 0, 0 ],
            navy: [ 0, 0, 128 ],
            olive: [ 128, 128, 0 ],
            orange: [ 255, 165, 0 ],
            pink: [ 255, 192, 203 ],
            purple: [ 128, 0, 128 ],
            violet: [ 128, 0, 128 ],
            red: [ 255, 0, 0 ],
            silver: [ 192, 192, 192 ],
            white: [ 255, 255, 255 ],
            yellow: [ 255, 255, 0 ]
        };
    }(jQuery), function(t) {
        function e(e, i) {
            var n = i.children("." + e)[0];
            if (null == n && (n = document.createElement("canvas"), n.className = e, t(n).css({
                direction: "ltr",
                position: "absolute",
                left: 0,
                top: 0
            }).appendTo(i), !n.getContext)) {
                if (!window.G_vmlCanvasManager) throw new Error("Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.");
                n = window.G_vmlCanvasManager.initElement(n);
            }
            this.element = n;
            var o = this.context = n.getContext("2d"), r = window.devicePixelRatio || 1, a = o.webkitBackingStorePixelRatio || o.mozBackingStorePixelRatio || o.msBackingStorePixelRatio || o.oBackingStorePixelRatio || o.backingStorePixelRatio || 1;
            this.pixelRatio = r / a, this.resize(i.width(), i.height()), this.textContainer = null, 
            this.text = {}, this._textCache = {};
        }
        function i(i, o, r, a) {
            function s(t, e) {
                e = [ gt ].concat(e);
                for (var i = 0; i < t.length; ++i) t[i].apply(this, e);
            }
            function l() {
                for (var i = {
                    Canvas: e
                }, n = 0; n < a.length; ++n) {
                    var o = a[n];
                    o.init(gt, i), o.options && t.extend(!0, ot, o.options);
                }
            }
            function c(e) {
                t.extend(!0, ot, e), e && e.colors && (ot.colors = e.colors), null == ot.xaxis.color && (ot.xaxis.color = t.color.parse(ot.grid.color).scale("a", .22).toString()), 
                null == ot.yaxis.color && (ot.yaxis.color = t.color.parse(ot.grid.color).scale("a", .22).toString()), 
                null == ot.xaxis.tickColor && (ot.xaxis.tickColor = ot.grid.tickColor || ot.xaxis.color), 
                null == ot.yaxis.tickColor && (ot.yaxis.tickColor = ot.grid.tickColor || ot.yaxis.color), 
                null == ot.grid.borderColor && (ot.grid.borderColor = ot.grid.color), null == ot.grid.tickColor && (ot.grid.tickColor = t.color.parse(ot.grid.color).scale("a", .22).toString());
                var n, o, r, a = i.css("font-size"), l = a ? +a.replace("px", "") : 13, c = {
                    style: i.css("font-style"),
                    size: Math.round(.8 * l),
                    variant: i.css("font-variant"),
                    weight: i.css("font-weight"),
                    family: i.css("font-family")
                };
                for (r = ot.xaxes.length || 1, n = 0; n < r; ++n) o = ot.xaxes[n], o && !o.tickColor && (o.tickColor = o.color), 
                o = t.extend(!0, {}, ot.xaxis, o), ot.xaxes[n] = o, o.font && (o.font = t.extend({}, c, o.font), 
                o.font.color || (o.font.color = o.color), o.font.lineHeight || (o.font.lineHeight = Math.round(1.15 * o.font.size)));
                for (r = ot.yaxes.length || 1, n = 0; n < r; ++n) o = ot.yaxes[n], o && !o.tickColor && (o.tickColor = o.color), 
                o = t.extend(!0, {}, ot.yaxis, o), ot.yaxes[n] = o, o.font && (o.font = t.extend({}, c, o.font), 
                o.font.color || (o.font.color = o.color), o.font.lineHeight || (o.font.lineHeight = Math.round(1.15 * o.font.size)));
                for (ot.xaxis.noTicks && null == ot.xaxis.ticks && (ot.xaxis.ticks = ot.xaxis.noTicks), 
                ot.yaxis.noTicks && null == ot.yaxis.ticks && (ot.yaxis.ticks = ot.yaxis.noTicks), 
                ot.x2axis && (ot.xaxes[1] = t.extend(!0, {}, ot.xaxis, ot.x2axis), ot.xaxes[1].position = "top", 
                null == ot.x2axis.min && (ot.xaxes[1].min = null), null == ot.x2axis.max && (ot.xaxes[1].max = null)), 
                ot.y2axis && (ot.yaxes[1] = t.extend(!0, {}, ot.yaxis, ot.y2axis), ot.yaxes[1].position = "right", 
                null == ot.y2axis.min && (ot.yaxes[1].min = null), null == ot.y2axis.max && (ot.yaxes[1].max = null)), 
                ot.grid.coloredAreas && (ot.grid.markings = ot.grid.coloredAreas), ot.grid.coloredAreasColor && (ot.grid.markingsColor = ot.grid.coloredAreasColor), 
                ot.lines && t.extend(!0, ot.series.lines, ot.lines), ot.points && t.extend(!0, ot.series.points, ot.points), 
                ot.bars && t.extend(!0, ot.series.bars, ot.bars), null != ot.shadowSize && (ot.series.shadowSize = ot.shadowSize), 
                null != ot.highlightColor && (ot.series.highlightColor = ot.highlightColor), n = 0; n < ot.xaxes.length; ++n) g(ht, n + 1).options = ot.xaxes[n];
                for (n = 0; n < ot.yaxes.length; ++n) g(ut, n + 1).options = ot.yaxes[n];
                for (var h in pt) ot.hooks[h] && ot.hooks[h].length && (pt[h] = pt[h].concat(ot.hooks[h]));
                s(pt.processOptions, [ ot ]);
            }
            function h(t) {
                nt = u(t), v(), x();
            }
            function u(e) {
                for (var i = [], n = 0; n < e.length; ++n) {
                    var o = t.extend(!0, {}, ot.series);
                    null != e[n].data ? (o.data = e[n].data, delete e[n].data, t.extend(!0, o, e[n]), 
                    e[n].data = o.data) : o.data = e[n], i.push(o);
                }
                return i;
            }
            function f(t, e) {
                var i = t[e + "axis"];
                return "object" == typeof i && (i = i.n), "number" != typeof i && (i = 1), i;
            }
            function d() {
                return t.grep(ht.concat(ut), function(t) {
                    return t;
                });
            }
            function m(t) {
                var e, i, n = {};
                for (e = 0; e < ht.length; ++e) i = ht[e], i && i.used && (n["x" + i.n] = i.c2p(t.left));
                for (e = 0; e < ut.length; ++e) i = ut[e], i && i.used && (n["y" + i.n] = i.c2p(t.top));
                return void 0 !== n.x1 && (n.x = n.x1), void 0 !== n.y1 && (n.y = n.y1), n;
            }
            function p(t) {
                var e, i, n, o = {};
                for (e = 0; e < ht.length; ++e) if (i = ht[e], i && i.used && (n = "x" + i.n, null == t[n] && 1 == i.n && (n = "x"), 
                null != t[n])) {
                    o.left = i.p2c(t[n]);
                    break;
                }
                for (e = 0; e < ut.length; ++e) if (i = ut[e], i && i.used && (n = "y" + i.n, null == t[n] && 1 == i.n && (n = "y"), 
                null != t[n])) {
                    o.top = i.p2c(t[n]);
                    break;
                }
                return o;
            }
            function g(e, i) {
                return e[i - 1] || (e[i - 1] = {
                    n: i,
                    direction: e == ht ? "x" : "y",
                    options: t.extend(!0, {}, e == ht ? ot.xaxis : ot.yaxis)
                }), e[i - 1];
            }
            function v() {
                var e, i = nt.length, n = -1;
                for (e = 0; e < nt.length; ++e) {
                    var o = nt[e].color;
                    null != o && (i--, "number" == typeof o && o > n && (n = o));
                }
                i <= n && (i = n + 1);
                var r, a = [], s = ot.colors, l = s.length, c = 0;
                for (e = 0; e < i; e++) r = t.color.parse(s[e % l] || "#666"), e % l == 0 && e && (c = c >= 0 ? c < .5 ? -c - .2 : 0 : -c), 
                a[e] = r.scale("rgb", 1 + c);
                var h, u = 0;
                for (e = 0; e < nt.length; ++e) {
                    if (h = nt[e], null == h.color ? (h.color = a[u].toString(), ++u) : "number" == typeof h.color && (h.color = a[h.color].toString()), 
                    null == h.lines.show) {
                        var d, m = !0;
                        for (d in h) if (h[d] && h[d].show) {
                            m = !1;
                            break;
                        }
                        m && (h.lines.show = !0);
                    }
                    null == h.lines.zero && (h.lines.zero = !!h.lines.fill), h.xaxis = g(ht, f(h, "x")), 
                    h.yaxis = g(ut, f(h, "y"));
                }
            }
            function x() {
                function e(t, e, i) {
                    e < t.datamin && e != -x && (t.datamin = e), i > t.datamax && i != x && (t.datamax = i);
                }
                var i, n, o, r, a, l, c, h, u, f, m, p, g = Number.POSITIVE_INFINITY, v = Number.NEGATIVE_INFINITY, x = Number.MAX_VALUE;
                for (t.each(d(), function(t, e) {
                    e.datamin = g, e.datamax = v, e.used = !1;
                }), i = 0; i < nt.length; ++i) a = nt[i], a.datapoints = {
                    points: []
                }, s(pt.processRawData, [ a, a.data, a.datapoints ]);
                for (i = 0; i < nt.length; ++i) {
                    if (a = nt[i], m = a.data, p = a.datapoints.format, !p) {
                        if (p = [], p.push({
                            x: !0,
                            number: !0,
                            required: !0
                        }), p.push({
                            y: !0,
                            number: !0,
                            required: !0
                        }), a.bars.show || a.lines.show && a.lines.fill) {
                            var b = !!(a.bars.show && a.bars.zero || a.lines.show && a.lines.zero);
                            p.push({
                                y: !0,
                                number: !0,
                                required: !1,
                                defaultValue: 0,
                                autoscale: b
                            }), a.bars.horizontal && (delete p[p.length - 1].y, p[p.length - 1].x = !0);
                        }
                        a.datapoints.format = p;
                    }
                    if (null == a.datapoints.pointsize) {
                        a.datapoints.pointsize = p.length, c = a.datapoints.pointsize, l = a.datapoints.points;
                        var y = a.lines.show && a.lines.steps;
                        for (a.xaxis.used = a.yaxis.used = !0, n = o = 0; n < m.length; ++n, o += c) {
                            f = m[n];
                            var k = null == f;
                            if (!k) for (r = 0; r < c; ++r) h = f[r], u = p[r], u && (u.number && null != h && (h = +h, 
                            isNaN(h) ? h = null : h == 1 / 0 ? h = x : h == -(1 / 0) && (h = -x)), null == h && (u.required && (k = !0), 
                            null != u.defaultValue && (h = u.defaultValue))), l[o + r] = h;
                            if (k) for (r = 0; r < c; ++r) h = l[o + r], null != h && (u = p[r], u.autoscale !== !1 && (u.x && e(a.xaxis, h, h), 
                            u.y && e(a.yaxis, h, h))), l[o + r] = null; else if (y && o > 0 && null != l[o - c] && l[o - c] != l[o] && l[o - c + 1] != l[o + 1]) {
                                for (r = 0; r < c; ++r) l[o + c + r] = l[o + r];
                                l[o + 1] = l[o - c + 1], o += c;
                            }
                        }
                    }
                }
                for (i = 0; i < nt.length; ++i) a = nt[i], s(pt.processDatapoints, [ a, a.datapoints ]);
                for (i = 0; i < nt.length; ++i) {
                    a = nt[i], l = a.datapoints.points, c = a.datapoints.pointsize, p = a.datapoints.format;
                    var _ = g, w = g, M = v, S = v;
                    for (n = 0; n < l.length; n += c) if (null != l[n]) for (r = 0; r < c; ++r) h = l[n + r], 
                    u = p[r], u && u.autoscale !== !1 && h != x && h != -x && (u.x && (h < _ && (_ = h), 
                    h > M && (M = h)), u.y && (h < w && (w = h), h > S && (S = h)));
                    if (a.bars.show) {
                        var z;
                        switch (a.bars.align) {
                          case "left":
                            z = 0;
                            break;

                          case "right":
                            z = -a.bars.barWidth;
                            break;

                          default:
                            z = -a.bars.barWidth / 2;
                        }
                        a.bars.horizontal ? (w += z, S += z + a.bars.barWidth) : (_ += z, M += z + a.bars.barWidth);
                    }
                    e(a.xaxis, _, M), e(a.yaxis, w, S);
                }
                t.each(d(), function(t, e) {
                    e.datamin == g && (e.datamin = null), e.datamax == v && (e.datamax = null);
                });
            }
            function b() {
                i.css("padding", 0).children().filter(function() {
                    return !t(this).hasClass("flot-overlay") && !t(this).hasClass("flot-base");
                }).remove(), "static" == i.css("position") && i.css("position", "relative"), rt = new e("flot-base", i), 
                at = new e("flot-overlay", i), lt = rt.context, ct = at.context, st = t(at.element).unbind();
                var n = i.data("plot");
                n && (n.shutdown(), at.clear()), i.data("plot", gt);
            }
            function y() {
                ot.grid.hoverable && (st.mousemove(B), st.bind("mouseleave", $)), ot.grid.clickable && st.click(J), 
                s(pt.bindEvents, [ st ]);
            }
            function k() {
                xt && clearTimeout(xt), st.unbind("mousemove", B), st.unbind("mouseleave", $), st.unbind("click", J), 
                s(pt.shutdown, [ st ]);
            }
            function _(t) {
                function e(t) {
                    return t;
                }
                var i, n, o = t.options.transform || e, r = t.options.inverseTransform;
                "x" == t.direction ? (i = t.scale = dt / Math.abs(o(t.max) - o(t.min)), n = Math.min(o(t.max), o(t.min))) : (i = t.scale = mt / Math.abs(o(t.max) - o(t.min)), 
                i = -i, n = Math.max(o(t.max), o(t.min))), o == e ? t.p2c = function(t) {
                    return (t - n) * i;
                } : t.p2c = function(t) {
                    return (o(t) - n) * i;
                }, r ? t.c2p = function(t) {
                    return r(n + t / i);
                } : t.c2p = function(t) {
                    return n + t / i;
                };
            }
            function w(t) {
                for (var e = t.options, i = t.ticks || [], n = e.labelWidth || 0, o = e.labelHeight || 0, r = n || ("x" == t.direction ? Math.floor(rt.width / (i.length || 1)) : null), a = t.direction + "Axis " + t.direction + t.n + "Axis", s = "flot-" + t.direction + "-axis flot-" + t.direction + t.n + "-axis " + a, l = e.font || "flot-tick-label tickLabel", c = 0; c < i.length; ++c) {
                    var h = i[c];
                    if (h.label) {
                        var u = rt.getTextInfo(s, h.label, l, null, r);
                        n = Math.max(n, u.width), o = Math.max(o, u.height);
                    }
                }
                t.labelWidth = e.labelWidth || n, t.labelHeight = e.labelHeight || o;
            }
            function M(e) {
                var i = e.labelWidth, n = e.labelHeight, o = e.options.position, r = "x" === e.direction, a = e.options.tickLength, s = ot.grid.axisMargin, l = ot.grid.labelMargin, c = !0, h = !0, u = !0, f = !1;
                t.each(r ? ht : ut, function(t, i) {
                    i && (i.show || i.reserveSpace) && (i === e ? f = !0 : i.options.position === o && (f ? h = !1 : c = !1), 
                    f || (u = !1));
                }), h && (s = 0), null == a && (a = u ? "full" : 5), isNaN(+a) || (l += +a), r ? (n += l, 
                "bottom" == o ? (ft.bottom += n + s, e.box = {
                    top: rt.height - ft.bottom,
                    height: n
                }) : (e.box = {
                    top: ft.top + s,
                    height: n
                }, ft.top += n + s)) : (i += l, "left" == o ? (e.box = {
                    left: ft.left + s,
                    width: i
                }, ft.left += i + s) : (ft.right += i + s, e.box = {
                    left: rt.width - ft.right,
                    width: i
                })), e.position = o, e.tickLength = a, e.box.padding = l, e.innermost = c;
            }
            function S(t) {
                "x" == t.direction ? (t.box.left = ft.left - t.labelWidth / 2, t.box.width = rt.width - ft.left - ft.right + t.labelWidth) : (t.box.top = ft.top - t.labelHeight / 2, 
                t.box.height = rt.height - ft.bottom - ft.top + t.labelHeight);
            }
            function z() {
                var e, i = ot.grid.minBorderMargin;
                if (null == i) for (i = 0, e = 0; e < nt.length; ++e) i = Math.max(i, 2 * (nt[e].points.radius + nt[e].points.lineWidth / 2));
                var n = {
                    left: i,
                    right: i,
                    top: i,
                    bottom: i
                };
                t.each(d(), function(t, e) {
                    e.reserveSpace && e.ticks && e.ticks.length && ("x" === e.direction ? (n.left = Math.max(n.left, e.labelWidth / 2), 
                    n.right = Math.max(n.right, e.labelWidth / 2)) : (n.bottom = Math.max(n.bottom, e.labelHeight / 2), 
                    n.top = Math.max(n.top, e.labelHeight / 2)));
                }), ft.left = Math.ceil(Math.max(n.left, ft.left)), ft.right = Math.ceil(Math.max(n.right, ft.right)), 
                ft.top = Math.ceil(Math.max(n.top, ft.top)), ft.bottom = Math.ceil(Math.max(n.bottom, ft.bottom));
            }
            function T() {
                var e, i = d(), n = ot.grid.show;
                for (var o in ft) {
                    var r = ot.grid.margin || 0;
                    ft[o] = "number" == typeof r ? r : r[o] || 0;
                }
                s(pt.processOffset, [ ft ]);
                for (var o in ft) "object" == typeof ot.grid.borderWidth ? ft[o] += n ? ot.grid.borderWidth[o] : 0 : ft[o] += n ? ot.grid.borderWidth : 0;
                if (t.each(i, function(t, e) {
                    var i = e.options;
                    e.show = null == i.show ? e.used : i.show, e.reserveSpace = null == i.reserveSpace ? e.show : i.reserveSpace, 
                    C(e);
                }), n) {
                    var a = t.grep(i, function(t) {
                        return t.show || t.reserveSpace;
                    });
                    for (t.each(a, function(t, e) {
                        W(e), D(e), A(e, e.ticks), w(e);
                    }), e = a.length - 1; e >= 0; --e) M(a[e]);
                    z(), t.each(a, function(t, e) {
                        S(e);
                    });
                }
                dt = rt.width - ft.left - ft.right, mt = rt.height - ft.bottom - ft.top, t.each(i, function(t, e) {
                    _(e);
                }), n && N(), L();
            }
            function C(t) {
                var e = t.options, i = +(null != e.min ? e.min : t.datamin), n = +(null != e.max ? e.max : t.datamax), o = n - i;
                if (0 == o) {
                    var r = 0 == n ? 1 : .01;
                    null == e.min && (i -= r), null != e.max && null == e.min || (n += r);
                } else {
                    var a = e.autoscaleMargin;
                    null != a && (null == e.min && (i -= o * a, i < 0 && null != t.datamin && t.datamin >= 0 && (i = 0)), 
                    null == e.max && (n += o * a, n > 0 && null != t.datamax && t.datamax <= 0 && (n = 0)));
                }
                t.min = i, t.max = n;
            }
            function W(e) {
                var i, o = e.options;
                i = "number" == typeof o.ticks && o.ticks > 0 ? o.ticks : .3 * Math.sqrt("x" == e.direction ? rt.width : rt.height);
                var r = (e.max - e.min) / i, a = -Math.floor(Math.log(r) / Math.LN10), s = o.tickDecimals;
                null != s && a > s && (a = s);
                var l, c = Math.pow(10, -a), h = r / c;
                if (h < 1.5 ? l = 1 : h < 3 ? (l = 2, h > 2.25 && (null == s || a + 1 <= s) && (l = 2.5, 
                ++a)) : l = h < 7.5 ? 5 : 10, l *= c, null != o.minTickSize && l < o.minTickSize && (l = o.minTickSize), 
                e.delta = r, e.tickDecimals = Math.max(0, null != s ? s : a), e.tickSize = o.tickSize || l, 
                "time" == o.mode && !e.tickGenerator) throw new Error("Time mode requires the flot.time plugin.");
                if (e.tickGenerator || (e.tickGenerator = function(t) {
                    var e, i = [], o = n(t.min, t.tickSize), r = 0, a = Number.NaN;
                    do e = a, a = o + r * t.tickSize, i.push(a), ++r; while (a < t.max && a != e);
                    return i;
                }, e.tickFormatter = function(t, e) {
                    var i = e.tickDecimals ? Math.pow(10, e.tickDecimals) : 1, n = "" + Math.round(t * i) / i;
                    if (null != e.tickDecimals) {
                        var o = n.indexOf("."), r = o == -1 ? 0 : n.length - o - 1;
                        if (r < e.tickDecimals) return (r ? n : n + ".") + ("" + i).substr(1, e.tickDecimals - r);
                    }
                    return n;
                }), t.isFunction(o.tickFormatter) && (e.tickFormatter = function(t, e) {
                    return "" + o.tickFormatter(t, e);
                }), null != o.alignTicksWithAxis) {
                    var u = ("x" == e.direction ? ht : ut)[o.alignTicksWithAxis - 1];
                    if (u && u.used && u != e) {
                        var f = e.tickGenerator(e);
                        if (f.length > 0 && (null == o.min && (e.min = Math.min(e.min, f[0])), null == o.max && f.length > 1 && (e.max = Math.max(e.max, f[f.length - 1]))), 
                        e.tickGenerator = function(t) {
                            var e, i, n = [];
                            for (i = 0; i < u.ticks.length; ++i) e = (u.ticks[i].v - u.min) / (u.max - u.min), 
                            e = t.min + e * (t.max - t.min), n.push(e);
                            return n;
                        }, !e.mode && null == o.tickDecimals) {
                            var d = Math.max(0, -Math.floor(Math.log(e.delta) / Math.LN10) + 1), m = e.tickGenerator(e);
                            m.length > 1 && /\..*0$/.test((m[1] - m[0]).toFixed(d)) || (e.tickDecimals = d);
                        }
                    }
                }
            }
            function D(e) {
                var i = e.options.ticks, n = [];
                null == i || "number" == typeof i && i > 0 ? n = e.tickGenerator(e) : i && (n = t.isFunction(i) ? i(e) : i);
                var o, r;
                for (e.ticks = [], o = 0; o < n.length; ++o) {
                    var a = null, s = n[o];
                    "object" == typeof s ? (r = +s[0], s.length > 1 && (a = s[1])) : r = +s, null == a && (a = e.tickFormatter(r, e)), 
                    isNaN(r) || e.ticks.push({
                        v: r,
                        label: a
                    });
                }
            }
            function A(t, e) {
                t.options.autoscaleMargin && e.length > 0 && (null == t.options.min && (t.min = Math.min(t.min, e[0].v)), 
                null == t.options.max && e.length > 1 && (t.max = Math.max(t.max, e[e.length - 1].v)));
            }
            function O() {
                rt.clear(), s(pt.drawBackground, [ lt ]);
                var t = ot.grid;
                t.show && t.backgroundColor && P(), t.show && !t.aboveData && I();
                for (var e = 0; e < nt.length; ++e) s(pt.drawSeries, [ lt, nt[e] ]), H(nt[e]);
                s(pt.draw, [ lt ]), t.show && t.aboveData && I(), rt.render(), Q();
            }
            function F(t, e) {
                for (var i, n, o, r, a = d(), s = 0; s < a.length; ++s) if (i = a[s], i.direction == e && (r = e + i.n + "axis", 
                t[r] || 1 != i.n || (r = e + "axis"), t[r])) {
                    n = t[r].from, o = t[r].to;
                    break;
                }
                if (t[r] || (i = "x" == e ? ht[0] : ut[0], n = t[e + "1"], o = t[e + "2"]), null != n && null != o && n > o) {
                    var l = n;
                    n = o, o = l;
                }
                return {
                    from: n,
                    to: o,
                    axis: i
                };
            }
            function P() {
                lt.save(), lt.translate(ft.left, ft.top), lt.fillStyle = it(ot.grid.backgroundColor, mt, 0, "rgba(255, 255, 255, 0)"), 
                lt.fillRect(0, 0, dt, mt), lt.restore();
            }
            function I() {
                var e, i, n, o;
                lt.save(), lt.translate(ft.left, ft.top);
                var r = ot.grid.markings;
                if (r) for (t.isFunction(r) && (i = gt.getAxes(), i.xmin = i.xaxis.min, i.xmax = i.xaxis.max, 
                i.ymin = i.yaxis.min, i.ymax = i.yaxis.max, r = r(i)), e = 0; e < r.length; ++e) {
                    var a = r[e], s = F(a, "x"), l = F(a, "y");
                    if (null == s.from && (s.from = s.axis.min), null == s.to && (s.to = s.axis.max), 
                    null == l.from && (l.from = l.axis.min), null == l.to && (l.to = l.axis.max), !(s.to < s.axis.min || s.from > s.axis.max || l.to < l.axis.min || l.from > l.axis.max)) {
                        s.from = Math.max(s.from, s.axis.min), s.to = Math.min(s.to, s.axis.max), l.from = Math.max(l.from, l.axis.min), 
                        l.to = Math.min(l.to, l.axis.max);
                        var c = s.from === s.to, h = l.from === l.to;
                        if (!c || !h) if (s.from = Math.floor(s.axis.p2c(s.from)), s.to = Math.floor(s.axis.p2c(s.to)), 
                        l.from = Math.floor(l.axis.p2c(l.from)), l.to = Math.floor(l.axis.p2c(l.to)), c || h) {
                            var u = a.lineWidth || ot.grid.markingsLineWidth, f = u % 2 ? .5 : 0;
                            lt.beginPath(), lt.strokeStyle = a.color || ot.grid.markingsColor, lt.lineWidth = u, 
                            c ? (lt.moveTo(s.to + f, l.from), lt.lineTo(s.to + f, l.to)) : (lt.moveTo(s.from, l.to + f), 
                            lt.lineTo(s.to, l.to + f)), lt.stroke();
                        } else lt.fillStyle = a.color || ot.grid.markingsColor, lt.fillRect(s.from, l.to, s.to - s.from, l.from - l.to);
                    }
                }
                i = d(), n = ot.grid.borderWidth;
                for (var m = 0; m < i.length; ++m) {
                    var p, g, v, x, b = i[m], y = b.box, k = b.tickLength;
                    if (b.show && 0 != b.ticks.length) {
                        for (lt.lineWidth = 1, "x" == b.direction ? (p = 0, g = "full" == k ? "top" == b.position ? 0 : mt : y.top - ft.top + ("top" == b.position ? y.height : 0)) : (g = 0, 
                        p = "full" == k ? "left" == b.position ? 0 : dt : y.left - ft.left + ("left" == b.position ? y.width : 0)), 
                        b.innermost || (lt.strokeStyle = b.options.color, lt.beginPath(), v = x = 0, "x" == b.direction ? v = dt + 1 : x = mt + 1, 
                        1 == lt.lineWidth && ("x" == b.direction ? g = Math.floor(g) + .5 : p = Math.floor(p) + .5), 
                        lt.moveTo(p, g), lt.lineTo(p + v, g + x), lt.stroke()), lt.strokeStyle = b.options.tickColor, 
                        lt.beginPath(), e = 0; e < b.ticks.length; ++e) {
                            var _ = b.ticks[e].v;
                            v = x = 0, isNaN(_) || _ < b.min || _ > b.max || "full" == k && ("object" == typeof n && n[b.position] > 0 || n > 0) && (_ == b.min || _ == b.max) || ("x" == b.direction ? (p = b.p2c(_), 
                            x = "full" == k ? -mt : k, "top" == b.position && (x = -x)) : (g = b.p2c(_), v = "full" == k ? -dt : k, 
                            "left" == b.position && (v = -v)), 1 == lt.lineWidth && ("x" == b.direction ? p = Math.floor(p) + .5 : g = Math.floor(g) + .5), 
                            lt.moveTo(p, g), lt.lineTo(p + v, g + x));
                        }
                        lt.stroke();
                    }
                }
                n && (o = ot.grid.borderColor, "object" == typeof n || "object" == typeof o ? ("object" != typeof n && (n = {
                    top: n,
                    right: n,
                    bottom: n,
                    left: n
                }), "object" != typeof o && (o = {
                    top: o,
                    right: o,
                    bottom: o,
                    left: o
                }), n.top > 0 && (lt.strokeStyle = o.top, lt.lineWidth = n.top, lt.beginPath(), 
                lt.moveTo(0 - n.left, 0 - n.top / 2), lt.lineTo(dt, 0 - n.top / 2), lt.stroke()), 
                n.right > 0 && (lt.strokeStyle = o.right, lt.lineWidth = n.right, lt.beginPath(), 
                lt.moveTo(dt + n.right / 2, 0 - n.top), lt.lineTo(dt + n.right / 2, mt), lt.stroke()), 
                n.bottom > 0 && (lt.strokeStyle = o.bottom, lt.lineWidth = n.bottom, lt.beginPath(), 
                lt.moveTo(dt + n.right, mt + n.bottom / 2), lt.lineTo(0, mt + n.bottom / 2), lt.stroke()), 
                n.left > 0 && (lt.strokeStyle = o.left, lt.lineWidth = n.left, lt.beginPath(), lt.moveTo(0 - n.left / 2, mt + n.bottom), 
                lt.lineTo(0 - n.left / 2, 0), lt.stroke())) : (lt.lineWidth = n, lt.strokeStyle = ot.grid.borderColor, 
                lt.strokeRect(-n / 2, -n / 2, dt + n, mt + n))), lt.restore();
            }
            function N() {
                t.each(d(), function(t, e) {
                    var i, n, o, r, a, s = e.box, l = e.direction + "Axis " + e.direction + e.n + "Axis", c = "flot-" + e.direction + "-axis flot-" + e.direction + e.n + "-axis " + l, h = e.options.font || "flot-tick-label tickLabel";
                    if (rt.removeText(c), e.show && 0 != e.ticks.length) for (var u = 0; u < e.ticks.length; ++u) i = e.ticks[u], 
                    !i.label || i.v < e.min || i.v > e.max || ("x" == e.direction ? (r = "center", n = ft.left + e.p2c(i.v), 
                    "bottom" == e.position ? o = s.top + s.padding : (o = s.top + s.height - s.padding, 
                    a = "bottom")) : (a = "middle", o = ft.top + e.p2c(i.v), "left" == e.position ? (n = s.left + s.width - s.padding, 
                    r = "right") : n = s.left + s.padding), rt.addText(c, n, o, i.label, h, null, null, r, a));
                });
            }
            function H(t) {
                t.lines.show && j(t), t.bars.show && Y(t), t.points.show && E(t);
            }
            function j(t) {
                function e(t, e, i, n, o) {
                    var r = t.points, a = t.pointsize, s = null, l = null;
                    lt.beginPath();
                    for (var c = a; c < r.length; c += a) {
                        var h = r[c - a], u = r[c - a + 1], f = r[c], d = r[c + 1];
                        if (null != h && null != f) {
                            if (u <= d && u < o.min) {
                                if (d < o.min) continue;
                                h = (o.min - u) / (d - u) * (f - h) + h, u = o.min;
                            } else if (d <= u && d < o.min) {
                                if (u < o.min) continue;
                                f = (o.min - u) / (d - u) * (f - h) + h, d = o.min;
                            }
                            if (u >= d && u > o.max) {
                                if (d > o.max) continue;
                                h = (o.max - u) / (d - u) * (f - h) + h, u = o.max;
                            } else if (d >= u && d > o.max) {
                                if (u > o.max) continue;
                                f = (o.max - u) / (d - u) * (f - h) + h, d = o.max;
                            }
                            if (h <= f && h < n.min) {
                                if (f < n.min) continue;
                                u = (n.min - h) / (f - h) * (d - u) + u, h = n.min;
                            } else if (f <= h && f < n.min) {
                                if (h < n.min) continue;
                                d = (n.min - h) / (f - h) * (d - u) + u, f = n.min;
                            }
                            if (h >= f && h > n.max) {
                                if (f > n.max) continue;
                                u = (n.max - h) / (f - h) * (d - u) + u, h = n.max;
                            } else if (f >= h && f > n.max) {
                                if (h > n.max) continue;
                                d = (n.max - h) / (f - h) * (d - u) + u, f = n.max;
                            }
                            h == s && u == l || lt.moveTo(n.p2c(h) + e, o.p2c(u) + i), s = f, l = d, lt.lineTo(n.p2c(f) + e, o.p2c(d) + i);
                        }
                    }
                    lt.stroke();
                }
                function i(t, e, i) {
                    for (var n = t.points, o = t.pointsize, r = Math.min(Math.max(0, i.min), i.max), a = 0, s = !1, l = 1, c = 0, h = 0; ;) {
                        if (o > 0 && a > n.length + o) break;
                        a += o;
                        var u = n[a - o], f = n[a - o + l], d = n[a], m = n[a + l];
                        if (s) {
                            if (o > 0 && null != u && null == d) {
                                h = a, o = -o, l = 2;
                                continue;
                            }
                            if (o < 0 && a == c + o) {
                                lt.fill(), s = !1, o = -o, l = 1, a = c = h + o;
                                continue;
                            }
                        }
                        if (null != u && null != d) {
                            if (u <= d && u < e.min) {
                                if (d < e.min) continue;
                                f = (e.min - u) / (d - u) * (m - f) + f, u = e.min;
                            } else if (d <= u && d < e.min) {
                                if (u < e.min) continue;
                                m = (e.min - u) / (d - u) * (m - f) + f, d = e.min;
                            }
                            if (u >= d && u > e.max) {
                                if (d > e.max) continue;
                                f = (e.max - u) / (d - u) * (m - f) + f, u = e.max;
                            } else if (d >= u && d > e.max) {
                                if (u > e.max) continue;
                                m = (e.max - u) / (d - u) * (m - f) + f, d = e.max;
                            }
                            if (s || (lt.beginPath(), lt.moveTo(e.p2c(u), i.p2c(r)), s = !0), f >= i.max && m >= i.max) lt.lineTo(e.p2c(u), i.p2c(i.max)), 
                            lt.lineTo(e.p2c(d), i.p2c(i.max)); else if (f <= i.min && m <= i.min) lt.lineTo(e.p2c(u), i.p2c(i.min)), 
                            lt.lineTo(e.p2c(d), i.p2c(i.min)); else {
                                var p = u, g = d;
                                f <= m && f < i.min && m >= i.min ? (u = (i.min - f) / (m - f) * (d - u) + u, f = i.min) : m <= f && m < i.min && f >= i.min && (d = (i.min - f) / (m - f) * (d - u) + u, 
                                m = i.min), f >= m && f > i.max && m <= i.max ? (u = (i.max - f) / (m - f) * (d - u) + u, 
                                f = i.max) : m >= f && m > i.max && f <= i.max && (d = (i.max - f) / (m - f) * (d - u) + u, 
                                m = i.max), u != p && lt.lineTo(e.p2c(p), i.p2c(f)), lt.lineTo(e.p2c(u), i.p2c(f)), 
                                lt.lineTo(e.p2c(d), i.p2c(m)), d != g && (lt.lineTo(e.p2c(d), i.p2c(m)), lt.lineTo(e.p2c(g), i.p2c(m)));
                            }
                        }
                    }
                }
                lt.save(), lt.translate(ft.left, ft.top), lt.lineJoin = "round";
                var n = t.lines.lineWidth, o = t.shadowSize;
                if (n > 0 && o > 0) {
                    lt.lineWidth = o, lt.strokeStyle = "rgba(0,0,0,0.1)";
                    var r = Math.PI / 18;
                    e(t.datapoints, Math.sin(r) * (n / 2 + o / 2), Math.cos(r) * (n / 2 + o / 2), t.xaxis, t.yaxis), 
                    lt.lineWidth = o / 2, e(t.datapoints, Math.sin(r) * (n / 2 + o / 4), Math.cos(r) * (n / 2 + o / 4), t.xaxis, t.yaxis);
                }
                lt.lineWidth = n, lt.strokeStyle = t.color;
                var a = q(t.lines, t.color, 0, mt);
                a && (lt.fillStyle = a, i(t.datapoints, t.xaxis, t.yaxis)), n > 0 && e(t.datapoints, 0, 0, t.xaxis, t.yaxis), 
                lt.restore();
            }
            function E(t) {
                function e(t, e, i, n, o, r, a, s) {
                    for (var l = t.points, c = t.pointsize, h = 0; h < l.length; h += c) {
                        var u = l[h], f = l[h + 1];
                        null == u || u < r.min || u > r.max || f < a.min || f > a.max || (lt.beginPath(), 
                        u = r.p2c(u), f = a.p2c(f) + n, "circle" == s ? lt.arc(u, f, e, 0, o ? Math.PI : 2 * Math.PI, !1) : s(lt, u, f, e, o), 
                        lt.closePath(), i && (lt.fillStyle = i, lt.fill()), lt.stroke());
                    }
                }
                lt.save(), lt.translate(ft.left, ft.top);
                var i = t.points.lineWidth, n = t.shadowSize, o = t.points.radius, r = t.points.symbol;
                if (0 == i && (i = 1e-4), i > 0 && n > 0) {
                    var a = n / 2;
                    lt.lineWidth = a, lt.strokeStyle = "rgba(0,0,0,0.1)", e(t.datapoints, o, null, a + a / 2, !0, t.xaxis, t.yaxis, r), 
                    lt.strokeStyle = "rgba(0,0,0,0.2)", e(t.datapoints, o, null, a / 2, !0, t.xaxis, t.yaxis, r);
                }
                lt.lineWidth = i, lt.strokeStyle = t.color, e(t.datapoints, o, q(t.points, t.color), 0, !1, t.xaxis, t.yaxis, r), 
                lt.restore();
            }
            function R(t, e, i, n, o, r, a, s, l, c, h) {
                var u, f, d, m, p, g, v, x, b;
                c ? (x = g = v = !0, p = !1, u = i, f = t, m = e + n, d = e + o, f < u && (b = f, 
                f = u, u = b, p = !0, g = !1)) : (p = g = v = !0, x = !1, u = t + n, f = t + o, 
                d = i, m = e, m < d && (b = m, m = d, d = b, x = !0, v = !1)), f < a.min || u > a.max || m < s.min || d > s.max || (u < a.min && (u = a.min, 
                p = !1), f > a.max && (f = a.max, g = !1), d < s.min && (d = s.min, x = !1), m > s.max && (m = s.max, 
                v = !1), u = a.p2c(u), d = s.p2c(d), f = a.p2c(f), m = s.p2c(m), r && (l.fillStyle = r(d, m), 
                l.fillRect(u, m, f - u, d - m)), h > 0 && (p || g || v || x) && (l.beginPath(), 
                l.moveTo(u, d), p ? l.lineTo(u, m) : l.moveTo(u, m), v ? l.lineTo(f, m) : l.moveTo(f, m), 
                g ? l.lineTo(f, d) : l.moveTo(f, d), x ? l.lineTo(u, d) : l.moveTo(u, d), l.stroke()));
            }
            function Y(t) {
                function e(e, i, n, o, r, a) {
                    for (var s = e.points, l = e.pointsize, c = 0; c < s.length; c += l) null != s[c] && R(s[c], s[c + 1], s[c + 2], i, n, o, r, a, lt, t.bars.horizontal, t.bars.lineWidth);
                }
                lt.save(), lt.translate(ft.left, ft.top), lt.lineWidth = t.bars.lineWidth, lt.strokeStyle = t.color;
                var i;
                switch (t.bars.align) {
                  case "left":
                    i = 0;
                    break;

                  case "right":
                    i = -t.bars.barWidth;
                    break;

                  default:
                    i = -t.bars.barWidth / 2;
                }
                var n = t.bars.fill ? function(e, i) {
                    return q(t.bars, t.color, e, i);
                } : null;
                e(t.datapoints, i, i + t.bars.barWidth, n, t.xaxis, t.yaxis), lt.restore();
            }
            function q(e, i, n, o) {
                var r = e.fill;
                if (!r) return null;
                if (e.fillColor) return it(e.fillColor, n, o, i);
                var a = t.color.parse(i);
                return a.a = "number" == typeof r ? r : .4, a.normalize(), a.toString();
            }
            function L() {
                if (null != ot.legend.container ? t(ot.legend.container).html("") : i.find(".legend").remove(), 
                ot.legend.show) {
                    for (var e, n, o = [], r = [], a = !1, s = ot.legend.labelFormatter, l = 0; l < nt.length; ++l) e = nt[l], 
                    e.label && (n = s ? s(e.label, e) : e.label, n && r.push({
                        label: n,
                        color: e.color
                    }));
                    if (ot.legend.sorted) if (t.isFunction(ot.legend.sorted)) r.sort(ot.legend.sorted); else if ("reverse" == ot.legend.sorted) r.reverse(); else {
                        var c = "descending" != ot.legend.sorted;
                        r.sort(function(t, e) {
                            return t.label == e.label ? 0 : t.label < e.label != c ? 1 : -1;
                        });
                    }
                    for (var l = 0; l < r.length; ++l) {
                        var h = r[l];
                        l % ot.legend.noColumns == 0 && (a && o.push("</tr>"), o.push("<tr>"), a = !0), 
                        o.push('<td class="legendColorBox"><div style="border:1px solid ' + ot.legend.labelBoxBorderColor + ';padding:1px"><div style="width:4px;height:0;border:5px solid ' + h.color + ';overflow:hidden"></div></div></td><td class="legendLabel">' + h.label + "</td>");
                    }
                    if (a && o.push("</tr>"), 0 != o.length) {
                        var u = '<table style="font-size:smaller;color:' + ot.grid.color + '">' + o.join("") + "</table>";
                        if (null != ot.legend.container) t(ot.legend.container).html(u); else {
                            var f = "", d = ot.legend.position, m = ot.legend.margin;
                            null == m[0] && (m = [ m, m ]), "n" == d.charAt(0) ? f += "top:" + (m[1] + ft.top) + "px;" : "s" == d.charAt(0) && (f += "bottom:" + (m[1] + ft.bottom) + "px;"), 
                            "e" == d.charAt(1) ? f += "right:" + (m[0] + ft.right) + "px;" : "w" == d.charAt(1) && (f += "left:" + (m[0] + ft.left) + "px;");
                            var p = t('<div class="legend">' + u.replace('style="', 'style="position:absolute;' + f + ";") + "</div>").appendTo(i);
                            if (0 != ot.legend.backgroundOpacity) {
                                var g = ot.legend.backgroundColor;
                                null == g && (g = ot.grid.backgroundColor, g = g && "string" == typeof g ? t.color.parse(g) : t.color.extract(p, "background-color"), 
                                g.a = 1, g = g.toString());
                                var v = p.children();
                                t('<div style="position:absolute;width:' + v.width() + "px;height:" + v.height() + "px;" + f + "background-color:" + g + ';"> </div>').prependTo(p).css("opacity", ot.legend.backgroundOpacity);
                            }
                        }
                    }
                }
            }
            function G(t, e, i) {
                var n, o, r, a = ot.grid.mouseActiveRadius, s = a * a + 1, l = null;
                for (n = nt.length - 1; n >= 0; --n) if (i(nt[n])) {
                    var c = nt[n], h = c.xaxis, u = c.yaxis, f = c.datapoints.points, d = h.c2p(t), m = u.c2p(e), p = a / h.scale, g = a / u.scale;
                    if (r = c.datapoints.pointsize, h.options.inverseTransform && (p = Number.MAX_VALUE), 
                    u.options.inverseTransform && (g = Number.MAX_VALUE), c.lines.show || c.points.show) for (o = 0; o < f.length; o += r) {
                        var v = f[o], x = f[o + 1];
                        if (null != v && !(v - d > p || v - d < -p || x - m > g || x - m < -g)) {
                            var b = Math.abs(h.p2c(v) - t), y = Math.abs(u.p2c(x) - e), k = b * b + y * y;
                            k < s && (s = k, l = [ n, o / r ]);
                        }
                    }
                    if (c.bars.show && !l) {
                        var _, w;
                        switch (c.bars.align) {
                          case "left":
                            _ = 0;
                            break;

                          case "right":
                            _ = -c.bars.barWidth;
                            break;

                          default:
                            _ = -c.bars.barWidth / 2;
                        }
                        for (w = _ + c.bars.barWidth, o = 0; o < f.length; o += r) {
                            var v = f[o], x = f[o + 1], M = f[o + 2];
                            null != v && (nt[n].bars.horizontal ? d <= Math.max(M, v) && d >= Math.min(M, v) && m >= x + _ && m <= x + w : d >= v + _ && d <= v + w && m >= Math.min(M, x) && m <= Math.max(M, x)) && (l = [ n, o / r ]);
                        }
                    }
                }
                return l ? (n = l[0], o = l[1], r = nt[n].datapoints.pointsize, {
                    datapoint: nt[n].datapoints.points.slice(o * r, (o + 1) * r),
                    dataIndex: o,
                    series: nt[n],
                    seriesIndex: n
                }) : null;
            }
            function B(t) {
                ot.grid.hoverable && X("plothover", t, function(t) {
                    return 0 != t.hoverable;
                });
            }
            function $(t) {
                ot.grid.hoverable && X("plothover", t, function(t) {
                    return !1;
                });
            }
            function J(t) {
                X("plotclick", t, function(t) {
                    return 0 != t.clickable;
                });
            }
            function X(t, e, n) {
                var o = st.offset(), r = e.pageX - o.left - ft.left, a = e.pageY - o.top - ft.top, s = m({
                    left: r,
                    top: a
                });
                s.pageX = e.pageX, s.pageY = e.pageY;
                var l = G(r, a, n);
                if (l && (l.pageX = parseInt(l.series.xaxis.p2c(l.datapoint[0]) + o.left + ft.left, 10), 
                l.pageY = parseInt(l.series.yaxis.p2c(l.datapoint[1]) + o.top + ft.top, 10)), ot.grid.autoHighlight) {
                    for (var c = 0; c < vt.length; ++c) {
                        var h = vt[c];
                        h.auto != t || l && h.series == l.series && h.point[0] == l.datapoint[0] && h.point[1] == l.datapoint[1] || K(h.series, h.point);
                    }
                    l && U(l.series, l.datapoint, t);
                }
                i.trigger(t, [ s, l ]);
            }
            function Q() {
                var t = ot.interaction.redrawOverlayInterval;
                return t == -1 ? void V() : void (xt || (xt = setTimeout(V, t)));
            }
            function V() {
                xt = null, ct.save(), at.clear(), ct.translate(ft.left, ft.top);
                var t, e;
                for (t = 0; t < vt.length; ++t) e = vt[t], e.series.bars.show ? et(e.series, e.point) : tt(e.series, e.point);
                ct.restore(), s(pt.drawOverlay, [ ct ]);
            }
            function U(t, e, i) {
                if ("number" == typeof t && (t = nt[t]), "number" == typeof e) {
                    var n = t.datapoints.pointsize;
                    e = t.datapoints.points.slice(n * e, n * (e + 1));
                }
                var o = Z(t, e);
                o == -1 ? (vt.push({
                    series: t,
                    point: e,
                    auto: i
                }), Q()) : i || (vt[o].auto = !1);
            }
            function K(t, e) {
                if (null == t && null == e) return vt = [], void Q();
                if ("number" == typeof t && (t = nt[t]), "number" == typeof e) {
                    var i = t.datapoints.pointsize;
                    e = t.datapoints.points.slice(i * e, i * (e + 1));
                }
                var n = Z(t, e);
                n != -1 && (vt.splice(n, 1), Q());
            }
            function Z(t, e) {
                for (var i = 0; i < vt.length; ++i) {
                    var n = vt[i];
                    if (n.series == t && n.point[0] == e[0] && n.point[1] == e[1]) return i;
                }
                return -1;
            }
            function tt(e, i) {
                var n = i[0], o = i[1], r = e.xaxis, a = e.yaxis, s = "string" == typeof e.highlightColor ? e.highlightColor : t.color.parse(e.color).scale("a", .5).toString();
                if (!(n < r.min || n > r.max || o < a.min || o > a.max)) {
                    var l = e.points.radius + e.points.lineWidth / 2;
                    ct.lineWidth = l, ct.strokeStyle = s;
                    var c = 1.5 * l;
                    n = r.p2c(n), o = a.p2c(o), ct.beginPath(), "circle" == e.points.symbol ? ct.arc(n, o, c, 0, 2 * Math.PI, !1) : e.points.symbol(ct, n, o, c, !1), 
                    ct.closePath(), ct.stroke();
                }
            }
            function et(e, i) {
                var n, o = "string" == typeof e.highlightColor ? e.highlightColor : t.color.parse(e.color).scale("a", .5).toString(), r = o;
                switch (e.bars.align) {
                  case "left":
                    n = 0;
                    break;

                  case "right":
                    n = -e.bars.barWidth;
                    break;

                  default:
                    n = -e.bars.barWidth / 2;
                }
                ct.lineWidth = e.bars.lineWidth, ct.strokeStyle = o, R(i[0], i[1], i[2] || 0, n, n + e.bars.barWidth, function() {
                    return r;
                }, e.xaxis, e.yaxis, ct, e.bars.horizontal, e.bars.lineWidth);
            }
            function it(e, i, n, o) {
                if ("string" == typeof e) return e;
                for (var r = lt.createLinearGradient(0, n, 0, i), a = 0, s = e.colors.length; a < s; ++a) {
                    var l = e.colors[a];
                    if ("string" != typeof l) {
                        var c = t.color.parse(o);
                        null != l.brightness && (c = c.scale("rgb", l.brightness)), null != l.opacity && (c.a *= l.opacity), 
                        l = c.toString();
                    }
                    r.addColorStop(a / (s - 1), l);
                }
                return r;
            }
            var nt = [], ot = {
                colors: [ "#edc240", "#afd8f8", "#cb4b4b", "#4da74d", "#9440ed" ],
                legend: {
                    show: !0,
                    noColumns: 1,
                    labelFormatter: null,
                    labelBoxBorderColor: "#ccc",
                    container: null,
                    position: "ne",
                    margin: 5,
                    backgroundColor: null,
                    backgroundOpacity: .85,
                    sorted: null
                },
                xaxis: {
                    show: null,
                    position: "bottom",
                    mode: null,
                    font: null,
                    color: null,
                    tickColor: null,
                    transform: null,
                    inverseTransform: null,
                    min: null,
                    max: null,
                    autoscaleMargin: null,
                    ticks: null,
                    tickFormatter: null,
                    labelWidth: null,
                    labelHeight: null,
                    reserveSpace: null,
                    tickLength: null,
                    alignTicksWithAxis: null,
                    tickDecimals: null,
                    tickSize: null,
                    minTickSize: null
                },
                yaxis: {
                    autoscaleMargin: .02,
                    position: "left"
                },
                xaxes: [],
                yaxes: [],
                series: {
                    points: {
                        show: !1,
                        radius: 3,
                        lineWidth: 2,
                        fill: !0,
                        fillColor: "#ffffff",
                        symbol: "circle"
                    },
                    lines: {
                        lineWidth: 2,
                        fill: !1,
                        fillColor: null,
                        steps: !1
                    },
                    bars: {
                        show: !1,
                        lineWidth: 2,
                        barWidth: 1,
                        fill: !0,
                        fillColor: null,
                        align: "left",
                        horizontal: !1,
                        zero: !0
                    },
                    shadowSize: 3,
                    highlightColor: null
                },
                grid: {
                    show: !0,
                    aboveData: !1,
                    color: "#545454",
                    backgroundColor: null,
                    borderColor: null,
                    tickColor: null,
                    margin: 0,
                    labelMargin: 5,
                    axisMargin: 8,
                    borderWidth: 2,
                    minBorderMargin: null,
                    markings: null,
                    markingsColor: "#f4f4f4",
                    markingsLineWidth: 2,
                    clickable: !1,
                    hoverable: !1,
                    autoHighlight: !0,
                    mouseActiveRadius: 10
                },
                interaction: {
                    redrawOverlayInterval: 1e3 / 60
                },
                hooks: {}
            }, rt = null, at = null, st = null, lt = null, ct = null, ht = [], ut = [], ft = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            }, dt = 0, mt = 0, pt = {
                processOptions: [],
                processRawData: [],
                processDatapoints: [],
                processOffset: [],
                drawBackground: [],
                drawSeries: [],
                draw: [],
                bindEvents: [],
                drawOverlay: [],
                shutdown: []
            }, gt = this;
            gt.setData = h, gt.setupGrid = T, gt.draw = O, gt.getPlaceholder = function() {
                return i;
            }, gt.getCanvas = function() {
                return rt.element;
            }, gt.getPlotOffset = function() {
                return ft;
            }, gt.width = function() {
                return dt;
            }, gt.height = function() {
                return mt;
            }, gt.offset = function() {
                var t = st.offset();
                return t.left += ft.left, t.top += ft.top, t;
            }, gt.getData = function() {
                return nt;
            }, gt.getAxes = function() {
                var e = {};
                return t.each(ht.concat(ut), function(t, i) {
                    i && (e[i.direction + (1 != i.n ? i.n : "") + "axis"] = i);
                }), e;
            }, gt.getXAxes = function() {
                return ht;
            }, gt.getYAxes = function() {
                return ut;
            }, gt.c2p = m, gt.p2c = p, gt.getOptions = function() {
                return ot;
            }, gt.highlight = U, gt.unhighlight = K, gt.triggerRedrawOverlay = Q, gt.pointOffset = function(t) {
                return {
                    left: parseInt(ht[f(t, "x") - 1].p2c(+t.x) + ft.left, 10),
                    top: parseInt(ut[f(t, "y") - 1].p2c(+t.y) + ft.top, 10)
                };
            }, gt.shutdown = k, gt.destroy = function() {
                k(), i.removeData("plot").empty(), nt = [], ot = null, rt = null, at = null, st = null, 
                lt = null, ct = null, ht = [], ut = [], pt = null, vt = [], gt = null;
            }, gt.resize = function() {
                var t = i.width(), e = i.height();
                rt.resize(t, e), at.resize(t, e);
            }, gt.hooks = pt, l(gt), c(r), b(), h(o), T(), O(), y();
            var vt = [], xt = null;
        }
        function n(t, e) {
            return e * Math.floor(t / e);
        }
        var o = Object.prototype.hasOwnProperty;
        t.fn.detach || (t.fn.detach = function() {
            return this.each(function() {
                this.parentNode && this.parentNode.removeChild(this);
            });
        }), e.prototype.resize = function(t, e) {
            if (t <= 0 || e <= 0) throw new Error("Invalid dimensions for plot, width = " + t + ", height = " + e);
            var i = this.element, n = this.context, o = this.pixelRatio;
            this.width != t && (i.width = t * o, i.style.width = t + "px", this.width = t), 
            this.height != e && (i.height = e * o, i.style.height = e + "px", this.height = e), 
            n.restore(), n.save(), n.scale(o, o);
        }, e.prototype.clear = function() {
            this.context.clearRect(0, 0, this.width, this.height);
        }, e.prototype.render = function() {
            var t = this._textCache;
            for (var e in t) if (o.call(t, e)) {
                var i = this.getTextLayer(e), n = t[e];
                i.hide();
                for (var r in n) if (o.call(n, r)) {
                    var a = n[r];
                    for (var s in a) if (o.call(a, s)) {
                        for (var l, c = a[s].positions, h = 0; l = c[h]; h++) l.active ? l.rendered || (i.append(l.element), 
                        l.rendered = !0) : (c.splice(h--, 1), l.rendered && l.element.detach());
                        0 == c.length && delete a[s];
                    }
                }
                i.show();
            }
        }, e.prototype.getTextLayer = function(e) {
            var i = this.text[e];
            return null == i && (null == this.textContainer && (this.textContainer = t("<div class='flot-text'></div>").css({
                position: "absolute",
                top: 0,
                left: 0,
                bottom: 0,
                right: 0,
                "font-size": "smaller",
                color: "#545454"
            }).insertAfter(this.element)), i = this.text[e] = t("<div></div>").addClass(e).css({
                position: "absolute",
                top: 0,
                left: 0,
                bottom: 0,
                right: 0
            }).appendTo(this.textContainer)), i;
        }, e.prototype.getTextInfo = function(e, i, n, o, r) {
            var a, s, l, c;
            if (i = "" + i, a = "object" == typeof n ? n.style + " " + n.variant + " " + n.weight + " " + n.size + "px/" + n.lineHeight + "px " + n.family : n, 
            s = this._textCache[e], null == s && (s = this._textCache[e] = {}), l = s[a], null == l && (l = s[a] = {}), 
            c = l[i], null == c) {
                var h = t("<div></div>").html(i).css({
                    position: "absolute",
                    "max-width": r,
                    top: -9999
                }).appendTo(this.getTextLayer(e));
                "object" == typeof n ? h.css({
                    font: a,
                    color: n.color
                }) : "string" == typeof n && h.addClass(n), c = l[i] = {
                    width: h.outerWidth(!0),
                    height: h.outerHeight(!0),
                    element: h,
                    positions: []
                }, h.detach();
            }
            return c;
        }, e.prototype.addText = function(t, e, i, n, o, r, a, s, l) {
            var c = this.getTextInfo(t, n, o, r, a), h = c.positions;
            "center" == s ? e -= c.width / 2 : "right" == s && (e -= c.width), "middle" == l ? i -= c.height / 2 : "bottom" == l && (i -= c.height);
            for (var u, f = 0; u = h[f]; f++) if (u.x == e && u.y == i) return void (u.active = !0);
            u = {
                active: !0,
                rendered: !1,
                element: h.length ? c.element.clone() : c.element,
                x: e,
                y: i
            }, h.push(u), u.element.css({
                top: Math.round(i),
                left: Math.round(e),
                "text-align": s
            });
        }, e.prototype.removeText = function(t, e, i, n, r, a) {
            if (null == n) {
                var s = this._textCache[t];
                if (null != s) for (var l in s) if (o.call(s, l)) {
                    var c = s[l];
                    for (var h in c) if (o.call(c, h)) for (var u, f = c[h].positions, d = 0; u = f[d]; d++) u.active = !1;
                }
            } else for (var u, f = this.getTextInfo(t, n, r, a).positions, d = 0; u = f[d]; d++) u.x == e && u.y == i && (u.active = !1);
        }, t.plot = function(e, n, o) {
            var r = new i(t(e), n, o, t.plot.plugins);
            return r;
        }, t.plot.version = "0.8.3", t.plot.plugins = [], t.fn.plot = function(e, i) {
            return this.each(function() {
                t.plot(this, e, i);
            });
        };
    }(jQuery);
}, function(t, e) {
    !function(t) {
        function e(e) {
            function i(t) {
                m.active && (c(t), e.getPlaceholder().trigger("plotselecting", [ r() ]));
            }
            function n(e) {
                1 == e.which && (document.body.focus(), void 0 !== document.onselectstart && null == p.onselectstart && (p.onselectstart = document.onselectstart, 
                document.onselectstart = function() {
                    return !1;
                }), void 0 !== document.ondrag && null == p.ondrag && (p.ondrag = document.ondrag, 
                document.ondrag = function() {
                    return !1;
                }), l(m.first, e), m.active = !0, g = function(t) {
                    o(t);
                }, t(document).one("mouseup", g));
            }
            function o(t) {
                return g = null, void 0 !== document.onselectstart && (document.onselectstart = p.onselectstart), 
                void 0 !== document.ondrag && (document.ondrag = p.ondrag), m.active = !1, c(t), 
                d() ? a() : (e.getPlaceholder().trigger("plotunselected", []), e.getPlaceholder().trigger("plotselecting", [ null ])), 
                !1;
            }
            function r() {
                if (!d()) return null;
                if (!m.show) return null;
                var i = {}, n = m.first, o = m.second;
                return t.each(e.getAxes(), function(t, e) {
                    if (e.used) {
                        var r = e.c2p(n[e.direction]), a = e.c2p(o[e.direction]);
                        i[t] = {
                            from: Math.min(r, a),
                            to: Math.max(r, a)
                        };
                    }
                }), i;
            }
            function a() {
                var t = r();
                e.getPlaceholder().trigger("plotselected", [ t ]), t.xaxis && t.yaxis && e.getPlaceholder().trigger("selected", [ {
                    x1: t.xaxis.from,
                    y1: t.yaxis.from,
                    x2: t.xaxis.to,
                    y2: t.yaxis.to
                } ]);
            }
            function s(t, e, i) {
                return e < t ? t : e > i ? i : e;
            }
            function l(t, i) {
                var n = e.getOptions(), o = e.getPlaceholder().offset(), r = e.getPlotOffset();
                t.x = s(0, i.pageX - o.left - r.left, e.width()), t.y = s(0, i.pageY - o.top - r.top, e.height()), 
                "y" == n.selection.mode && (t.x = t == m.first ? 0 : e.width()), "x" == n.selection.mode && (t.y = t == m.first ? 0 : e.height());
            }
            function c(t) {
                null != t.pageX && (l(m.second, t), d() ? (m.show = !0, e.triggerRedrawOverlay()) : h(!0));
            }
            function h(t) {
                m.show && (m.show = !1, e.triggerRedrawOverlay(), t || e.getPlaceholder().trigger("plotunselected", []));
            }
            function u(t, i) {
                var n, o, r, a, s = e.getAxes();
                for (var l in s) if (n = s[l], n.direction == i && (a = i + n.n + "axis", t[a] || 1 != n.n || (a = i + "axis"), 
                t[a])) {
                    o = t[a].from, r = t[a].to;
                    break;
                }
                if (t[a] || (n = "x" == i ? e.getXAxes()[0] : e.getYAxes()[0], o = t[i + "1"], r = t[i + "2"]), 
                null != o && null != r && o > r) {
                    var c = o;
                    o = r, r = c;
                }
                return {
                    from: o,
                    to: r,
                    axis: n
                };
            }
            function f(t, i) {
                var n, o = e.getOptions();
                "y" == o.selection.mode ? (m.first.x = 0, m.second.x = e.width()) : (n = u(t, "x"), 
                m.first.x = n.axis.p2c(n.from), m.second.x = n.axis.p2c(n.to)), "x" == o.selection.mode ? (m.first.y = 0, 
                m.second.y = e.height()) : (n = u(t, "y"), m.first.y = n.axis.p2c(n.from), m.second.y = n.axis.p2c(n.to)), 
                m.show = !0, e.triggerRedrawOverlay(), !i && d() && a();
            }
            function d() {
                var t = e.getOptions().selection.minSize;
                return Math.abs(m.second.x - m.first.x) >= t && Math.abs(m.second.y - m.first.y) >= t;
            }
            var m = {
                first: {
                    x: -1,
                    y: -1
                },
                second: {
                    x: -1,
                    y: -1
                },
                show: !1,
                active: !1
            }, p = {}, g = null;
            e.clearSelection = h, e.setSelection = f, e.getSelection = r, e.hooks.bindEvents.push(function(t, e) {
                var o = t.getOptions();
                null != o.selection.mode && (e.mousemove(i), e.mousedown(n));
            }), e.hooks.drawOverlay.push(function(e, i) {
                if (m.show && d()) {
                    var n = e.getPlotOffset(), o = e.getOptions();
                    i.save(), i.translate(n.left, n.top);
                    var r = t.color.parse(o.selection.color);
                    i.strokeStyle = r.scale("a", .8).toString(), i.lineWidth = 1, i.lineJoin = o.selection.shape, 
                    i.fillStyle = r.scale("a", .4).toString();
                    var a = Math.min(m.first.x, m.second.x) + .5, s = Math.min(m.first.y, m.second.y) + .5, l = Math.abs(m.second.x - m.first.x) - 1, c = Math.abs(m.second.y - m.first.y) - 1;
                    i.fillRect(a, s, l, c), i.strokeRect(a, s, l, c), i.restore();
                }
            }), e.hooks.shutdown.push(function(e, o) {
                o.unbind("mousemove", i), o.unbind("mousedown", n), g && t(document).unbind("mouseup", g);
            });
        }
        t.plot.plugins.push({
            init: e,
            options: {
                selection: {
                    mode: null,
                    color: "#e8cfac",
                    shape: "round",
                    minSize: 5
                }
            },
            name: "selection",
            version: "1.1"
        });
    }(jQuery);
}, function(t, e) {
    !function(t) {
        function e(t, e) {
            return e * Math.floor(t / e);
        }
        function i(t, e, i, n) {
            if ("function" == typeof t.strftime) return t.strftime(e);
            var o = function(t, e) {
                return t = "" + t, e = "" + (null == e ? "0" : e), 1 == t.length ? e + t : t;
            }, r = [], a = !1, s = t.getHours(), l = s < 12;
            null == i && (i = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]), 
            null == n && (n = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ]);
            var c;
            c = s > 12 ? s - 12 : 0 == s ? 12 : s;
            for (var h = 0; h < e.length; ++h) {
                var u = e.charAt(h);
                if (a) {
                    switch (u) {
                      case "a":
                        u = "" + n[t.getDay()];
                        break;

                      case "b":
                        u = "" + i[t.getMonth()];
                        break;

                      case "d":
                        u = o(t.getDate());
                        break;

                      case "e":
                        u = o(t.getDate(), " ");
                        break;

                      case "h":
                      case "H":
                        u = o(s);
                        break;

                      case "I":
                        u = o(c);
                        break;

                      case "l":
                        u = o(c, " ");
                        break;

                      case "m":
                        u = o(t.getMonth() + 1);
                        break;

                      case "M":
                        u = o(t.getMinutes());
                        break;

                      case "q":
                        u = "" + (Math.floor(t.getMonth() / 3) + 1);
                        break;

                      case "S":
                        u = o(t.getSeconds());
                        break;

                      case "y":
                        u = o(t.getFullYear() % 100);
                        break;

                      case "Y":
                        u = "" + t.getFullYear();
                        break;

                      case "p":
                        u = l ? "am" : "pm";
                        break;

                      case "P":
                        u = l ? "AM" : "PM";
                        break;

                      case "w":
                        u = "" + t.getDay();
                    }
                    r.push(u), a = !1;
                } else "%" == u ? a = !0 : r.push(u);
            }
            return r.join("");
        }
        function n(t) {
            function e(t, e, i, n) {
                t[e] = function() {
                    return i[n].apply(i, arguments);
                };
            }
            var i = {
                date: t
            };
            void 0 != t.strftime && e(i, "strftime", t, "strftime"), e(i, "getTime", t, "getTime"), 
            e(i, "setTime", t, "setTime");
            for (var n = [ "Date", "Day", "FullYear", "Hours", "Milliseconds", "Minutes", "Month", "Seconds" ], o = 0; o < n.length; o++) e(i, "get" + n[o], t, "getUTC" + n[o]), 
            e(i, "set" + n[o], t, "setUTC" + n[o]);
            return i;
        }
        function o(t, e) {
            if ("browser" == e.timezone) return new Date(t);
            if (e.timezone && "utc" != e.timezone) {
                if ("undefined" != typeof timezoneJS && "undefined" != typeof timezoneJS.Date) {
                    var i = new timezoneJS.Date();
                    return i.setTimezone(e.timezone), i.setTime(t), i;
                }
                return n(new Date(t));
            }
            return n(new Date(t));
        }
        function r(n) {
            n.hooks.processOptions.push(function(n, r) {
                t.each(n.getAxes(), function(t, n) {
                    var r = n.options;
                    "time" == r.mode && (n.tickGenerator = function(t) {
                        var i = [], n = o(t.min, r), a = 0, l = r.tickSize && "quarter" === r.tickSize[1] || r.minTickSize && "quarter" === r.minTickSize[1] ? h : c;
                        null != r.minTickSize && (a = "number" == typeof r.tickSize ? r.tickSize : r.minTickSize[0] * s[r.minTickSize[1]]);
                        for (var u = 0; u < l.length - 1 && !(t.delta < (l[u][0] * s[l[u][1]] + l[u + 1][0] * s[l[u + 1][1]]) / 2 && l[u][0] * s[l[u][1]] >= a); ++u) ;
                        var f = l[u][0], d = l[u][1];
                        if ("year" == d) {
                            if (null != r.minTickSize && "year" == r.minTickSize[1]) f = Math.floor(r.minTickSize[0]); else {
                                var m = Math.pow(10, Math.floor(Math.log(t.delta / s.year) / Math.LN10)), p = t.delta / s.year / m;
                                f = p < 1.5 ? 1 : p < 3 ? 2 : p < 7.5 ? 5 : 10, f *= m;
                            }
                            f < 1 && (f = 1);
                        }
                        t.tickSize = r.tickSize || [ f, d ];
                        var g = t.tickSize[0];
                        d = t.tickSize[1];
                        var v = g * s[d];
                        "second" == d ? n.setSeconds(e(n.getSeconds(), g)) : "minute" == d ? n.setMinutes(e(n.getMinutes(), g)) : "hour" == d ? n.setHours(e(n.getHours(), g)) : "month" == d ? n.setMonth(e(n.getMonth(), g)) : "quarter" == d ? n.setMonth(3 * e(n.getMonth() / 3, g)) : "year" == d && n.setFullYear(e(n.getFullYear(), g)), 
                        n.setMilliseconds(0), v >= s.minute && n.setSeconds(0), v >= s.hour && n.setMinutes(0), 
                        v >= s.day && n.setHours(0), v >= 4 * s.day && n.setDate(1), v >= 2 * s.month && n.setMonth(e(n.getMonth(), 3)), 
                        v >= 2 * s.quarter && n.setMonth(e(n.getMonth(), 6)), v >= s.year && n.setMonth(0);
                        var x, b = 0, y = Number.NaN;
                        do if (x = y, y = n.getTime(), i.push(y), "month" == d || "quarter" == d) if (g < 1) {
                            n.setDate(1);
                            var k = n.getTime();
                            n.setMonth(n.getMonth() + ("quarter" == d ? 3 : 1));
                            var _ = n.getTime();
                            n.setTime(y + b * s.hour + (_ - k) * g), b = n.getHours(), n.setHours(0);
                        } else n.setMonth(n.getMonth() + g * ("quarter" == d ? 3 : 1)); else "year" == d ? n.setFullYear(n.getFullYear() + g) : n.setTime(y + v); while (y < t.max && y != x);
                        return i;
                    }, n.tickFormatter = function(t, e) {
                        var n = o(t, e.options);
                        if (null != r.timeformat) return i(n, r.timeformat, r.monthNames, r.dayNames);
                        var a, l = e.options.tickSize && "quarter" == e.options.tickSize[1] || e.options.minTickSize && "quarter" == e.options.minTickSize[1], c = e.tickSize[0] * s[e.tickSize[1]], h = e.max - e.min, u = r.twelveHourClock ? " %p" : "", f = r.twelveHourClock ? "%I" : "%H";
                        a = c < s.minute ? f + ":%M:%S" + u : c < s.day ? h < 2 * s.day ? f + ":%M" + u : "%b %d " + f + ":%M" + u : c < s.month ? "%b %d" : l && c < s.quarter || !l && c < s.year ? h < s.year ? "%b" : "%b %Y" : l && c < s.year ? h < s.year ? "Q%q" : "Q%q %Y" : "%Y";
                        var d = i(n, a, r.monthNames, r.dayNames);
                        return d;
                    });
                });
            });
        }
        var a = {
            xaxis: {
                timezone: null,
                timeformat: null,
                twelveHourClock: !1,
                monthNames: null
            }
        }, s = {
            second: 1e3,
            minute: 6e4,
            hour: 36e5,
            day: 864e5,
            month: 2592e6,
            quarter: 7776e6,
            year: 525949.2 * 60 * 1e3
        }, l = [ [ 1, "second" ], [ 2, "second" ], [ 5, "second" ], [ 10, "second" ], [ 30, "second" ], [ 1, "minute" ], [ 2, "minute" ], [ 5, "minute" ], [ 10, "minute" ], [ 30, "minute" ], [ 1, "hour" ], [ 2, "hour" ], [ 4, "hour" ], [ 8, "hour" ], [ 12, "hour" ], [ 1, "day" ], [ 2, "day" ], [ 3, "day" ], [ .25, "month" ], [ .5, "month" ], [ 1, "month" ], [ 2, "month" ] ], c = l.concat([ [ 3, "month" ], [ 6, "month" ], [ 1, "year" ] ]), h = l.concat([ [ 1, "quarter" ], [ 2, "quarter" ], [ 1, "year" ] ]);
        t.plot.plugins.push({
            init: r,
            options: a,
            name: "time",
            version: "1.0"
        }), t.plot.formatDate = i, t.plot.dateGenerator = o;
    }(jQuery);
} ]);
//# sourceMappingURL=plot.min.js.map