{"version":3,"sources":["webpack:///networkmanager/test-utils.min.js","webpack:///webpack/bootstrap 6a4a1d5384330b946f46?2bd4","webpack:///../pkg/networkmanager/test-utils.js","webpack:///external \"cockpit\"?478e","webpack:///../pkg/networkmanager/utils.js?0508","webpack:///../pkg/lib/qunit-tests.js","webpack:///../bower_components/qunit/qunit/qunit.js","webpack:///../~/process/browser.js","webpack:///../bower_components/qunit-tap/lib/qunit-tap.js","webpack:///../pkg/lib/qunit-config.js","webpack:///../~/webpack/buildin/module.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","assert_throws","func","checks","assert","expect","length","forEach","throws","utils","cockpit","QUnit","test","strictEqual","ip_prefix_from_text","ip_metric_from_text","set_byteorder","ip4_to_text","replace","ip4_from_text","i","ip4_prefix_from_text","ip6_to_text","base64_encode","deepEqual","base64_decode","ip6_from_text","zero","start","bo","byteorder","ip_prefix_to_text","num","toString","text","trim","parseInt","format","_","ip_metric_to_text","toDec","n","bytes_from_nm32","bytes","zero_is_empty","map","join","empty_is_zero","invalid","shift","b","isNaN","parts","split","s","prefix","text_to_prefix_bits","undefined","data","result","j","empty_seen","gettext","255","254","252","248","240","224","192","128","0","window","qunitTap","process","done","config","autorun","previousModule","runLoggingCallbacks","name","failed","moduleStats","bad","passed","all","total","key","banner","tests","runtime","Date","started","stats","html","className","innerHTML","altertitle","defined","document","title","reorder","sessionStorage","indexOf","removeItem","scrolltop","scrollTo","validTest","include","filter","toLowerCase","fullName","testName","callback","testNumber","inArray","charAt","slice","extractStacktrace","e","offset","stack","stacktrace","fileName","push","sourceURL","line","sourceFromStacktrace","Error","escapeText","synchronize","last","queue","blocking","next","getTime","depth","setTimeout","updateRate","saveGlobal","pollution","noglobals","hasOwn","checkPollution","newGlobals","deletedGlobals","old","diff","pushFailure","a","splice","extend","prop","addEvent","elem","type","fn","addEventListener","attachEvent","addEvents","elems","hasClass","addClass","removeClass","set","getElementById","registerLoggingCallback","scope","args","callbacks","hasOwnProperty","array","Test","settings","this","assertions","count","onErrorFnPrev","testId","Object","prototype","clearTimeout","x","setItem","errorString","error","message","substring","objectValues","obj","val","vals","is","testEnvironment","currentModule","currentModuleTestEnvironment","asyncTest","expected","arguments","async","nameHtml","moduleTestEnvironment","asserts","current","semaphore","begin","timeout","stop","testTimeout","ok","F","constructor","hidepassed","requireExpects","urlConfig","label","tooltip","log","testStart","testDone","moduleStart","moduleDone","location","search","protocol","params","urlParams","decodeURIComponent","concat","isLocal","init","autostart","qunit","parentNode","removeChild","createElement","insertBefore","reset","fixture","objectType","match","actual","output","source","details","jsDump","parse","url","querystring","encodeURIComponent","host","pathname","readyState","load","len","main","ol","toolbar","selection","urlConfigContainer","moduleFilter","userAgent","numModules","moduleNames","moduleFilterHtml","urlConfigHtml","oldconfig","value","sort","localeCompare","navigator","tmp","checked","getItem","appendChild","setAttribute","getElementsByTagName","event","target","srcElement","defaultValue","options","selectedIndex","lastChild","selectBox","selectedModule","onerror","filePath","linerNr","ret","ignoreGlobalErrors","li","href","setup","teardown","current_testEnvironment","notrycatch","run","running","callbackStarted","callbackRuntime","finish","assertion","time","good","collapsed","nodeName","firstChild","duration","msg","equal","notEqual","propEqual","equiv","notPropEqual","notDeepEqual","notStrictEqual","block","expectedOutput","raises","equals","same","bindCallbacks","o","apply","innerEquiv","callers","parents","parentsB","getProto","getPrototypeOf","__proto__","useStrictEquality","string","boolean","number","null","nan","date","valueOf","regexp","global","ignoreCase","multiline","sticky","function","caller","loop","aCircular","bCircular","pop","object","eq","aProperties","bProperties","quote","str","literal","pre","arr","post","separator","base","indent","inner","Array","up","down","reName","inStack","res","parser","parsers","typeOf","setInterval","nodeType","item","HTML","extra","chr","indentChar","setParser","unknown","exec","nodelist","keys","node","open","close","tag","attrs","attributes","nodeValue","functionArgs","l","String","fromCharCode","functionCode","attribute","ns","os","rows","row","out","oSpace","nSpace","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queueIndex","drainQueue","Item","noop","nextTick","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","ary","element","removeElement","index","isPlanRequired","conf","isPassed","isFailed","isAssertOkFailed","escapeLineEndings","ltrim","render","desc","fieldName","fieldValue","formatter","renderIf","shouldRender","formatTestLine","testLine","rest","qunitObject","printLikeFunction","isEnabled","configName","tap","formatDetails","explain","printPlanLine","toCount","puts","initialCount","unsubscribeEvent","eventName","listeners","targetEvents","qu","registeredCallbacks","unsubscribeEvents","eventNames","jsDumpExists","deprecateOption","optionName","fallback","showModuleNameOnFailure","showTestNameOnFailure","showExpectationOnFailure","showSourceOnFailure","flag","noPlan","VERSION","qunitTapVersion","expectedCount","note","diag","arg","unsubscribe","appendCallback","createCallbackAppenderFor","subject","observer","originalLoggingCallback","qunit_started","qunit_onerror","file","console","tap_regex","tests_included","webpackPolyfill","deprecate","paths","children"],"mappings":"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","file":"networkmanager/test-utils.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\n\t * This file is part of Cockpit.\n\t *\n\t * Copyright (C) 2014 Red Hat, Inc.\n\t *\n\t * Cockpit is free software; you can redistribute it and/or modify it\n\t * under the terms of the GNU Lesser General Public License as published by\n\t * the Free Software Foundation; either version 2.1 of the License, or\n\t * (at your option) any later version.\n\t *\n\t * Cockpit is distributed in the hope that it will be useful, but\n\t * WITHOUT ANY WARRANTY; without even the implied warranty of\n\t * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n\t * Lesser General Public License for more details.\n\t *\n\t * You should have received a copy of the GNU Lesser General Public License\n\t * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n\t */\n\t\n\tvar utils = __webpack_require__(4);\n\tvar cockpit = __webpack_require__(3);\n\tvar QUnit = __webpack_require__(22);\n\tvar assert = QUnit;\n\t\n\tfunction assert_throws(func, checks) {\n\t    assert.expect(checks.length);\n\t\n\t    checks.forEach(function(c) {\n\t        assert.throws(function() {\n\t            func(c);\n\t        });\n\t    });\n\t}\n\t\n\tQUnit.test(\"ip_prefix_from_text\", function() {\n\t    var checks = [\n\t        [ \"0\",      0 ],\n\t        [ \"12\",    12 ],\n\t        [ \" 12  \", 12 ]\n\t    ];\n\t\n\t    assert.expect(checks.length);\n\t\n\t    checks.forEach(function(c) {\n\t        assert.strictEqual(utils.ip_prefix_from_text(c[0]), c[1]);\n\t    });\n\t});\n\t\n\tQUnit.test(\"ip_prefix_from_text invalids\", function() {\n\t    var checks = [\n\t        \"\",\n\t        \"-1\",\n\t        \"foo\",\n\t        \"1foo\",\n\t        \"1.5\",\n\t        \"1 2 3\"\n\t    ];\n\t\n\t    assert_throws(utils.ip_prefix_from_text, checks);\n\t});\n\t\n\tQUnit.test(\"ip_metric_from_text\", function() {\n\t    var checks = [\n\t        [ \"\",       0 ],\n\t        [ \"0\",      0 ],\n\t        [ \"12\",    12 ],\n\t        [ \" 12  \", 12 ]\n\t    ];\n\t\n\t    assert.expect(checks.length);\n\t\n\t    checks.forEach(function(c) {\n\t        assert.strictEqual(utils.ip_metric_from_text(c[0]), c[1]);\n\t    });\n\t});\n\t\n\tQUnit.test(\"ip_metric_from_text invalids\", function() {\n\t    var checks = [\n\t        \"-1\",\n\t        \"foo\",\n\t        \"1foo\",\n\t        \"1.5\",\n\t        \"1 2 3\"\n\t    ];\n\t\n\t    assert_throws(utils.ip_metric_from_text, checks);\n\t});\n\t\n\tQUnit.test(\"ip4_to/from_text be\", function() {\n\t    var checks = [\n\t        [ \"0.0.0.0\",           0x00000000 ],\n\t        [ \"255.255.255.255\",   0xFFFFFFFF ],\n\t        [ \"1.2.3.4\",           0x01020304 ],\n\t        [ \" 1.2.3.4 \",         0x01020304 ],\n\t        [ \" 1 . 2 . 3. 4 \",    0x01020304 ]\n\t    ];\n\t\n\t    assert.expect(2*checks.length);\n\t\n\t    utils.set_byteorder(\"be\");\n\t    checks.forEach(function(c) {\n\t        assert.strictEqual(utils.ip4_to_text(c[1]), c[0].replace(/ /g, \"\"));\n\t        assert.strictEqual(utils.ip4_from_text(c[0]), c[1]);\n\t    });\n\t});\n\t\n\tQUnit.test(\"ip4_to/from_text le\", function() {\n\t    var checks = [\n\t        [ \"0.0.0.0\",           0x00000000 ],\n\t        [ \"255.255.255.255\",   0xFFFFFFFF ],\n\t        [ \"1.2.3.4\",           0x04030201 ],\n\t        [ \" 1.2.3.4 \",         0x04030201 ],\n\t        [ \" 1 . 2 . 3. 4 \",    0x04030201 ]\n\t    ];\n\t\n\t    assert.expect(2*checks.length);\n\t\n\t    utils.set_byteorder(\"le\");\n\t    checks.forEach(function(c) {\n\t        assert.strictEqual(utils.ip4_to_text(c[1]), c[0].replace(/ /g, \"\"));\n\t        assert.strictEqual(utils.ip4_from_text(c[0]), c[1]);\n\t    });\n\t});\n\t\n\tQUnit.test(\"ip4_from_text invalids\", function() {\n\t    var checks = [\n\t        \"\",\n\t        \"0\",\n\t        \"0.0\",\n\t        \"0.0.0\",\n\t        \"0.0.0.0.0\",\n\t        \"-1.2.3.4\",\n\t        \"foo\",\n\t        \"1.foo.3.4\",\n\t        \"1foo.2.3.4\",\n\t        \"1.2.3.400\",\n\t        \"1,2,3,4\",\n\t        \"1 1.2.3 3.4\"\n\t    ];\n\t\n\t    assert_throws(utils.ip4_from_text, checks);\n\t});\n\t\n\tQUnit.test(\"ip4_to_text zero\", function() {\n\t    utils.set_byteorder(\"be\");\n\t    assert.strictEqual(utils.ip4_to_text(0, true), \"\");\n\t});\n\t\n\tQUnit.test(\"ip4_from_text empty\", function() {\n\t    utils.set_byteorder(\"be\");\n\t    assert.strictEqual(utils.ip4_from_text(\"\", true), 0);\n\t});\n\t\n\tQUnit.test(\"ip4_prefix_from_text\", function() {\n\t    var checks = [\n\t        \"0.0.0.0\",\n\t\n\t        \" 128.0.0.0\",\n\t        \"192.0.0.0 \",\n\t        \"224. 0. 0.0\",\n\t        \"240. 0.0 .0\",\n\t        \"248.0.0.0\",\n\t        \"252. 0.0.0\",\n\t        \"254.0.0.0\",\n\t        \"255.0.0.0\",\n\t\n\t        \"255.128.0.0\",\n\t        \"255.192.0.0\",\n\t        \"255.224.0.0\",\n\t        \"255.240.0.0\",\n\t        \"255.248.0.0\",\n\t        \"255.252.0.0\",\n\t        \"255.254.0.0\",\n\t        \"255.255.0.0\",\n\t\n\t        \"255.255.128.0\",\n\t        \"255.255.192.0\",\n\t        \"255.255.224.0\",\n\t        \"255.255.240.0\",\n\t        \"255.255.248.0\",\n\t        \"255.255.252.0\",\n\t        \"255.255.254.0\",\n\t        \"255.255.255.0\",\n\t\n\t        \"255.255.255.128\",\n\t        \"255.255.255.192\",\n\t        \"255.255.255.224\",\n\t        \"255.255.255.240\",\n\t        \"255.255.255.248\",\n\t        \"255.255.255.252\",\n\t        \"255.255.255.254\",\n\t        \"255.255.255.255\"\n\t    ];\n\t\n\t    assert.expect(checks.length);\n\t\n\t    checks.forEach(function(c, i) {\n\t        assert.strictEqual(utils.ip4_prefix_from_text(c), i);\n\t    });\n\t});\n\t\n\tQUnit.test(\"ip4_prefix_from_text invalids\", function() {\n\t    var checks = [\n\t        \"\",\n\t        \"-1\",\n\t        \"foo\",\n\t        \"1foo\",\n\t        \"1.5\",\n\t\n\t        \"0.0\",\n\t        \"0.0.0\",\n\t        \"0.0.0.0.0\",\n\t        \"1.2.3.4\",\n\t        \"255.255.255.8\",\n\t        \"255.192.0.10\"\n\t    ];\n\t\n\t    assert_throws(utils.ip4_prefix_from_text, checks);\n\t});\n\t\n\tQUnit.test(\"ip6_to/from_text\", function() {\n\t    var checks = [\n\t        [ [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ],\n\t          \"0:0:0:0:0:0:0:0\"\n\t        ],\n\t        [ [ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n\t            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F ],\n\t          \"1:203:405:607:809:a0b:c0d:e0f\"\n\t        ],\n\t        [ [ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n\t            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F ],\n\t          \" 1: 203 :  405: 607: 809:a0b :c0d:e0f\"\n\t        ],\n\t    ];\n\t\n\t    assert.expect(2*checks.length);\n\t\n\t    checks.forEach(function(c) {\n\t        assert.strictEqual(utils.ip6_to_text(cockpit.base64_encode(c[0])), c[1].replace(/ /g, \"\"));\n\t        assert.deepEqual(cockpit.base64_decode(utils.ip6_from_text(c[1])), c[0]);\n\t    });\n\t});\n\t\n\tQUnit.test(\"ip6_from_text abbrevs\", function() {\n\t    var checks = [\n\t        [ \"::\",\n\t          [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ],\n\t        ],\n\t        [ \"::1\",\n\t          [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 ],\n\t        ],\n\t        [ \"1::\",\n\t          [ 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ],\n\t        ],\n\t        [ \"1:2:3::2:1\",\n\t          [ 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,\n\t            0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01 ],\n\t        ],\n\t        [ \"2001::1\",\n\t          [ 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 ],\n\t        ],\n\t    ];\n\t\n\t    checks.forEach(function(c) {\n\t        assert.deepEqual(cockpit.base64_decode(utils.ip6_from_text(c[0])), c[1]);\n\t    });\n\t});\n\t\n\tQUnit.test(\"ip6_from_text invalids\", function() {\n\t    var checks = [\n\t        \"\",\n\t        \"0\",\n\t        \"0:0\",\n\t        \"0:0:0\",\n\t        \"0:0:0:0\",\n\t        \"0:0:0:0:0\",\n\t        \"0:0:0:0:0:0\",\n\t        \"0:0:0:0:0:0:0\",\n\t        \"0:0:0:0:0:0:0:0:0\",\n\t        \"foo\",\n\t        \"1:2:3:four:5:6:7:8\",\n\t        \"1:2:3:-4:5:6:7:8\",\n\t        \"1:2:3:4.0:5:6:7:8\",\n\t        \"1:2:3:4foo:5:6:7:8\",\n\t        \"1:2:3:10000:5:6:7:8\",\n\t        \"1::4::8\",\n\t        \"::8::\",\n\t        \"1:2:3:4 4:5:6:7:8\",\n\t    ];\n\t\n\t    assert_throws(utils.ip6_from_text, checks);\n\t});\n\t\n\tQUnit.test(\"ip6_to_text zero\", function() {\n\t    var zero = [ 0, 0, 0, 0, 0, 0, 0, 0,\n\t                 0, 0, 0, 0, 0, 0, 0, 0\n\t               ];\n\t    assert.strictEqual(utils.ip6_to_text(cockpit.base64_encode(zero), true), \"\");\n\t});\n\t\n\tQUnit.test(\"ip6_from_text empty\", function() {\n\t    var zero = [ 0, 0, 0, 0, 0, 0, 0, 0,\n\t                 0, 0, 0, 0, 0, 0, 0, 0\n\t               ];\n\t    assert.deepEqual(cockpit.base64_decode(utils.ip6_from_text(\"\", true)), zero);\n\t});\n\t\n\tQUnit.start();\n\n\n/***/ },\n/* 1 */,\n/* 2 */,\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = cockpit;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\n\t * This file is part of Cockpit.\n\t *\n\t * Copyright (C) 2016 Red Hat, Inc.\n\t *\n\t * Cockpit is free software; you can redistribute it and/or modify it\n\t * under the terms of the GNU Lesser General Public License as published by\n\t * the Free Software Foundation; either version 2.1 of the License, or\n\t * (at your option) any later version.\n\t *\n\t * Cockpit is distributed in the hope that it will be useful, but\n\t * WITHOUT ANY WARRANTY; without even the implied warranty of\n\t * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n\t * Lesser General Public License for more details.\n\t *\n\t * You should have received a copy of the GNU Lesser General Public License\n\t * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n\t */\n\t\n\t(function() {\n\t    \"use strict\";\n\t\n\t    var cockpit = __webpack_require__(3);\n\t\n\t    var _ = cockpit.gettext;\n\t\n\t    /* NetworkManager specific data conversions and utility functions.\n\t     */\n\t\n\t    var byteorder;\n\t\n\t    function set_byteorder(bo) {\n\t        byteorder = bo;\n\t    }\n\t\n\t    function ip_prefix_to_text(num) {\n\t        return num.toString();\n\t    }\n\t\n\t    function ip_prefix_from_text(text) {\n\t        if (/^[0-9]+$/.test(text.trim()))\n\t            return parseInt(text, 10);\n\t\n\t        throw cockpit.format(_(\"Invalid prefix $0\"), text);\n\t    }\n\t\n\t    function ip_metric_to_text(num) {\n\t        return num.toString();\n\t    }\n\t\n\t    function ip_metric_from_text(text) {\n\t        if (text === \"\")\n\t            return 0;\n\t\n\t        if (/^[0-9]+$/.test(text.trim()))\n\t            return parseInt(text, 10);\n\t\n\t        throw cockpit.format(_(\"Invalid metric $0\"), text);\n\t    }\n\t\n\t    function toDec(n) {\n\t        return n.toString(10);\n\t    }\n\t\n\t    function bytes_from_nm32(num) {\n\t        var bytes = [], i;\n\t        if (byteorder == \"be\") {\n\t            for (i = 3; i >= 0; i--) {\n\t                bytes[i] = num & 0xFF;\n\t                num = num >>> 8;\n\t            }\n\t        } else {\n\t            for (i = 0; i < 4; i++) {\n\t                bytes[i] = num & 0xFF;\n\t                num = num >>> 8;\n\t            }\n\t        }\n\t        return bytes;\n\t    }\n\t\n\t    function ip4_to_text(num, zero_is_empty) {\n\t        if (num === 0 && zero_is_empty)\n\t            return \"\";\n\t        return bytes_from_nm32(num).map(toDec).join('.');\n\t    }\n\t\n\t    function ip4_from_text(text, empty_is_zero) {\n\t        function invalid() {\n\t            throw cockpit.format(_(\"Invalid address $0\"), text);\n\t        }\n\t\n\t        if (text === \"\" && empty_is_zero)\n\t            return 0;\n\t\n\t        var parts = text.split('.');\n\t        if (parts.length != 4)\n\t            invalid();\n\t\n\t        var bytes = parts.map(function(s) {\n\t            if (/^[0-9]+$/.test(s.trim()))\n\t                return parseInt(s, 10);\n\t            else\n\t                invalid();\n\t        });\n\t\n\t        var num = 0;\n\t        function shift(b) {\n\t            if (isNaN(b) || b < 0 || b > 0xFF)\n\t                invalid();\n\t            num = 0x100*num + b;\n\t        }\n\t\n\t        var i;\n\t        if (byteorder == \"be\") {\n\t            for (i = 0; i < 4; i++) {\n\t                shift(bytes[i]);\n\t            }\n\t        } else {\n\t            for (i = 3; i >= 0; i--) {\n\t                shift(bytes[i]);\n\t            }\n\t        }\n\t\n\t        return num;\n\t    }\n\t\n\t    var text_to_prefix_bits = {\n\t        \"255\": 8, \"254\": 7, \"252\": 6, \"248\": 5, \"240\": 4, \"224\": 3, \"192\": 2, \"128\": 1, \"0\": 0\n\t    };\n\t\n\t    function ip4_prefix_from_text(text) {\n\t        function invalid() {\n\t            throw cockpit.format(_(\"Invalid prefix or netmask $0\"), text);\n\t        }\n\t\n\t        if (/^[0-9]+$/.test(text.trim()))\n\t            return parseInt(text, 10);\n\t        var parts = text.split('.');\n\t        if (parts.length != 4)\n\t            invalid();\n\t        var prefix = 0;\n\t        var i;\n\t        for (i = 0; i < 4; i++) {\n\t            var p = text_to_prefix_bits[parts[i].trim()];\n\t            if (p !== undefined) {\n\t                prefix += p;\n\t                if (p < 8)\n\t                    break;\n\t            } else\n\t                invalid();\n\t        }\n\t        for (i += 1; i < 4; i++) {\n\t            if (/^0+$/.test(parts[i].trim()) === false)\n\t                invalid();\n\t        }\n\t        return prefix;\n\t    }\n\t\n\t    function ip6_to_text(data, zero_is_empty) {\n\t        var parts = [];\n\t        var bytes = cockpit.base64_decode(data);\n\t        for (var i = 0; i < 8; i++)\n\t            parts[i] = ((bytes[2*i] << 8) + bytes[2*i+1]).toString(16);\n\t        var result = parts.join(':');\n\t        if (result == \"0:0:0:0:0:0:0:0\" && zero_is_empty)\n\t            return \"\";\n\t        return result;\n\t    }\n\t\n\t    function ip6_from_text(text, empty_is_zero) {\n\t        function invalid() {\n\t            throw cockpit.format(_(\"Invalid address $0\"), text);\n\t        }\n\t\n\t        if (text === \"\" && empty_is_zero)\n\t            return cockpit.base64_encode([ 0, 0, 0, 0, 0, 0, 0, 0,\n\t                                           0, 0, 0, 0, 0, 0, 0, 0,\n\t                                         ]);\n\t\n\t        var parts = text.split(':');\n\t        if (parts.length < 1 || parts.length > 8)\n\t            invalid();\n\t\n\t        if (parts[0] === \"\")\n\t            parts[0] = \"0\";\n\t        if (parts[parts.length-1] === \"\")\n\t            parts[parts.length-1] = \"0\";\n\t\n\t        var bytes = [], n, i, j;\n\t        var empty_seen = false;\n\t        for (i = 0, j = 0; i < parts.length; i++, j++) {\n\t            if (parts[i] === \"\") {\n\t                if (empty_seen)\n\t                    invalid();\n\t                empty_seen = true;\n\t                while (j < i + (8 - parts.length)) {\n\t                    bytes[2*j] = bytes[2*j+1] = 0;\n\t                    j++;\n\t                }\n\t            } else {\n\t                if (!/^[0-9a-fA-F]+$/.test(parts[i].trim()))\n\t                    invalid();\n\t                n = parseInt(parts[i], 16);\n\t                if (isNaN(n) || n < 0 || n > 0xFFFF)\n\t                    invalid();\n\t                bytes[2*j] = n >> 8;\n\t                bytes[2*j+1] = n & 0xFF;\n\t            }\n\t        }\n\t        if (j != 8)\n\t            invalid();\n\t\n\t        return cockpit.base64_encode(bytes);\n\t    }\n\t\n\t    module.exports = {\n\t        set_byteorder: set_byteorder,\n\t\n\t        ip_prefix_to_text: ip_prefix_to_text,\n\t        ip_prefix_from_text: ip_prefix_from_text,\n\t        ip_metric_to_text: ip_metric_to_text,\n\t        ip_metric_from_text: ip_metric_from_text,\n\t\n\t        ip4_to_text: ip4_to_text,\n\t        ip4_from_text: ip4_from_text,\n\t        ip4_prefix_from_text: ip4_prefix_from_text,\n\t\n\t        ip6_to_text: ip6_to_text,\n\t        ip6_from_text: ip6_from_text\n\t    };\n\t\n\t})();\n\n\n/***/ },\n/* 5 */,\n/* 6 */,\n/* 7 */,\n/* 8 */,\n/* 9 */,\n/* 10 */,\n/* 11 */,\n/* 12 */,\n/* 13 */,\n/* 14 */,\n/* 15 */,\n/* 16 */,\n/* 17 */,\n/* 18 */,\n/* 19 */,\n/* 20 */,\n/* 21 */,\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\n\t * This file is part of Cockpit.\n\t *\n\t * Copyright (C) 2014 Red Hat, Inc.\n\t *\n\t * Cockpit is free software; you can redistribute it and/or modify it\n\t * under the terms of the GNU Lesser General Public License as published by\n\t * the Free Software Foundation; either version 2.1 of the License, or\n\t * (at your option) any later version.\n\t *\n\t * Cockpit is distributed in the hope that it will be useful, but\n\t * WITHOUT ANY WARRANTY; without even the implied warranty of\n\t * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n\t * Lesser General Public License for more details.\n\t *\n\t * You should have received a copy of the GNU Lesser General Public License\n\t * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n\t */\n\t\n\t(function() {\n\t    \"use strict\";\n\t\n\t    /* QUnit needs to have 'window' as 'this' in order to load */\n\t    window.QUnit = __webpack_require__(23);\n\t    window.qunitTap = __webpack_require__(25);\n\t\n\t    __webpack_require__(26);\n\t\n\t    __webpack_require__(28);\n\t\n\t    module.exports = window.QUnit;\n\t\n\t}());\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {/*!\n\t * QUnit 1.14.0\n\t * http://qunitjs.com/\n\t *\n\t * Copyright 2013 jQuery Foundation and other contributors\n\t * Released under the MIT license\n\t * http://jquery.org/license\n\t *\n\t * Date: 2014-01-31T16:40Z\n\t */\n\t\n\t(function( window ) {\n\t\n\tvar QUnit,\n\t\tassert,\n\t\tconfig,\n\t\tonErrorFnPrev,\n\t\ttestId = 0,\n\t\tfileName = (sourceFromStacktrace( 0 ) || \"\" ).replace(/(:\\d+)+\\)?/, \"\").replace(/.+\\//, \"\"),\n\t\ttoString = Object.prototype.toString,\n\t\thasOwn = Object.prototype.hasOwnProperty,\n\t\t// Keep a local reference to Date (GH-283)\n\t\tDate = window.Date,\n\t\tsetTimeout = window.setTimeout,\n\t\tclearTimeout = window.clearTimeout,\n\t\tdefined = {\n\t\t\tdocument: typeof window.document !== \"undefined\",\n\t\t\tsetTimeout: typeof window.setTimeout !== \"undefined\",\n\t\t\tsessionStorage: (function() {\n\t\t\t\tvar x = \"qunit-test-string\";\n\t\t\t\ttry {\n\t\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\t\treturn true;\n\t\t\t\t} catch( e ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}())\n\t\t},\n\t\t/**\n\t\t * Provides a normalized error string, correcting an issue\n\t\t * with IE 7 (and prior) where Error.prototype.toString is\n\t\t * not properly implemented\n\t\t *\n\t\t * Based on http://es5.github.com/#x15.11.4.4\n\t\t *\n\t\t * @param {String|Error} error\n\t\t * @return {String} error message\n\t\t */\n\t\terrorString = function( error ) {\n\t\t\tvar name, message,\n\t\t\t\terrorString = error.toString();\n\t\t\tif ( errorString.substring( 0, 7 ) === \"[object\" ) {\n\t\t\t\tname = error.name ? error.name.toString() : \"Error\";\n\t\t\t\tmessage = error.message ? error.message.toString() : \"\";\n\t\t\t\tif ( name && message ) {\n\t\t\t\t\treturn name + \": \" + message;\n\t\t\t\t} else if ( name ) {\n\t\t\t\t\treturn name;\n\t\t\t\t} else if ( message ) {\n\t\t\t\t\treturn message;\n\t\t\t\t} else {\n\t\t\t\t\treturn \"Error\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn errorString;\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Makes a clone of an object using only Array or Object as base,\n\t\t * and copies over the own enumerable properties.\n\t\t *\n\t\t * @param {Object} obj\n\t\t * @return {Object} New object with only the own properties (recursively).\n\t\t */\n\t\tobjectValues = function( obj ) {\n\t\t\t// Grunt 0.3.x uses an older version of jshint that still has jshint/jshint#392.\n\t\t\t/*jshint newcap: false */\n\t\t\tvar key, val,\n\t\t\t\tvals = QUnit.is( \"array\", obj ) ? [] : {};\n\t\t\tfor ( key in obj ) {\n\t\t\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\t\t\tval = obj[key];\n\t\t\t\t\tvals[key] = val === Object(val) ? objectValues(val) : val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn vals;\n\t\t};\n\t\n\t\n\t// Root QUnit object.\n\t// `QUnit` initialized at top of scope\n\tQUnit = {\n\t\n\t\t// call on start of module test to prepend name to all tests\n\t\tmodule: function( name, testEnvironment ) {\n\t\t\tconfig.currentModule = name;\n\t\t\tconfig.currentModuleTestEnvironment = testEnvironment;\n\t\t\tconfig.modules[name] = true;\n\t\t},\n\t\n\t\tasyncTest: function( testName, expected, callback ) {\n\t\t\tif ( arguments.length === 2 ) {\n\t\t\t\tcallback = expected;\n\t\t\t\texpected = null;\n\t\t\t}\n\t\n\t\t\tQUnit.test( testName, expected, callback, true );\n\t\t},\n\t\n\t\ttest: function( testName, expected, callback, async ) {\n\t\t\tvar test,\n\t\t\t\tnameHtml = \"<span class='test-name'>\" + escapeText( testName ) + \"</span>\";\n\t\n\t\t\tif ( arguments.length === 2 ) {\n\t\t\t\tcallback = expected;\n\t\t\t\texpected = null;\n\t\t\t}\n\t\n\t\t\tif ( config.currentModule ) {\n\t\t\t\tnameHtml = \"<span class='module-name'>\" + escapeText( config.currentModule ) + \"</span>: \" + nameHtml;\n\t\t\t}\n\t\n\t\t\ttest = new Test({\n\t\t\t\tnameHtml: nameHtml,\n\t\t\t\ttestName: testName,\n\t\t\t\texpected: expected,\n\t\t\t\tasync: async,\n\t\t\t\tcallback: callback,\n\t\t\t\tmodule: config.currentModule,\n\t\t\t\tmoduleTestEnvironment: config.currentModuleTestEnvironment,\n\t\t\t\tstack: sourceFromStacktrace( 2 )\n\t\t\t});\n\t\n\t\t\tif ( !validTest( test ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\ttest.queue();\n\t\t},\n\t\n\t\t// Specify the number of expected assertions to guarantee that failed test (no assertions are run at all) don't slip through.\n\t\texpect: function( asserts ) {\n\t\t\tif (arguments.length === 1) {\n\t\t\t\tconfig.current.expected = asserts;\n\t\t\t} else {\n\t\t\t\treturn config.current.expected;\n\t\t\t}\n\t\t},\n\t\n\t\tstart: function( count ) {\n\t\t\t// QUnit hasn't been initialized yet.\n\t\t\t// Note: RequireJS (et al) may delay onLoad\n\t\t\tif ( config.semaphore === undefined ) {\n\t\t\t\tQUnit.begin(function() {\n\t\t\t\t\t// This is triggered at the top of QUnit.load, push start() to the event loop, to allow QUnit.load to finish first\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tQUnit.start( count );\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tconfig.semaphore -= count || 1;\n\t\t\t// don't start until equal number of stop-calls\n\t\t\tif ( config.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// ignore if start is called more often then stop\n\t\t\tif ( config.semaphore < 0 ) {\n\t\t\t\tconfig.semaphore = 0;\n\t\t\t\tQUnit.pushFailure( \"Called start() while already started (QUnit.config.semaphore was 0 already)\", null, sourceFromStacktrace(2) );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// A slight delay, to avoid any current callbacks\n\t\t\tif ( defined.setTimeout ) {\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tif ( config.semaphore > 0 ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( config.timeout ) {\n\t\t\t\t\t\tclearTimeout( config.timeout );\n\t\t\t\t\t}\n\t\n\t\t\t\t\tconfig.blocking = false;\n\t\t\t\t\tprocess( true );\n\t\t\t\t}, 13);\n\t\t\t} else {\n\t\t\t\tconfig.blocking = false;\n\t\t\t\tprocess( true );\n\t\t\t}\n\t\t},\n\t\n\t\tstop: function( count ) {\n\t\t\tconfig.semaphore += count || 1;\n\t\t\tconfig.blocking = true;\n\t\n\t\t\tif ( config.testTimeout && defined.setTimeout ) {\n\t\t\t\tclearTimeout( config.timeout );\n\t\t\t\tconfig.timeout = setTimeout(function() {\n\t\t\t\t\tQUnit.ok( false, \"Test timed out\" );\n\t\t\t\t\tconfig.semaphore = 1;\n\t\t\t\t\tQUnit.start();\n\t\t\t\t}, config.testTimeout );\n\t\t\t}\n\t\t}\n\t};\n\t\n\t// We use the prototype to distinguish between properties that should\n\t// be exposed as globals (and in exports) and those that shouldn't\n\t(function() {\n\t\tfunction F() {}\n\t\tF.prototype = QUnit;\n\t\tQUnit = new F();\n\t\t// Make F QUnit's constructor so that we can add to the prototype later\n\t\tQUnit.constructor = F;\n\t}());\n\t\n\t/**\n\t * Config object: Maintain internal state\n\t * Later exposed as QUnit.config\n\t * `config` initialized at top of scope\n\t */\n\tconfig = {\n\t\t// The queue of tests to run\n\t\tqueue: [],\n\t\n\t\t// block until document ready\n\t\tblocking: true,\n\t\n\t\t// when enabled, show only failing tests\n\t\t// gets persisted through sessionStorage and can be changed in UI via checkbox\n\t\thidepassed: false,\n\t\n\t\t// by default, run previously failed tests first\n\t\t// very useful in combination with \"Hide passed tests\" checked\n\t\treorder: true,\n\t\n\t\t// by default, modify document.title when suite is done\n\t\taltertitle: true,\n\t\n\t\t// by default, scroll to top of the page when suite is done\n\t\tscrolltop: true,\n\t\n\t\t// when enabled, all tests must call expect()\n\t\trequireExpects: false,\n\t\n\t\t// add checkboxes that are persisted in the query-string\n\t\t// when enabled, the id is set to `true` as a `QUnit.config` property\n\t\turlConfig: [\n\t\t\t{\n\t\t\t\tid: \"noglobals\",\n\t\t\t\tlabel: \"Check for Globals\",\n\t\t\t\ttooltip: \"Enabling this will test if any test introduces new properties on the `window` object. Stored as query-strings.\"\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"notrycatch\",\n\t\t\t\tlabel: \"No try-catch\",\n\t\t\t\ttooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging exceptions in IE reasonable. Stored as query-strings.\"\n\t\t\t}\n\t\t],\n\t\n\t\t// Set of all modules.\n\t\tmodules: {},\n\t\n\t\t// logging callback queues\n\t\tbegin: [],\n\t\tdone: [],\n\t\tlog: [],\n\t\ttestStart: [],\n\t\ttestDone: [],\n\t\tmoduleStart: [],\n\t\tmoduleDone: []\n\t};\n\t\n\t// Initialize more QUnit.config and QUnit.urlParams\n\t(function() {\n\t\tvar i, current,\n\t\t\tlocation = window.location || { search: \"\", protocol: \"file:\" },\n\t\t\tparams = location.search.slice( 1 ).split( \"&\" ),\n\t\t\tlength = params.length,\n\t\t\turlParams = {};\n\t\n\t\tif ( params[ 0 ] ) {\n\t\t\tfor ( i = 0; i < length; i++ ) {\n\t\t\t\tcurrent = params[ i ].split( \"=\" );\n\t\t\t\tcurrent[ 0 ] = decodeURIComponent( current[ 0 ] );\n\t\n\t\t\t\t// allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\t\tcurrent[ 1 ] = current[ 1 ] ? decodeURIComponent( current[ 1 ] ) : true;\n\t\t\t\tif ( urlParams[ current[ 0 ] ] ) {\n\t\t\t\t\turlParams[ current[ 0 ] ] = [].concat( urlParams[ current[ 0 ] ], current[ 1 ] );\n\t\t\t\t} else {\n\t\t\t\t\turlParams[ current[ 0 ] ] = current[ 1 ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tQUnit.urlParams = urlParams;\n\t\n\t\t// String search anywhere in moduleName+testName\n\t\tconfig.filter = urlParams.filter;\n\t\n\t\t// Exact match of the module name\n\t\tconfig.module = urlParams.module;\n\t\n\t\tconfig.testNumber = [];\n\t\tif ( urlParams.testNumber ) {\n\t\n\t\t\t// Ensure that urlParams.testNumber is an array\n\t\t\turlParams.testNumber = [].concat( urlParams.testNumber );\n\t\t\tfor ( i = 0; i < urlParams.testNumber.length; i++ ) {\n\t\t\t\tcurrent = urlParams.testNumber[ i ];\n\t\t\t\tconfig.testNumber.push( parseInt( current, 10 ) );\n\t\t\t}\n\t\t}\n\t\n\t\t// Figure out if we're running the tests from a server or not\n\t\tQUnit.isLocal = location.protocol === \"file:\";\n\t}());\n\t\n\textend( QUnit, {\n\t\n\t\tconfig: config,\n\t\n\t\t// Initialize the configuration options\n\t\tinit: function() {\n\t\t\textend( config, {\n\t\t\t\tstats: { all: 0, bad: 0 },\n\t\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\t\tstarted: +new Date(),\n\t\t\t\tupdateRate: 1000,\n\t\t\t\tblocking: false,\n\t\t\t\tautostart: true,\n\t\t\t\tautorun: false,\n\t\t\t\tfilter: \"\",\n\t\t\t\tqueue: [],\n\t\t\t\tsemaphore: 1\n\t\t\t});\n\t\n\t\t\tvar tests, banner, result,\n\t\t\t\tqunit = id( \"qunit\" );\n\t\n\t\t\tif ( qunit ) {\n\t\t\t\tqunit.innerHTML =\n\t\t\t\t\t\"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +\n\t\t\t\t\t\"<h2 id='qunit-banner'></h2>\" +\n\t\t\t\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +\n\t\t\t\t\t\"<h2 id='qunit-userAgent'></h2>\" +\n\t\t\t\t\t\"<ol id='qunit-tests'></ol>\";\n\t\t\t}\n\t\n\t\t\ttests = id( \"qunit-tests\" );\n\t\t\tbanner = id( \"qunit-banner\" );\n\t\t\tresult = id( \"qunit-testresult\" );\n\t\n\t\t\tif ( tests ) {\n\t\t\t\ttests.innerHTML = \"\";\n\t\t\t}\n\t\n\t\t\tif ( banner ) {\n\t\t\t\tbanner.className = \"\";\n\t\t\t}\n\t\n\t\t\tif ( result ) {\n\t\t\t\tresult.parentNode.removeChild( result );\n\t\t\t}\n\t\n\t\t\tif ( tests ) {\n\t\t\t\tresult = document.createElement( \"p\" );\n\t\t\t\tresult.id = \"qunit-testresult\";\n\t\t\t\tresult.className = \"result\";\n\t\t\t\ttests.parentNode.insertBefore( result, tests );\n\t\t\t\tresult.innerHTML = \"Running...<br/>&nbsp;\";\n\t\t\t}\n\t\t},\n\t\n\t\t// Resets the test setup. Useful for tests that modify the DOM.\n\t\t/*\n\t\tDEPRECATED: Use multiple tests instead of resetting inside a test.\n\t\tUse testStart or testDone for custom cleanup.\n\t\tThis method will throw an error in 2.0, and will be removed in 2.1\n\t\t*/\n\t\treset: function() {\n\t\t\tvar fixture = id( \"qunit-fixture\" );\n\t\t\tif ( fixture ) {\n\t\t\t\tfixture.innerHTML = config.fixture;\n\t\t\t}\n\t\t},\n\t\n\t\t// Safe object type checking\n\t\tis: function( type, obj ) {\n\t\t\treturn QUnit.objectType( obj ) === type;\n\t\t},\n\t\n\t\tobjectType: function( obj ) {\n\t\t\tif ( typeof obj === \"undefined\" ) {\n\t\t\t\treturn \"undefined\";\n\t\t\t}\n\t\n\t\t\t// Consider: typeof null === object\n\t\t\tif ( obj === null ) {\n\t\t\t\treturn \"null\";\n\t\t\t}\n\t\n\t\t\tvar match = toString.call( obj ).match(/^\\[object\\s(.*)\\]$/),\n\t\t\t\ttype = match && match[1] || \"\";\n\t\n\t\t\tswitch ( type ) {\n\t\t\t\tcase \"Number\":\n\t\t\t\t\tif ( isNaN(obj) ) {\n\t\t\t\t\t\treturn \"nan\";\n\t\t\t\t\t}\n\t\t\t\t\treturn \"number\";\n\t\t\t\tcase \"String\":\n\t\t\t\tcase \"Boolean\":\n\t\t\t\tcase \"Array\":\n\t\t\t\tcase \"Date\":\n\t\t\t\tcase \"RegExp\":\n\t\t\t\tcase \"Function\":\n\t\t\t\t\treturn type.toLowerCase();\n\t\t\t}\n\t\t\tif ( typeof obj === \"object\" ) {\n\t\t\t\treturn \"object\";\n\t\t\t}\n\t\t\treturn undefined;\n\t\t},\n\t\n\t\tpush: function( result, actual, expected, message ) {\n\t\t\tif ( !config.current ) {\n\t\t\t\tthrow new Error( \"assertion outside test context, was \" + sourceFromStacktrace() );\n\t\t\t}\n\t\n\t\t\tvar output, source,\n\t\t\t\tdetails = {\n\t\t\t\t\tmodule: config.current.module,\n\t\t\t\t\tname: config.current.testName,\n\t\t\t\t\tresult: result,\n\t\t\t\t\tmessage: message,\n\t\t\t\t\tactual: actual,\n\t\t\t\t\texpected: expected\n\t\t\t\t};\n\t\n\t\t\tmessage = escapeText( message ) || ( result ? \"okay\" : \"failed\" );\n\t\t\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\n\t\t\toutput = message;\n\t\n\t\t\tif ( !result ) {\n\t\t\t\texpected = escapeText( QUnit.jsDump.parse(expected) );\n\t\t\t\tactual = escapeText( QUnit.jsDump.parse(actual) );\n\t\t\t\toutput += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" + expected + \"</pre></td></tr>\";\n\t\n\t\t\t\tif ( actual !== expected ) {\n\t\t\t\t\toutput += \"<tr class='test-actual'><th>Result: </th><td><pre>\" + actual + \"</pre></td></tr>\";\n\t\t\t\t\toutput += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" + QUnit.diff( expected, actual ) + \"</pre></td></tr>\";\n\t\t\t\t}\n\t\n\t\t\t\tsource = sourceFromStacktrace();\n\t\n\t\t\t\tif ( source ) {\n\t\t\t\t\tdetails.source = source;\n\t\t\t\t\toutput += \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText( source ) + \"</pre></td></tr>\";\n\t\t\t\t}\n\t\n\t\t\t\toutput += \"</table>\";\n\t\t\t}\n\t\n\t\t\trunLoggingCallbacks( \"log\", QUnit, details );\n\t\n\t\t\tconfig.current.assertions.push({\n\t\t\t\tresult: !!result,\n\t\t\t\tmessage: output\n\t\t\t});\n\t\t},\n\t\n\t\tpushFailure: function( message, source, actual ) {\n\t\t\tif ( !config.current ) {\n\t\t\t\tthrow new Error( \"pushFailure() assertion outside test context, was \" + sourceFromStacktrace(2) );\n\t\t\t}\n\t\n\t\t\tvar output,\n\t\t\t\tdetails = {\n\t\t\t\t\tmodule: config.current.module,\n\t\t\t\t\tname: config.current.testName,\n\t\t\t\t\tresult: false,\n\t\t\t\t\tmessage: message\n\t\t\t\t};\n\t\n\t\t\tmessage = escapeText( message ) || \"error\";\n\t\t\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\n\t\t\toutput = message;\n\t\n\t\t\toutput += \"<table>\";\n\t\n\t\t\tif ( actual ) {\n\t\t\t\toutput += \"<tr class='test-actual'><th>Result: </th><td><pre>\" + escapeText( actual ) + \"</pre></td></tr>\";\n\t\t\t}\n\t\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t\toutput += \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText( source ) + \"</pre></td></tr>\";\n\t\t\t}\n\t\n\t\t\toutput += \"</table>\";\n\t\n\t\t\trunLoggingCallbacks( \"log\", QUnit, details );\n\t\n\t\t\tconfig.current.assertions.push({\n\t\t\t\tresult: false,\n\t\t\t\tmessage: output\n\t\t\t});\n\t\t},\n\t\n\t\turl: function( params ) {\n\t\t\tparams = extend( extend( {}, QUnit.urlParams ), params );\n\t\t\tvar key,\n\t\t\t\tquerystring = \"?\";\n\t\n\t\t\tfor ( key in params ) {\n\t\t\t\tif ( hasOwn.call( params, key ) ) {\n\t\t\t\t\tquerystring += encodeURIComponent( key ) + \"=\" +\n\t\t\t\t\t\tencodeURIComponent( params[ key ] ) + \"&\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn window.location.protocol + \"//\" + window.location.host +\n\t\t\t\twindow.location.pathname + querystring.slice( 0, -1 );\n\t\t},\n\t\n\t\textend: extend,\n\t\tid: id,\n\t\taddEvent: addEvent,\n\t\taddClass: addClass,\n\t\thasClass: hasClass,\n\t\tremoveClass: removeClass\n\t\t// load, equiv, jsDump, diff: Attached later\n\t});\n\t\n\t/**\n\t * @deprecated: Created for backwards compatibility with test runner that set the hook function\n\t * into QUnit.{hook}, instead of invoking it and passing the hook function.\n\t * QUnit.constructor is set to the empty F() above so that we can add to it's prototype here.\n\t * Doing this allows us to tell if the following methods have been overwritten on the actual\n\t * QUnit object.\n\t */\n\textend( QUnit.constructor.prototype, {\n\t\n\t\t// Logging callbacks; all receive a single argument with the listed properties\n\t\t// run test/logs.html for any related changes\n\t\tbegin: registerLoggingCallback( \"begin\" ),\n\t\n\t\t// done: { failed, passed, total, runtime }\n\t\tdone: registerLoggingCallback( \"done\" ),\n\t\n\t\t// log: { result, actual, expected, message }\n\t\tlog: registerLoggingCallback( \"log\" ),\n\t\n\t\t// testStart: { name }\n\t\ttestStart: registerLoggingCallback( \"testStart\" ),\n\t\n\t\t// testDone: { name, failed, passed, total, runtime }\n\t\ttestDone: registerLoggingCallback( \"testDone\" ),\n\t\n\t\t// moduleStart: { name }\n\t\tmoduleStart: registerLoggingCallback( \"moduleStart\" ),\n\t\n\t\t// moduleDone: { name, failed, passed, total }\n\t\tmoduleDone: registerLoggingCallback( \"moduleDone\" )\n\t});\n\t\n\tif ( !defined.document || document.readyState === \"complete\" ) {\n\t\tconfig.autorun = true;\n\t}\n\t\n\tQUnit.load = function() {\n\t\trunLoggingCallbacks( \"begin\", QUnit, {} );\n\t\n\t\t// Initialize the config, saving the execution queue\n\t\tvar banner, filter, i, j, label, len, main, ol, toolbar, val, selection,\n\t\t\turlConfigContainer, moduleFilter, userAgent,\n\t\t\tnumModules = 0,\n\t\t\tmoduleNames = [],\n\t\t\tmoduleFilterHtml = \"\",\n\t\t\turlConfigHtml = \"\",\n\t\t\toldconfig = extend( {}, config );\n\t\n\t\tQUnit.init();\n\t\textend(config, oldconfig);\n\t\n\t\tconfig.blocking = false;\n\t\n\t\tlen = config.urlConfig.length;\n\t\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tval = config.urlConfig[i];\n\t\t\tif ( typeof val === \"string\" ) {\n\t\t\t\tval = {\n\t\t\t\t\tid: val,\n\t\t\t\t\tlabel: val\n\t\t\t\t};\n\t\t\t}\n\t\t\tconfig[ val.id ] = QUnit.urlParams[ val.id ];\n\t\t\tif ( !val.value || typeof val.value === \"string\" ) {\n\t\t\t\turlConfigHtml += \"<input id='qunit-urlconfig-\" + escapeText( val.id ) +\n\t\t\t\t\t\"' name='\" + escapeText( val.id ) +\n\t\t\t\t\t\"' type='checkbox'\" +\n\t\t\t\t\t( val.value ? \" value='\" + escapeText( val.value ) + \"'\" : \"\" ) +\n\t\t\t\t\t( config[ val.id ] ? \" checked='checked'\" : \"\" ) +\n\t\t\t\t\t\" title='\" + escapeText( val.tooltip ) +\n\t\t\t\t\t\"'><label for='qunit-urlconfig-\" + escapeText( val.id ) +\n\t\t\t\t\t\"' title='\" + escapeText( val.tooltip ) + \"'>\" + val.label + \"</label>\";\n\t\t\t} else {\n\t\t\t\turlConfigHtml += \"<label for='qunit-urlconfig-\" + escapeText( val.id ) +\n\t\t\t\t\t\"' title='\" + escapeText( val.tooltip ) +\n\t\t\t\t\t\"'>\" + val.label +\n\t\t\t\t\t\": </label><select id='qunit-urlconfig-\" + escapeText( val.id ) +\n\t\t\t\t\t\"' name='\" + escapeText( val.id ) +\n\t\t\t\t\t\"' title='\" + escapeText( val.tooltip ) +\n\t\t\t\t\t\"'><option></option>\";\n\t\t\t\tselection = false;\n\t\t\t\tif ( QUnit.is( \"array\", val.value ) ) {\n\t\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {\n\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( val.value[j] ) + \"'\" +\n\t\t\t\t\t\t\t( config[ val.id ] === val.value[j] ?\n\t\t\t\t\t\t\t\t(selection = true) && \" selected='selected'\" :\n\t\t\t\t\t\t\t\t\"\" ) +\n\t\t\t\t\t\t\t\">\" + escapeText( val.value[j] ) + \"</option>\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( j in val.value ) {\n\t\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {\n\t\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( j ) + \"'\" +\n\t\t\t\t\t\t\t\t( config[ val.id ] === j ?\n\t\t\t\t\t\t\t\t\t(selection = true) && \" selected='selected'\" :\n\t\t\t\t\t\t\t\t\t\"\" ) +\n\t\t\t\t\t\t\t\t\">\" + escapeText( val.value[j] ) + \"</option>\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( config[ val.id ] && !selection ) {\n\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( config[ val.id ] ) +\n\t\t\t\t\t\t\"' selected='selected' disabled='disabled'>\" +\n\t\t\t\t\t\tescapeText( config[ val.id ] ) +\n\t\t\t\t\t\t\"</option>\";\n\t\t\t\t}\n\t\t\t\turlConfigHtml += \"</select>\";\n\t\t\t}\n\t\t}\n\t\tfor ( i in config.modules ) {\n\t\t\tif ( config.modules.hasOwnProperty( i ) ) {\n\t\t\t\tmoduleNames.push(i);\n\t\t\t}\n\t\t}\n\t\tnumModules = moduleNames.length;\n\t\tmoduleNames.sort( function( a, b ) {\n\t\t\treturn a.localeCompare( b );\n\t\t});\n\t\tmoduleFilterHtml += \"<label for='qunit-modulefilter'>Module: </label><select id='qunit-modulefilter' name='modulefilter'><option value='' \" +\n\t\t\t( config.module === undefined  ? \"selected='selected'\" : \"\" ) +\n\t\t\t\">< All Modules ></option>\";\n\t\n\t\n\t\tfor ( i = 0; i < numModules; i++) {\n\t\t\t\tmoduleFilterHtml += \"<option value='\" + escapeText( encodeURIComponent(moduleNames[i]) ) + \"' \" +\n\t\t\t\t\t( config.module === moduleNames[i] ? \"selected='selected'\" : \"\" ) +\n\t\t\t\t\t\">\" + escapeText(moduleNames[i]) + \"</option>\";\n\t\t}\n\t\tmoduleFilterHtml += \"</select>\";\n\t\n\t\t// `userAgent` initialized at top of scope\n\t\tuserAgent = id( \"qunit-userAgent\" );\n\t\tif ( userAgent ) {\n\t\t\tuserAgent.innerHTML = navigator.userAgent;\n\t\t}\n\t\n\t\t// `banner` initialized at top of scope\n\t\tbanner = id( \"qunit-header\" );\n\t\tif ( banner ) {\n\t\t\tbanner.innerHTML = \"<a href='\" + QUnit.url({ filter: undefined, module: undefined, testNumber: undefined }) + \"'>\" + banner.innerHTML + \"</a> \";\n\t\t}\n\t\n\t\t// `toolbar` initialized at top of scope\n\t\ttoolbar = id( \"qunit-testrunner-toolbar\" );\n\t\tif ( toolbar ) {\n\t\t\t// `filter` initialized at top of scope\n\t\t\tfilter = document.createElement( \"input\" );\n\t\t\tfilter.type = \"checkbox\";\n\t\t\tfilter.id = \"qunit-filter-pass\";\n\t\n\t\t\taddEvent( filter, \"click\", function() {\n\t\t\t\tvar tmp,\n\t\t\t\t\tol = id( \"qunit-tests\" );\n\t\n\t\t\t\tif ( filter.checked ) {\n\t\t\t\t\tol.className = ol.className + \" hidepass\";\n\t\t\t\t} else {\n\t\t\t\t\ttmp = \" \" + ol.className.replace( /[\\n\\t\\r]/g, \" \" ) + \" \";\n\t\t\t\t\tol.className = tmp.replace( / hidepass /, \" \" );\n\t\t\t\t}\n\t\t\t\tif ( defined.sessionStorage ) {\n\t\t\t\t\tif (filter.checked) {\n\t\t\t\t\t\tsessionStorage.setItem( \"qunit-filter-passed-tests\", \"true\" );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsessionStorage.removeItem( \"qunit-filter-passed-tests\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tif ( config.hidepassed || defined.sessionStorage && sessionStorage.getItem( \"qunit-filter-passed-tests\" ) ) {\n\t\t\t\tfilter.checked = true;\n\t\t\t\t// `ol` initialized at top of scope\n\t\t\t\tol = id( \"qunit-tests\" );\n\t\t\t\tol.className = ol.className + \" hidepass\";\n\t\t\t}\n\t\t\ttoolbar.appendChild( filter );\n\t\n\t\t\t// `label` initialized at top of scope\n\t\t\tlabel = document.createElement( \"label\" );\n\t\t\tlabel.setAttribute( \"for\", \"qunit-filter-pass\" );\n\t\t\tlabel.setAttribute( \"title\", \"Only show tests and assertions that fail. Stored in sessionStorage.\" );\n\t\t\tlabel.innerHTML = \"Hide passed tests\";\n\t\t\ttoolbar.appendChild( label );\n\t\n\t\t\turlConfigContainer = document.createElement(\"span\");\n\t\t\turlConfigContainer.innerHTML = urlConfigHtml;\n\t\t\t// For oldIE support:\n\t\t\t// * Add handlers to the individual elements instead of the container\n\t\t\t// * Use \"click\" instead of \"change\" for checkboxes\n\t\t\t// * Fallback from event.target to event.srcElement\n\t\t\taddEvents( urlConfigContainer.getElementsByTagName(\"input\"), \"click\", function( event ) {\n\t\t\t\tvar params = {},\n\t\t\t\t\ttarget = event.target || event.srcElement;\n\t\t\t\tparams[ target.name ] = target.checked ?\n\t\t\t\t\ttarget.defaultValue || true :\n\t\t\t\t\tundefined;\n\t\t\t\twindow.location = QUnit.url( params );\n\t\t\t});\n\t\t\taddEvents( urlConfigContainer.getElementsByTagName(\"select\"), \"change\", function( event ) {\n\t\t\t\tvar params = {},\n\t\t\t\t\ttarget = event.target || event.srcElement;\n\t\t\t\tparams[ target.name ] = target.options[ target.selectedIndex ].value || undefined;\n\t\t\t\twindow.location = QUnit.url( params );\n\t\t\t});\n\t\t\ttoolbar.appendChild( urlConfigContainer );\n\t\n\t\t\tif (numModules > 1) {\n\t\t\t\tmoduleFilter = document.createElement( \"span\" );\n\t\t\t\tmoduleFilter.setAttribute( \"id\", \"qunit-modulefilter-container\" );\n\t\t\t\tmoduleFilter.innerHTML = moduleFilterHtml;\n\t\t\t\taddEvent( moduleFilter.lastChild, \"change\", function() {\n\t\t\t\t\tvar selectBox = moduleFilter.getElementsByTagName(\"select\")[0],\n\t\t\t\t\t\tselectedModule = decodeURIComponent(selectBox.options[selectBox.selectedIndex].value);\n\t\n\t\t\t\t\twindow.location = QUnit.url({\n\t\t\t\t\t\tmodule: ( selectedModule === \"\" ) ? undefined : selectedModule,\n\t\t\t\t\t\t// Remove any existing filters\n\t\t\t\t\t\tfilter: undefined,\n\t\t\t\t\t\ttestNumber: undefined\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\ttoolbar.appendChild(moduleFilter);\n\t\t\t}\n\t\t}\n\t\n\t\t// `main` initialized at top of scope\n\t\tmain = id( \"qunit-fixture\" );\n\t\tif ( main ) {\n\t\t\tconfig.fixture = main.innerHTML;\n\t\t}\n\t\n\t\tif ( config.autostart ) {\n\t\t\tQUnit.start();\n\t\t}\n\t};\n\t\n\tif ( defined.document ) {\n\t\taddEvent( window, \"load\", QUnit.load );\n\t}\n\t\n\t// `onErrorFnPrev` initialized at top of scope\n\t// Preserve other handlers\n\tonErrorFnPrev = window.onerror;\n\t\n\t// Cover uncaught exceptions\n\t// Returning true will suppress the default browser handler,\n\t// returning false will let it run.\n\twindow.onerror = function ( error, filePath, linerNr ) {\n\t\tvar ret = false;\n\t\tif ( onErrorFnPrev ) {\n\t\t\tret = onErrorFnPrev( error, filePath, linerNr );\n\t\t}\n\t\n\t\t// Treat return value as window.onerror itself does,\n\t\t// Only do our handling if not suppressed.\n\t\tif ( ret !== true ) {\n\t\t\tif ( QUnit.config.current ) {\n\t\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t} else {\n\t\t\t\tQUnit.test( \"global failure\", extend( function() {\n\t\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t\t}, { validTest: validTest } ) );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\n\t\treturn ret;\n\t};\n\t\n\tfunction done() {\n\t\tconfig.autorun = true;\n\t\n\t\t// Log the last module results\n\t\tif ( config.previousModule ) {\n\t\t\trunLoggingCallbacks( \"moduleDone\", QUnit, {\n\t\t\t\tname: config.previousModule,\n\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\ttotal: config.moduleStats.all\n\t\t\t});\n\t\t}\n\t\tdelete config.previousModule;\n\t\n\t\tvar i, key,\n\t\t\tbanner = id( \"qunit-banner\" ),\n\t\t\ttests = id( \"qunit-tests\" ),\n\t\t\truntime = +new Date() - config.started,\n\t\t\tpassed = config.stats.all - config.stats.bad,\n\t\t\thtml = [\n\t\t\t\t\"Tests completed in \",\n\t\t\t\truntime,\n\t\t\t\t\" milliseconds.<br/>\",\n\t\t\t\t\"<span class='passed'>\",\n\t\t\t\tpassed,\n\t\t\t\t\"</span> assertions of <span class='total'>\",\n\t\t\t\tconfig.stats.all,\n\t\t\t\t\"</span> passed, <span class='failed'>\",\n\t\t\t\tconfig.stats.bad,\n\t\t\t\t\"</span> failed.\"\n\t\t\t].join( \"\" );\n\t\n\t\tif ( banner ) {\n\t\t\tbanner.className = ( config.stats.bad ? \"qunit-fail\" : \"qunit-pass\" );\n\t\t}\n\t\n\t\tif ( tests ) {\n\t\t\tid( \"qunit-testresult\" ).innerHTML = html;\n\t\t}\n\t\n\t\tif ( config.altertitle && defined.document && document.title ) {\n\t\t\t// show ✖ for good, ✔ for bad suite result in title\n\t\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\t\tdocument.title = [\n\t\t\t\t( config.stats.bad ? \"\\u2716\" : \"\\u2714\" ),\n\t\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, \"\" )\n\t\t\t].join( \" \" );\n\t\t}\n\t\n\t\t// clear own sessionStorage items if all tests passed\n\t\tif ( config.reorder && defined.sessionStorage && config.stats.bad === 0 ) {\n\t\t\t// `key` & `i` initialized at top of scope\n\t\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\n\t\t\t\tkey = sessionStorage.key( i++ );\n\t\t\t\tif ( key.indexOf( \"qunit-test-\" ) === 0 ) {\n\t\t\t\t\tsessionStorage.removeItem( key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// scroll back to top to show results\n\t\tif ( config.scrolltop && window.scrollTo ) {\n\t\t\twindow.scrollTo(0, 0);\n\t\t}\n\t\n\t\trunLoggingCallbacks( \"done\", QUnit, {\n\t\t\tfailed: config.stats.bad,\n\t\t\tpassed: passed,\n\t\t\ttotal: config.stats.all,\n\t\t\truntime: runtime\n\t\t});\n\t}\n\t\n\t/** @return Boolean: true if this test should be ran */\n\tfunction validTest( test ) {\n\t\tvar include,\n\t\t\tfilter = config.filter && config.filter.toLowerCase(),\n\t\t\tmodule = config.module && config.module.toLowerCase(),\n\t\t\tfullName = ( test.module + \": \" + test.testName ).toLowerCase();\n\t\n\t\t// Internally-generated tests are always valid\n\t\tif ( test.callback && test.callback.validTest === validTest ) {\n\t\t\tdelete test.callback.validTest;\n\t\t\treturn true;\n\t\t}\n\t\n\t\tif ( config.testNumber.length > 0 ) {\n\t\t\tif ( inArray( test.testNumber, config.testNumber ) < 0 ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\n\t\tif ( module && ( !test.module || test.module.toLowerCase() !== module ) ) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tif ( !filter ) {\n\t\t\treturn true;\n\t\t}\n\t\n\t\tinclude = filter.charAt( 0 ) !== \"!\";\n\t\tif ( !include ) {\n\t\t\tfilter = filter.slice( 1 );\n\t\t}\n\t\n\t\t// If the filter matches, we need to honour include\n\t\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\t\treturn include;\n\t\t}\n\t\n\t\t// Otherwise, do the opposite\n\t\treturn !include;\n\t}\n\t\n\t// so far supports only Firefox, Chrome and Opera (buggy), Safari (for real exceptions)\n\t// Later Safari and IE10 are supposed to support error.stack as well\n\t// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\n\tfunction extractStacktrace( e, offset ) {\n\t\toffset = offset === undefined ? 3 : offset;\n\t\n\t\tvar stack, include, i;\n\t\n\t\tif ( e.stacktrace ) {\n\t\t\t// Opera\n\t\t\treturn e.stacktrace.split( \"\\n\" )[ offset + 3 ];\n\t\t} else if ( e.stack ) {\n\t\t\t// Firefox, Chrome\n\t\t\tstack = e.stack.split( \"\\n\" );\n\t\t\tif (/^error$/i.test( stack[0] ) ) {\n\t\t\t\tstack.shift();\n\t\t\t}\n\t\t\tif ( fileName ) {\n\t\t\t\tinclude = [];\n\t\t\t\tfor ( i = offset; i < stack.length; i++ ) {\n\t\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tinclude.push( stack[ i ] );\n\t\t\t\t}\n\t\t\t\tif ( include.length ) {\n\t\t\t\t\treturn include.join( \"\\n\" );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stack[ offset ];\n\t\t} else if ( e.sourceURL ) {\n\t\t\t// Safari, PhantomJS\n\t\t\t// hopefully one day Safari provides actual stacktraces\n\t\t\t// exclude useless self-reference for generated Error objects\n\t\t\tif ( /qunit.js$/.test( e.sourceURL ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// for actual exceptions, this is useful\n\t\t\treturn e.sourceURL + \":\" + e.line;\n\t\t}\n\t}\n\tfunction sourceFromStacktrace( offset ) {\n\t\ttry {\n\t\t\tthrow new Error();\n\t\t} catch ( e ) {\n\t\t\treturn extractStacktrace( e, offset );\n\t\t}\n\t}\n\t\n\t/**\n\t * Escape text for attribute or text content.\n\t */\n\tfunction escapeText( s ) {\n\t\tif ( !s ) {\n\t\t\treturn \"\";\n\t\t}\n\t\ts = s + \"\";\n\t\t// Both single quotes and double quotes (for attributes)\n\t\treturn s.replace( /['\"<>&]/g, function( s ) {\n\t\t\tswitch( s ) {\n\t\t\t\tcase \"'\":\n\t\t\t\t\treturn \"&#039;\";\n\t\t\t\tcase \"\\\"\":\n\t\t\t\t\treturn \"&quot;\";\n\t\t\t\tcase \"<\":\n\t\t\t\t\treturn \"&lt;\";\n\t\t\t\tcase \">\":\n\t\t\t\t\treturn \"&gt;\";\n\t\t\t\tcase \"&\":\n\t\t\t\t\treturn \"&amp;\";\n\t\t\t}\n\t\t});\n\t}\n\t\n\tfunction synchronize( callback, last ) {\n\t\tconfig.queue.push( callback );\n\t\n\t\tif ( config.autorun && !config.blocking ) {\n\t\t\tprocess( last );\n\t\t}\n\t}\n\t\n\tfunction process( last ) {\n\t\tfunction next() {\n\t\t\tprocess( last );\n\t\t}\n\t\tvar start = new Date().getTime();\n\t\tconfig.depth = config.depth ? config.depth + 1 : 1;\n\t\n\t\twhile ( config.queue.length && !config.blocking ) {\n\t\t\tif ( !defined.setTimeout || config.updateRate <= 0 || ( ( new Date().getTime() - start ) < config.updateRate ) ) {\n\t\t\t\tconfig.queue.shift()();\n\t\t\t} else {\n\t\t\t\tsetTimeout( next, 13 );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconfig.depth--;\n\t\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\t\tdone();\n\t\t}\n\t}\n\t\n\tfunction saveGlobal() {\n\t\tconfig.pollution = [];\n\t\n\t\tif ( config.noglobals ) {\n\t\t\tfor ( var key in window ) {\n\t\t\t\tif ( hasOwn.call( window, key ) ) {\n\t\t\t\t\t// in Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconfig.pollution.push( key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction checkPollution() {\n\t\tvar newGlobals,\n\t\t\tdeletedGlobals,\n\t\t\told = config.pollution;\n\t\n\t\tsaveGlobal();\n\t\n\t\tnewGlobals = diff( config.pollution, old );\n\t\tif ( newGlobals.length > 0 ) {\n\t\t\tQUnit.pushFailure( \"Introduced global variable(s): \" + newGlobals.join(\", \") );\n\t\t}\n\t\n\t\tdeletedGlobals = diff( old, config.pollution );\n\t\tif ( deletedGlobals.length > 0 ) {\n\t\t\tQUnit.pushFailure( \"Deleted global variable(s): \" + deletedGlobals.join(\", \") );\n\t\t}\n\t}\n\t\n\t// returns a new Array with the elements that are in a but not in b\n\tfunction diff( a, b ) {\n\t\tvar i, j,\n\t\t\tresult = a.slice();\n\t\n\t\tfor ( i = 0; i < result.length; i++ ) {\n\t\t\tfor ( j = 0; j < b.length; j++ ) {\n\t\t\t\tif ( result[i] === b[j] ) {\n\t\t\t\t\tresult.splice( i, 1 );\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tfunction extend( a, b ) {\n\t\tfor ( var prop in b ) {\n\t\t\tif ( hasOwn.call( b, prop ) ) {\n\t\t\t\t// Avoid \"Member not found\" error in IE8 caused by messing with window.constructor\n\t\t\t\tif ( !( prop === \"constructor\" && a === window ) ) {\n\t\t\t\t\tif ( b[ prop ] === undefined ) {\n\t\t\t\t\t\tdelete a[ prop ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta[ prop ] = b[ prop ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn a;\n\t}\n\t\n\t/**\n\t * @param {HTMLElement} elem\n\t * @param {string} type\n\t * @param {Function} fn\n\t */\n\tfunction addEvent( elem, type, fn ) {\n\t\tif ( elem.addEventListener ) {\n\t\n\t\t\t// Standards-based browsers\n\t\t\telem.addEventListener( type, fn, false );\n\t\t} else if ( elem.attachEvent ) {\n\t\n\t\t\t// support: IE <9\n\t\t\telem.attachEvent( \"on\" + type, fn );\n\t\t} else {\n\t\n\t\t\t// Caller must ensure support for event listeners is present\n\t\t\tthrow new Error( \"addEvent() was called in a context without event listener support\" );\n\t\t}\n\t}\n\t\n\t/**\n\t * @param {Array|NodeList} elems\n\t * @param {string} type\n\t * @param {Function} fn\n\t */\n\tfunction addEvents( elems, type, fn ) {\n\t\tvar i = elems.length;\n\t\twhile ( i-- ) {\n\t\t\taddEvent( elems[i], type, fn );\n\t\t}\n\t}\n\t\n\tfunction hasClass( elem, name ) {\n\t\treturn (\" \" + elem.className + \" \").indexOf(\" \" + name + \" \") > -1;\n\t}\n\t\n\tfunction addClass( elem, name ) {\n\t\tif ( !hasClass( elem, name ) ) {\n\t\t\telem.className += (elem.className ? \" \" : \"\") + name;\n\t\t}\n\t}\n\t\n\tfunction removeClass( elem, name ) {\n\t\tvar set = \" \" + elem.className + \" \";\n\t\t// Class name may appear multiple times\n\t\twhile ( set.indexOf(\" \" + name + \" \") > -1 ) {\n\t\t\tset = set.replace(\" \" + name + \" \" , \" \");\n\t\t}\n\t\t// If possible, trim it for prettiness, but not necessarily\n\t\telem.className = typeof set.trim === \"function\" ? set.trim() : set.replace(/^\\s+|\\s+$/g, \"\");\n\t}\n\t\n\tfunction id( name ) {\n\t\treturn defined.document && document.getElementById && document.getElementById( name );\n\t}\n\t\n\tfunction registerLoggingCallback( key ) {\n\t\treturn function( callback ) {\n\t\t\tconfig[key].push( callback );\n\t\t};\n\t}\n\t\n\t// Supports deprecated method of completely overwriting logging callbacks\n\tfunction runLoggingCallbacks( key, scope, args ) {\n\t\tvar i, callbacks;\n\t\tif ( QUnit.hasOwnProperty( key ) ) {\n\t\t\tQUnit[ key ].call(scope, args );\n\t\t} else {\n\t\t\tcallbacks = config[ key ];\n\t\t\tfor ( i = 0; i < callbacks.length; i++ ) {\n\t\t\t\tcallbacks[ i ].call( scope, args );\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// from jquery.js\n\tfunction inArray( elem, array ) {\n\t\tif ( array.indexOf ) {\n\t\t\treturn array.indexOf( elem );\n\t\t}\n\t\n\t\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\t\tif ( array[ i ] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\n\t\treturn -1;\n\t}\n\t\n\tfunction Test( settings ) {\n\t\textend( this, settings );\n\t\tthis.assertions = [];\n\t\tthis.testNumber = ++Test.count;\n\t}\n\t\n\tTest.count = 0;\n\t\n\tTest.prototype = {\n\t\tinit: function() {\n\t\t\tvar a, b, li,\n\t\t\t\ttests = id( \"qunit-tests\" );\n\t\n\t\t\tif ( tests ) {\n\t\t\t\tb = document.createElement( \"strong\" );\n\t\t\t\tb.innerHTML = this.nameHtml;\n\t\n\t\t\t\t// `a` initialized at top of scope\n\t\t\t\ta = document.createElement( \"a\" );\n\t\t\t\ta.innerHTML = \"Rerun\";\n\t\t\t\ta.href = QUnit.url({ testNumber: this.testNumber });\n\t\n\t\t\t\tli = document.createElement( \"li\" );\n\t\t\t\tli.appendChild( b );\n\t\t\t\tli.appendChild( a );\n\t\t\t\tli.className = \"running\";\n\t\t\t\tli.id = this.id = \"qunit-test-output\" + testId++;\n\t\n\t\t\t\ttests.appendChild( li );\n\t\t\t}\n\t\t},\n\t\tsetup: function() {\n\t\t\tif (\n\t\t\t\t// Emit moduleStart when we're switching from one module to another\n\t\t\t\tthis.module !== config.previousModule ||\n\t\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn't\n\t\t\t\t\t// yet exist it means this is the first test in a suite that isn't wrapped in a\n\t\t\t\t\t// module, in which case we'll just emit a moduleStart event for 'undefined'.\n\t\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t\t!hasOwn.call( config, \"previousModule\" )\n\t\t\t) {\n\t\t\t\tif ( hasOwn.call( config, \"previousModule\" ) ) {\n\t\t\t\t\trunLoggingCallbacks( \"moduleDone\", QUnit, {\n\t\t\t\t\t\tname: config.previousModule,\n\t\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\t\ttotal: config.moduleStats.all\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconfig.previousModule = this.module;\n\t\t\t\tconfig.moduleStats = { all: 0, bad: 0 };\n\t\t\t\trunLoggingCallbacks( \"moduleStart\", QUnit, {\n\t\t\t\t\tname: this.module\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tconfig.current = this;\n\t\n\t\t\tthis.testEnvironment = extend({\n\t\t\t\tsetup: function() {},\n\t\t\t\tteardown: function() {}\n\t\t\t}, this.moduleTestEnvironment );\n\t\n\t\t\tthis.started = +new Date();\n\t\t\trunLoggingCallbacks( \"testStart\", QUnit, {\n\t\t\t\tname: this.testName,\n\t\t\t\tmodule: this.module\n\t\t\t});\n\t\n\t\t\t/*jshint camelcase:false */\n\t\n\t\n\t\t\t/**\n\t\t\t * Expose the current test environment.\n\t\t\t *\n\t\t\t * @deprecated since 1.12.0: Use QUnit.config.current.testEnvironment instead.\n\t\t\t */\n\t\t\tQUnit.current_testEnvironment = this.testEnvironment;\n\t\n\t\t\t/*jshint camelcase:true */\n\t\n\t\t\tif ( !config.pollution ) {\n\t\t\t\tsaveGlobal();\n\t\t\t}\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\tthis.testEnvironment.setup.call( this.testEnvironment, QUnit.assert );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthis.testEnvironment.setup.call( this.testEnvironment, QUnit.assert );\n\t\t\t} catch( e ) {\n\t\t\t\tQUnit.pushFailure( \"Setup failed on \" + this.testName + \": \" + ( e.message || e ), extractStacktrace( e, 1 ) );\n\t\t\t}\n\t\t},\n\t\trun: function() {\n\t\t\tconfig.current = this;\n\t\n\t\t\tvar running = id( \"qunit-testresult\" );\n\t\n\t\t\tif ( running ) {\n\t\t\t\trunning.innerHTML = \"Running: <br/>\" + this.nameHtml;\n\t\t\t}\n\t\n\t\t\tif ( this.async ) {\n\t\t\t\tQUnit.stop();\n\t\t\t}\n\t\n\t\t\tthis.callbackStarted = +new Date();\n\t\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\tthis.callback.call( this.testEnvironment, QUnit.assert );\n\t\t\t\tthis.callbackRuntime = +new Date() - this.callbackStarted;\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\ttry {\n\t\t\t\tthis.callback.call( this.testEnvironment, QUnit.assert );\n\t\t\t\tthis.callbackRuntime = +new Date() - this.callbackStarted;\n\t\t\t} catch( e ) {\n\t\t\t\tthis.callbackRuntime = +new Date() - this.callbackStarted;\n\t\n\t\t\t\tQUnit.pushFailure( \"Died on test #\" + (this.assertions.length + 1) + \" \" + this.stack + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );\n\t\t\t\t// else next test will carry the responsibility\n\t\t\t\tsaveGlobal();\n\t\n\t\t\t\t// Restart the tests if they're blocking\n\t\t\t\tif ( config.blocking ) {\n\t\t\t\t\tQUnit.start();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tteardown: function() {\n\t\t\tconfig.current = this;\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\tif ( typeof this.callbackRuntime === \"undefined\" ) {\n\t\t\t\t\tthis.callbackRuntime = +new Date() - this.callbackStarted;\n\t\t\t\t}\n\t\t\t\tthis.testEnvironment.teardown.call( this.testEnvironment, QUnit.assert );\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tthis.testEnvironment.teardown.call( this.testEnvironment, QUnit.assert );\n\t\t\t\t} catch( e ) {\n\t\t\t\t\tQUnit.pushFailure( \"Teardown failed on \" + this.testName + \": \" + ( e.message || e ), extractStacktrace( e, 1 ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckPollution();\n\t\t},\n\t\tfinish: function() {\n\t\t\tconfig.current = this;\n\t\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\t\tQUnit.pushFailure( \"Expected number of assertions to be defined, but expect() was not called.\", this.stack );\n\t\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\t\tQUnit.pushFailure( \"Expected \" + this.expected + \" assertions, but \" + this.assertions.length + \" were run\", this.stack );\n\t\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\t\tQUnit.pushFailure( \"Expected at least one assertion, but none were run - call expect(0) to accept zero assertions.\", this.stack );\n\t\t\t}\n\t\n\t\t\tvar i, assertion, a, b, time, li, ol,\n\t\t\t\ttest = this,\n\t\t\t\tgood = 0,\n\t\t\t\tbad = 0,\n\t\t\t\ttests = id( \"qunit-tests\" );\n\t\n\t\t\tthis.runtime = +new Date() - this.started;\n\t\t\tconfig.stats.all += this.assertions.length;\n\t\t\tconfig.moduleStats.all += this.assertions.length;\n\t\n\t\t\tif ( tests ) {\n\t\t\t\tol = document.createElement( \"ol\" );\n\t\t\t\tol.className = \"qunit-assert-list\";\n\t\n\t\t\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\t\t\tassertion = this.assertions[i];\n\t\n\t\t\t\t\tli = document.createElement( \"li\" );\n\t\t\t\t\tli.className = assertion.result ? \"pass\" : \"fail\";\n\t\t\t\t\tli.innerHTML = assertion.message || ( assertion.result ? \"okay\" : \"failed\" );\n\t\t\t\t\tol.appendChild( li );\n\t\n\t\t\t\t\tif ( assertion.result ) {\n\t\t\t\t\t\tgood++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbad++;\n\t\t\t\t\t\tconfig.stats.bad++;\n\t\t\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// store result when possible\n\t\t\t\tif ( QUnit.config.reorder && defined.sessionStorage ) {\n\t\t\t\t\tif ( bad ) {\n\t\t\t\t\t\tsessionStorage.setItem( \"qunit-test-\" + this.module + \"-\" + this.testName, bad );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsessionStorage.removeItem( \"qunit-test-\" + this.module + \"-\" + this.testName );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif ( bad === 0 ) {\n\t\t\t\t\taddClass( ol, \"qunit-collapsed\" );\n\t\t\t\t}\n\t\n\t\t\t\t// `b` initialized at top of scope\n\t\t\t\tb = document.createElement( \"strong\" );\n\t\t\t\tb.innerHTML = this.nameHtml + \" <b class='counts'>(<b class='failed'>\" + bad + \"</b>, <b class='passed'>\" + good + \"</b>, \" + this.assertions.length + \")</b>\";\n\t\n\t\t\t\taddEvent(b, \"click\", function() {\n\t\t\t\t\tvar next = b.parentNode.lastChild,\n\t\t\t\t\t\tcollapsed = hasClass( next, \"qunit-collapsed\" );\n\t\t\t\t\t( collapsed ? removeClass : addClass )( next, \"qunit-collapsed\" );\n\t\t\t\t});\n\t\n\t\t\t\taddEvent(b, \"dblclick\", function( e ) {\n\t\t\t\t\tvar target = e && e.target ? e.target : window.event.srcElement;\n\t\t\t\t\tif ( target.nodeName.toLowerCase() === \"span\" || target.nodeName.toLowerCase() === \"b\" ) {\n\t\t\t\t\t\ttarget = target.parentNode;\n\t\t\t\t\t}\n\t\t\t\t\tif ( window.location && target.nodeName.toLowerCase() === \"strong\" ) {\n\t\t\t\t\t\twindow.location = QUnit.url({ testNumber: test.testNumber });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\t// `time` initialized at top of scope\n\t\t\t\ttime = document.createElement( \"span\" );\n\t\t\t\ttime.className = \"runtime\";\n\t\t\t\ttime.innerHTML = this.runtime + \" ms\";\n\t\n\t\t\t\t// `li` initialized at top of scope\n\t\t\t\tli = id( this.id );\n\t\t\t\tli.className = bad ? \"fail\" : \"pass\";\n\t\t\t\tli.removeChild( li.firstChild );\n\t\t\t\ta = li.firstChild;\n\t\t\t\tli.appendChild( b );\n\t\t\t\tli.appendChild( a );\n\t\t\t\tli.appendChild( time );\n\t\t\t\tli.appendChild( ol );\n\t\n\t\t\t} else {\n\t\t\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\t\t\tif ( !this.assertions[i].result ) {\n\t\t\t\t\t\tbad++;\n\t\t\t\t\t\tconfig.stats.bad++;\n\t\t\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\trunLoggingCallbacks( \"testDone\", QUnit, {\n\t\t\t\tname: this.testName,\n\t\t\t\tmodule: this.module,\n\t\t\t\tfailed: bad,\n\t\t\t\tpassed: this.assertions.length - bad,\n\t\t\t\ttotal: this.assertions.length,\n\t\t\t\truntime: this.runtime,\n\t\t\t\t// DEPRECATED: this property will be removed in 2.0.0, use runtime instead\n\t\t\t\tduration: this.runtime\n\t\t\t});\n\t\n\t\t\tQUnit.reset();\n\t\n\t\t\tconfig.current = undefined;\n\t\t},\n\t\n\t\tqueue: function() {\n\t\t\tvar bad,\n\t\t\t\ttest = this;\n\t\n\t\t\tsynchronize(function() {\n\t\t\t\ttest.init();\n\t\t\t});\n\t\t\tfunction run() {\n\t\t\t\t// each of these can by async\n\t\t\t\tsynchronize(function() {\n\t\t\t\t\ttest.setup();\n\t\t\t\t});\n\t\t\t\tsynchronize(function() {\n\t\t\t\t\ttest.run();\n\t\t\t\t});\n\t\t\t\tsynchronize(function() {\n\t\t\t\t\ttest.teardown();\n\t\t\t\t});\n\t\t\t\tsynchronize(function() {\n\t\t\t\t\ttest.finish();\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t// `bad` initialized at top of scope\n\t\t\t// defer when previous test run passed, if storage is available\n\t\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t\t\t\t+sessionStorage.getItem( \"qunit-test-\" + this.module + \"-\" + this.testName );\n\t\n\t\t\tif ( bad ) {\n\t\t\t\trun();\n\t\t\t} else {\n\t\t\t\tsynchronize( run, true );\n\t\t\t}\n\t\t}\n\t};\n\t\n\t// `assert` initialized at top of scope\n\t// Assert helpers\n\t// All of these must either call QUnit.push() or manually do:\n\t// - runLoggingCallbacks( \"log\", .. );\n\t// - config.current.assertions.push({ .. });\n\tassert = QUnit.assert = {\n\t\t/**\n\t\t * Asserts rough true-ish result.\n\t\t * @name ok\n\t\t * @function\n\t\t * @example ok( \"asdfasdf\".length > 5, \"There must be at least 5 chars\" );\n\t\t */\n\t\tok: function( result, msg ) {\n\t\t\tif ( !config.current ) {\n\t\t\t\tthrow new Error( \"ok() assertion outside test context, was \" + sourceFromStacktrace(2) );\n\t\t\t}\n\t\t\tresult = !!result;\n\t\t\tmsg = msg || ( result ? \"okay\" : \"failed\" );\n\t\n\t\t\tvar source,\n\t\t\t\tdetails = {\n\t\t\t\t\tmodule: config.current.module,\n\t\t\t\t\tname: config.current.testName,\n\t\t\t\t\tresult: result,\n\t\t\t\t\tmessage: msg\n\t\t\t\t};\n\t\n\t\t\tmsg = \"<span class='test-message'>\" + escapeText( msg ) + \"</span>\";\n\t\n\t\t\tif ( !result ) {\n\t\t\t\tsource = sourceFromStacktrace( 2 );\n\t\t\t\tif ( source ) {\n\t\t\t\t\tdetails.source = source;\n\t\t\t\t\tmsg += \"<table><tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\t\t\t\tescapeText( source ) +\n\t\t\t\t\t\t\"</pre></td></tr></table>\";\n\t\t\t\t}\n\t\t\t}\n\t\t\trunLoggingCallbacks( \"log\", QUnit, details );\n\t\t\tconfig.current.assertions.push({\n\t\t\t\tresult: result,\n\t\t\t\tmessage: msg\n\t\t\t});\n\t\t},\n\t\n\t\t/**\n\t\t * Assert that the first two arguments are equal, with an optional message.\n\t\t * Prints out both actual and expected values.\n\t\t * @name equal\n\t\t * @function\n\t\t * @example equal( format( \"Received {0} bytes.\", 2), \"Received 2 bytes.\", \"format() replaces {0} with next argument\" );\n\t\t */\n\t\tequal: function( actual, expected, message ) {\n\t\t\t/*jshint eqeqeq:false */\n\t\t\tQUnit.push( expected == actual, actual, expected, message );\n\t\t},\n\t\n\t\t/**\n\t\t * @name notEqual\n\t\t * @function\n\t\t */\n\t\tnotEqual: function( actual, expected, message ) {\n\t\t\t/*jshint eqeqeq:false */\n\t\t\tQUnit.push( expected != actual, actual, expected, message );\n\t\t},\n\t\n\t\t/**\n\t\t * @name propEqual\n\t\t * @function\n\t\t */\n\t\tpropEqual: function( actual, expected, message ) {\n\t\t\tactual = objectValues(actual);\n\t\t\texpected = objectValues(expected);\n\t\t\tQUnit.push( QUnit.equiv(actual, expected), actual, expected, message );\n\t\t},\n\t\n\t\t/**\n\t\t * @name notPropEqual\n\t\t * @function\n\t\t */\n\t\tnotPropEqual: function( actual, expected, message ) {\n\t\t\tactual = objectValues(actual);\n\t\t\texpected = objectValues(expected);\n\t\t\tQUnit.push( !QUnit.equiv(actual, expected), actual, expected, message );\n\t\t},\n\t\n\t\t/**\n\t\t * @name deepEqual\n\t\t * @function\n\t\t */\n\t\tdeepEqual: function( actual, expected, message ) {\n\t\t\tQUnit.push( QUnit.equiv(actual, expected), actual, expected, message );\n\t\t},\n\t\n\t\t/**\n\t\t * @name notDeepEqual\n\t\t * @function\n\t\t */\n\t\tnotDeepEqual: function( actual, expected, message ) {\n\t\t\tQUnit.push( !QUnit.equiv(actual, expected), actual, expected, message );\n\t\t},\n\t\n\t\t/**\n\t\t * @name strictEqual\n\t\t * @function\n\t\t */\n\t\tstrictEqual: function( actual, expected, message ) {\n\t\t\tQUnit.push( expected === actual, actual, expected, message );\n\t\t},\n\t\n\t\t/**\n\t\t * @name notStrictEqual\n\t\t * @function\n\t\t */\n\t\tnotStrictEqual: function( actual, expected, message ) {\n\t\t\tQUnit.push( expected !== actual, actual, expected, message );\n\t\t},\n\t\n\t\t\"throws\": function( block, expected, message ) {\n\t\t\tvar actual,\n\t\t\t\texpectedOutput = expected,\n\t\t\t\tok = false;\n\t\n\t\t\t// 'expected' is optional\n\t\t\tif ( !message && typeof expected === \"string\" ) {\n\t\t\t\tmessage = expected;\n\t\t\t\texpected = null;\n\t\t\t}\n\t\n\t\t\tconfig.current.ignoreGlobalErrors = true;\n\t\t\ttry {\n\t\t\t\tblock.call( config.current.testEnvironment );\n\t\t\t} catch (e) {\n\t\t\t\tactual = e;\n\t\t\t}\n\t\t\tconfig.current.ignoreGlobalErrors = false;\n\t\n\t\t\tif ( actual ) {\n\t\n\t\t\t\t// we don't want to validate thrown error\n\t\t\t\tif ( !expected ) {\n\t\t\t\t\tok = true;\n\t\t\t\t\texpectedOutput = null;\n\t\n\t\t\t\t// expected is an Error object\n\t\t\t\t} else if ( expected instanceof Error ) {\n\t\t\t\t\tok = actual instanceof Error &&\n\t\t\t\t\t\t actual.name === expected.name &&\n\t\t\t\t\t\t actual.message === expected.message;\n\t\n\t\t\t\t// expected is a regexp\n\t\t\t\t} else if ( QUnit.objectType( expected ) === \"regexp\" ) {\n\t\t\t\t\tok = expected.test( errorString( actual ) );\n\t\n\t\t\t\t// expected is a string\n\t\t\t\t} else if ( QUnit.objectType( expected ) === \"string\" ) {\n\t\t\t\t\tok = expected === errorString( actual );\n\t\n\t\t\t\t// expected is a constructor\n\t\t\t\t} else if ( actual instanceof expected ) {\n\t\t\t\t\tok = true;\n\t\n\t\t\t\t// expected is a validation function which returns true is validation passed\n\t\t\t\t} else if ( expected.call( {}, actual ) === true ) {\n\t\t\t\t\texpectedOutput = null;\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\n\t\t\t\tQUnit.push( ok, actual, expectedOutput, message );\n\t\t\t} else {\n\t\t\t\tQUnit.pushFailure( message, null, \"No exception was thrown.\" );\n\t\t\t}\n\t\t}\n\t};\n\t\n\t/**\n\t * @deprecated since 1.8.0\n\t * Kept assertion helpers in root for backwards compatibility.\n\t */\n\textend( QUnit.constructor.prototype, assert );\n\t\n\t/**\n\t * @deprecated since 1.9.0\n\t * Kept to avoid TypeErrors for undefined methods.\n\t */\n\tQUnit.constructor.prototype.raises = function() {\n\t\tQUnit.push( false, false, false, \"QUnit.raises has been deprecated since 2012 (fad3c1ea), use QUnit.throws instead\" );\n\t};\n\t\n\t/**\n\t * @deprecated since 1.0.0, replaced with error pushes since 1.3.0\n\t * Kept to avoid TypeErrors for undefined methods.\n\t */\n\tQUnit.constructor.prototype.equals = function() {\n\t\tQUnit.push( false, false, false, \"QUnit.equals has been deprecated since 2009 (e88049a0), use QUnit.equal instead\" );\n\t};\n\tQUnit.constructor.prototype.same = function() {\n\t\tQUnit.push( false, false, false, \"QUnit.same has been deprecated since 2009 (e88049a0), use QUnit.deepEqual instead\" );\n\t};\n\t\n\t// Test for equality any JavaScript type.\n\t// Author: Philippe Rathé <prathe@gmail.com>\n\tQUnit.equiv = (function() {\n\t\n\t\t// Call the o related callback with the given arguments.\n\t\tfunction bindCallbacks( o, callbacks, args ) {\n\t\t\tvar prop = QUnit.objectType( o );\n\t\t\tif ( prop ) {\n\t\t\t\tif ( QUnit.objectType( callbacks[ prop ] ) === \"function\" ) {\n\t\t\t\t\treturn callbacks[ prop ].apply( callbacks, args );\n\t\t\t\t} else {\n\t\t\t\t\treturn callbacks[ prop ]; // or undefined\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// the real equiv function\n\t\tvar innerEquiv,\n\t\t\t// stack to decide between skip/abort functions\n\t\t\tcallers = [],\n\t\t\t// stack to avoiding loops from circular referencing\n\t\t\tparents = [],\n\t\t\tparentsB = [],\n\t\n\t\t\tgetProto = Object.getPrototypeOf || function ( obj ) {\n\t\t\t\t/*jshint camelcase:false */\n\t\t\t\treturn obj.__proto__;\n\t\t\t},\n\t\t\tcallbacks = (function () {\n\t\n\t\t\t\t// for string, boolean, number and null\n\t\t\t\tfunction useStrictEquality( b, a ) {\n\t\t\t\t\t/*jshint eqeqeq:false */\n\t\t\t\t\tif ( b instanceof a.constructor || a instanceof b.constructor ) {\n\t\t\t\t\t\t// to catch short annotation VS 'new' annotation of a\n\t\t\t\t\t\t// declaration\n\t\t\t\t\t\t// e.g. var i = 1;\n\t\t\t\t\t\t// var j = new Number(1);\n\t\t\t\t\t\treturn a == b;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn a === b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn {\n\t\t\t\t\t\"string\": useStrictEquality,\n\t\t\t\t\t\"boolean\": useStrictEquality,\n\t\t\t\t\t\"number\": useStrictEquality,\n\t\t\t\t\t\"null\": useStrictEquality,\n\t\t\t\t\t\"undefined\": useStrictEquality,\n\t\n\t\t\t\t\t\"nan\": function( b ) {\n\t\t\t\t\t\treturn isNaN( b );\n\t\t\t\t\t},\n\t\n\t\t\t\t\t\"date\": function( b, a ) {\n\t\t\t\t\t\treturn QUnit.objectType( b ) === \"date\" && a.valueOf() === b.valueOf();\n\t\t\t\t\t},\n\t\n\t\t\t\t\t\"regexp\": function( b, a ) {\n\t\t\t\t\t\treturn QUnit.objectType( b ) === \"regexp\" &&\n\t\t\t\t\t\t\t// the regex itself\n\t\t\t\t\t\t\ta.source === b.source &&\n\t\t\t\t\t\t\t// and its modifiers\n\t\t\t\t\t\t\ta.global === b.global &&\n\t\t\t\t\t\t\t// (gmi) ...\n\t\t\t\t\t\t\ta.ignoreCase === b.ignoreCase &&\n\t\t\t\t\t\t\ta.multiline === b.multiline &&\n\t\t\t\t\t\t\ta.sticky === b.sticky;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t// - skip when the property is a method of an instance (OOP)\n\t\t\t\t\t// - abort otherwise,\n\t\t\t\t\t// initial === would have catch identical references anyway\n\t\t\t\t\t\"function\": function() {\n\t\t\t\t\t\tvar caller = callers[callers.length - 1];\n\t\t\t\t\t\treturn caller !== Object && typeof caller !== \"undefined\";\n\t\t\t\t\t},\n\t\n\t\t\t\t\t\"array\": function( b, a ) {\n\t\t\t\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\t\n\t\t\t\t\t\t// b could be an object literal here\n\t\t\t\t\t\tif ( QUnit.objectType( b ) !== \"array\" ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tlen = a.length;\n\t\t\t\t\t\tif ( len !== b.length ) {\n\t\t\t\t\t\t\t// safe and faster\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// track reference to avoid circular references\n\t\t\t\t\t\tparents.push( a );\n\t\t\t\t\t\tparentsB.push( b );\n\t\t\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\t\t\tloop = false;\n\t\t\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\t\t\t\taCircular = parents[j] === a[i];\n\t\t\t\t\t\t\t\tbCircular = parentsB[j] === b[i];\n\t\t\t\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\t\t\t\tif ( a[i] === b[i] || aCircular && bCircular ) {\n\t\t\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( !loop && !innerEquiv(a[i], b[i]) ) {\n\t\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\n\t\t\t\t\t\"object\": function( b, a ) {\n\t\t\t\t\t\t/*jshint forin:false */\n\t\t\t\t\t\tvar i, j, loop, aCircular, bCircular,\n\t\t\t\t\t\t\t// Default to true\n\t\t\t\t\t\t\teq = true,\n\t\t\t\t\t\t\taProperties = [],\n\t\t\t\t\t\t\tbProperties = [];\n\t\n\t\t\t\t\t\t// comparing constructors is more strict than using\n\t\t\t\t\t\t// instanceof\n\t\t\t\t\t\tif ( a.constructor !== b.constructor ) {\n\t\t\t\t\t\t\t// Allow objects with no prototype to be equivalent to\n\t\t\t\t\t\t\t// objects with Object as their constructor.\n\t\t\t\t\t\t\tif ( !(( getProto(a) === null && getProto(b) === Object.prototype ) ||\n\t\t\t\t\t\t\t\t( getProto(b) === null && getProto(a) === Object.prototype ) ) ) {\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// stack constructor before traversing properties\n\t\t\t\t\t\tcallers.push( a.constructor );\n\t\n\t\t\t\t\t\t// track reference to avoid circular references\n\t\t\t\t\t\tparents.push( a );\n\t\t\t\t\t\tparentsB.push( b );\n\t\n\t\t\t\t\t\t// be strict: don't ensure hasOwnProperty and go deep\n\t\t\t\t\t\tfor ( i in a ) {\n\t\t\t\t\t\t\tloop = false;\n\t\t\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\t\t\t\taCircular = parents[j] === a[i];\n\t\t\t\t\t\t\t\tbCircular = parentsB[j] === b[i];\n\t\t\t\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\t\t\t\tif ( a[i] === b[i] || aCircular && bCircular ) {\n\t\t\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\taProperties.push(i);\n\t\t\t\t\t\t\tif ( !loop && !innerEquiv(a[i], b[i]) ) {\n\t\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\tcallers.pop(); // unstack, we are done\n\t\n\t\t\t\t\t\tfor ( i in b ) {\n\t\t\t\t\t\t\tbProperties.push( i ); // collect b's properties\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Ensures identical properties name\n\t\t\t\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}());\n\t\n\t\tinnerEquiv = function() { // can take multiple arguments\n\t\t\tvar args = [].slice.apply( arguments );\n\t\t\tif ( args.length < 2 ) {\n\t\t\t\treturn true; // end transition\n\t\t\t}\n\t\n\t\t\treturn (function( a, b ) {\n\t\t\t\tif ( a === b ) {\n\t\t\t\t\treturn true; // catch the most you can\n\t\t\t\t} else if ( a === null || b === null || typeof a === \"undefined\" ||\n\t\t\t\t\t\ttypeof b === \"undefined\" ||\n\t\t\t\t\t\tQUnit.objectType(a) !== QUnit.objectType(b) ) {\n\t\t\t\t\treturn false; // don't lose time with error prone cases\n\t\t\t\t} else {\n\t\t\t\t\treturn bindCallbacks(a, callbacks, [ b, a ]);\n\t\t\t\t}\n\t\n\t\t\t\t// apply transition with (1..n) arguments\n\t\t\t}( args[0], args[1] ) && innerEquiv.apply( this, args.splice(1, args.length - 1 )) );\n\t\t};\n\t\n\t\treturn innerEquiv;\n\t}());\n\t\n\t/**\n\t * jsDump Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com |\n\t * http://flesler.blogspot.com Licensed under BSD\n\t * (http://www.opensource.org/licenses/bsd-license.php) Date: 5/15/2008\n\t *\n\t * @projectDescription Advanced and extensible data dumping for Javascript.\n\t * @version 1.0.0\n\t * @author Ariel Flesler\n\t * @link {http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html}\n\t */\n\tQUnit.jsDump = (function() {\n\t\tfunction quote( str ) {\n\t\t\treturn \"\\\"\" + str.toString().replace( /\"/g, \"\\\\\\\"\" ) + \"\\\"\";\n\t\t}\n\t\tfunction literal( o ) {\n\t\t\treturn o + \"\";\n\t\t}\n\t\tfunction join( pre, arr, post ) {\n\t\t\tvar s = jsDump.separator(),\n\t\t\t\tbase = jsDump.indent(),\n\t\t\t\tinner = jsDump.indent(1);\n\t\t\tif ( arr.join ) {\n\t\t\t\tarr = arr.join( \",\" + s + inner );\n\t\t\t}\n\t\t\tif ( !arr ) {\n\t\t\t\treturn pre + post;\n\t\t\t}\n\t\t\treturn [ pre, inner + arr, base + post ].join(s);\n\t\t}\n\t\tfunction array( arr, stack ) {\n\t\t\tvar i = arr.length, ret = new Array(i);\n\t\t\tthis.up();\n\t\t\twhile ( i-- ) {\n\t\t\t\tret[i] = this.parse( arr[i] , undefined , stack);\n\t\t\t}\n\t\t\tthis.down();\n\t\t\treturn join( \"[\", ret, \"]\" );\n\t\t}\n\t\n\t\tvar reName = /^function (\\w+)/,\n\t\t\tjsDump = {\n\t\t\t\t// type is used mostly internally, you can fix a (custom)type in advance\n\t\t\t\tparse: function( obj, type, stack ) {\n\t\t\t\t\tstack = stack || [ ];\n\t\t\t\t\tvar inStack, res,\n\t\t\t\t\t\tparser = this.parsers[ type || this.typeOf(obj) ];\n\t\n\t\t\t\t\ttype = typeof parser;\n\t\t\t\t\tinStack = inArray( obj, stack );\n\t\n\t\t\t\t\tif ( inStack !== -1 ) {\n\t\t\t\t\t\treturn \"recursion(\" + (inStack - stack.length) + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tif ( type === \"function\" )  {\n\t\t\t\t\t\tstack.push( obj );\n\t\t\t\t\t\tres = parser.call( this, obj, stack );\n\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t\treturn ( type === \"string\" ) ? parser : this.parsers.error;\n\t\t\t\t},\n\t\t\t\ttypeOf: function( obj ) {\n\t\t\t\t\tvar type;\n\t\t\t\t\tif ( obj === null ) {\n\t\t\t\t\t\ttype = \"null\";\n\t\t\t\t\t} else if ( typeof obj === \"undefined\" ) {\n\t\t\t\t\t\ttype = \"undefined\";\n\t\t\t\t\t} else if ( QUnit.is( \"regexp\", obj) ) {\n\t\t\t\t\t\ttype = \"regexp\";\n\t\t\t\t\t} else if ( QUnit.is( \"date\", obj) ) {\n\t\t\t\t\t\ttype = \"date\";\n\t\t\t\t\t} else if ( QUnit.is( \"function\", obj) ) {\n\t\t\t\t\t\ttype = \"function\";\n\t\t\t\t\t} else if ( typeof obj.setInterval !== undefined && typeof obj.document !== \"undefined\" && typeof obj.nodeType === \"undefined\" ) {\n\t\t\t\t\t\ttype = \"window\";\n\t\t\t\t\t} else if ( obj.nodeType === 9 ) {\n\t\t\t\t\t\ttype = \"document\";\n\t\t\t\t\t} else if ( obj.nodeType ) {\n\t\t\t\t\t\ttype = \"node\";\n\t\t\t\t\t} else if (\n\t\t\t\t\t\t// native arrays\n\t\t\t\t\t\ttoString.call( obj ) === \"[object Array]\" ||\n\t\t\t\t\t\t// NodeList objects\n\t\t\t\t\t\t( typeof obj.length === \"number\" && typeof obj.item !== \"undefined\" && ( obj.length ? obj.item(0) === obj[0] : ( obj.item( 0 ) === null && typeof obj[0] === \"undefined\" ) ) )\n\t\t\t\t\t) {\n\t\t\t\t\t\ttype = \"array\";\n\t\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {\n\t\t\t\t\t\ttype = \"error\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype = typeof obj;\n\t\t\t\t\t}\n\t\t\t\t\treturn type;\n\t\t\t\t},\n\t\t\t\tseparator: function() {\n\t\t\t\t\treturn this.multiline ?\tthis.HTML ? \"<br />\" : \"\\n\" : this.HTML ? \"&nbsp;\" : \" \";\n\t\t\t\t},\n\t\t\t\t// extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\t\tindent: function( extra ) {\n\t\t\t\t\tif ( !this.multiline ) {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\t\t\t\t\tvar chr = this.indentChar;\n\t\t\t\t\tif ( this.HTML ) {\n\t\t\t\t\t\tchr = chr.replace( /\\t/g, \"   \" ).replace( / /g, \"&nbsp;\" );\n\t\t\t\t\t}\n\t\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join(chr);\n\t\t\t\t},\n\t\t\t\tup: function( a ) {\n\t\t\t\t\tthis.depth += a || 1;\n\t\t\t\t},\n\t\t\t\tdown: function( a ) {\n\t\t\t\t\tthis.depth -= a || 1;\n\t\t\t\t},\n\t\t\t\tsetParser: function( name, parser ) {\n\t\t\t\t\tthis.parsers[name] = parser;\n\t\t\t\t},\n\t\t\t\t// The next 3 are exposed so you can use them\n\t\t\t\tquote: quote,\n\t\t\t\tliteral: literal,\n\t\t\t\tjoin: join,\n\t\t\t\t//\n\t\t\t\tdepth: 1,\n\t\t\t\t// This is the list of parsers, to modify them, use jsDump.setParser\n\t\t\t\tparsers: {\n\t\t\t\t\twindow: \"[Window]\",\n\t\t\t\t\tdocument: \"[Document]\",\n\t\t\t\t\terror: function(error) {\n\t\t\t\t\t\treturn \"Error(\\\"\" + error.message + \"\\\")\";\n\t\t\t\t\t},\n\t\t\t\t\tunknown: \"[Unknown]\",\n\t\t\t\t\t\"null\": \"null\",\n\t\t\t\t\t\"undefined\": \"undefined\",\n\t\t\t\t\t\"function\": function( fn ) {\n\t\t\t\t\t\tvar ret = \"function\",\n\t\t\t\t\t\t\t// functions never have name in IE\n\t\t\t\t\t\t\tname = \"name\" in fn ? fn.name : (reName.exec(fn) || [])[1];\n\t\n\t\t\t\t\t\tif ( name ) {\n\t\t\t\t\t\t\tret += \" \" + name;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret += \"( \";\n\t\n\t\t\t\t\t\tret = [ ret, QUnit.jsDump.parse( fn, \"functionArgs\" ), \"){\" ].join( \"\" );\n\t\t\t\t\t\treturn join( ret, QUnit.jsDump.parse(fn,\"functionCode\" ), \"}\" );\n\t\t\t\t\t},\n\t\t\t\t\tarray: array,\n\t\t\t\t\tnodelist: array,\n\t\t\t\t\t\"arguments\": array,\n\t\t\t\t\tobject: function( map, stack ) {\n\t\t\t\t\t\t/*jshint forin:false */\n\t\t\t\t\t\tvar ret = [ ], keys, key, val, i;\n\t\t\t\t\t\tQUnit.jsDump.up();\n\t\t\t\t\t\tkeys = [];\n\t\t\t\t\t\tfor ( key in map ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkeys.sort();\n\t\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\n\t\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\t\tval = map[ key ];\n\t\t\t\t\t\t\tret.push( QUnit.jsDump.parse( key, \"key\" ) + \": \" + QUnit.jsDump.parse( val, undefined, stack ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tQUnit.jsDump.down();\n\t\t\t\t\t\treturn join( \"{\", ret, \"}\" );\n\t\t\t\t\t},\n\t\t\t\t\tnode: function( node ) {\n\t\t\t\t\t\tvar len, i, val,\n\t\t\t\t\t\t\topen = QUnit.jsDump.HTML ? \"&lt;\" : \"<\",\n\t\t\t\t\t\t\tclose = QUnit.jsDump.HTML ? \"&gt;\" : \">\",\n\t\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\n\t\t\t\t\t\t\tret = open + tag,\n\t\t\t\t\t\t\tattrs = node.attributes;\n\t\n\t\t\t\t\t\tif ( attrs ) {\n\t\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {\n\t\t\t\t\t\t\t\tval = attrs[i].nodeValue;\n\t\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly set.\n\t\t\t\t\t\t\t\t// Those have values like undefined, null, 0, false, \"\" or \"inherit\".\n\t\t\t\t\t\t\t\tif ( val && val !== \"inherit\" ) {\n\t\t\t\t\t\t\t\t\tret += \" \" + attrs[i].nodeName + \"=\" + QUnit.jsDump.parse( val, \"attribute\" );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret += close;\n\t\n\t\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {\n\t\t\t\t\t\t\tret += node.nodeValue;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn ret + open + \"/\" + tag + close;\n\t\t\t\t\t},\n\t\t\t\t\t// function calls it internally, it's the arguments part of the function\n\t\t\t\t\tfunctionArgs: function( fn ) {\n\t\t\t\t\t\tvar args,\n\t\t\t\t\t\t\tl = fn.length;\n\t\n\t\t\t\t\t\tif ( !l ) {\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\targs = new Array(l);\n\t\t\t\t\t\twhile ( l-- ) {\n\t\t\t\t\t\t\t// 97 is 'a'\n\t\t\t\t\t\t\targs[l] = String.fromCharCode(97+l);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn \" \" + args.join( \", \" ) + \" \";\n\t\t\t\t\t},\n\t\t\t\t\t// object calls it internally, the key part of an item in a map\n\t\t\t\t\tkey: quote,\n\t\t\t\t\t// function calls it internally, it's the content of the function\n\t\t\t\t\tfunctionCode: \"[code]\",\n\t\t\t\t\t// node calls it internally, it's an html attribute value\n\t\t\t\t\tattribute: quote,\n\t\t\t\t\tstring: quote,\n\t\t\t\t\tdate: quote,\n\t\t\t\t\tregexp: literal,\n\t\t\t\t\tnumber: literal,\n\t\t\t\t\t\"boolean\": literal\n\t\t\t\t},\n\t\t\t\t// if true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\t\tHTML: false,\n\t\t\t\t// indentation unit\n\t\t\t\tindentChar: \"  \",\n\t\t\t\t// if true, items in a collection, are separated by a \\n, else just a space.\n\t\t\t\tmultiline: true\n\t\t\t};\n\t\n\t\treturn jsDump;\n\t}());\n\t\n\t/*\n\t * Javascript Diff Algorithm\n\t *  By John Resig (http://ejohn.org/)\n\t *  Modified by Chu Alan \"sprite\"\n\t *\n\t * Released under the MIT license.\n\t *\n\t * More Info:\n\t *  http://ejohn.org/projects/javascript-diff-algorithm/\n\t *\n\t * Usage: QUnit.diff(expected, actual)\n\t *\n\t * QUnit.diff( \"the quick brown fox jumped over\", \"the quick fox jumps over\" ) == \"the  quick <del>brown </del> fox <del>jumped </del><ins>jumps </ins> over\"\n\t */\n\tQUnit.diff = (function() {\n\t\t/*jshint eqeqeq:false, eqnull:true */\n\t\tfunction diff( o, n ) {\n\t\t\tvar i,\n\t\t\t\tns = {},\n\t\t\t\tos = {};\n\t\n\t\t\tfor ( i = 0; i < n.length; i++ ) {\n\t\t\t\tif ( !hasOwn.call( ns, n[i] ) ) {\n\t\t\t\t\tns[ n[i] ] = {\n\t\t\t\t\t\trows: [],\n\t\t\t\t\t\to: null\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tns[ n[i] ].rows.push( i );\n\t\t\t}\n\t\n\t\t\tfor ( i = 0; i < o.length; i++ ) {\n\t\t\t\tif ( !hasOwn.call( os, o[i] ) ) {\n\t\t\t\t\tos[ o[i] ] = {\n\t\t\t\t\t\trows: [],\n\t\t\t\t\t\tn: null\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tos[ o[i] ].rows.push( i );\n\t\t\t}\n\t\n\t\t\tfor ( i in ns ) {\n\t\t\t\tif ( hasOwn.call( ns, i ) ) {\n\t\t\t\t\tif ( ns[i].rows.length === 1 && hasOwn.call( os, i ) && os[i].rows.length === 1 ) {\n\t\t\t\t\t\tn[ ns[i].rows[0] ] = {\n\t\t\t\t\t\t\ttext: n[ ns[i].rows[0] ],\n\t\t\t\t\t\t\trow: os[i].rows[0]\n\t\t\t\t\t\t};\n\t\t\t\t\t\to[ os[i].rows[0] ] = {\n\t\t\t\t\t\t\ttext: o[ os[i].rows[0] ],\n\t\t\t\t\t\t\trow: ns[i].rows[0]\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfor ( i = 0; i < n.length - 1; i++ ) {\n\t\t\t\tif ( n[i].text != null && n[ i + 1 ].text == null && n[i].row + 1 < o.length && o[ n[i].row + 1 ].text == null &&\n\t\t\t\t\t\t\tn[ i + 1 ] == o[ n[i].row + 1 ] ) {\n\t\n\t\t\t\t\tn[ i + 1 ] = {\n\t\t\t\t\t\ttext: n[ i + 1 ],\n\t\t\t\t\t\trow: n[i].row + 1\n\t\t\t\t\t};\n\t\t\t\t\to[ n[i].row + 1 ] = {\n\t\t\t\t\t\ttext: o[ n[i].row + 1 ],\n\t\t\t\t\t\trow: i + 1\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfor ( i = n.length - 1; i > 0; i-- ) {\n\t\t\t\tif ( n[i].text != null && n[ i - 1 ].text == null && n[i].row > 0 && o[ n[i].row - 1 ].text == null &&\n\t\t\t\t\t\t\tn[ i - 1 ] == o[ n[i].row - 1 ]) {\n\t\n\t\t\t\t\tn[ i - 1 ] = {\n\t\t\t\t\t\ttext: n[ i - 1 ],\n\t\t\t\t\t\trow: n[i].row - 1\n\t\t\t\t\t};\n\t\t\t\t\to[ n[i].row - 1 ] = {\n\t\t\t\t\t\ttext: o[ n[i].row - 1 ],\n\t\t\t\t\t\trow: i - 1\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\to: o,\n\t\t\t\tn: n\n\t\t\t};\n\t\t}\n\t\n\t\treturn function( o, n ) {\n\t\t\to = o.replace( /\\s+$/, \"\" );\n\t\t\tn = n.replace( /\\s+$/, \"\" );\n\t\n\t\t\tvar i, pre,\n\t\t\t\tstr = \"\",\n\t\t\t\tout = diff( o === \"\" ? [] : o.split(/\\s+/), n === \"\" ? [] : n.split(/\\s+/) ),\n\t\t\t\toSpace = o.match(/\\s+/g),\n\t\t\t\tnSpace = n.match(/\\s+/g);\n\t\n\t\t\tif ( oSpace == null ) {\n\t\t\t\toSpace = [ \" \" ];\n\t\t\t}\n\t\t\telse {\n\t\t\t\toSpace.push( \" \" );\n\t\t\t}\n\t\n\t\t\tif ( nSpace == null ) {\n\t\t\t\tnSpace = [ \" \" ];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnSpace.push( \" \" );\n\t\t\t}\n\t\n\t\t\tif ( out.n.length === 0 ) {\n\t\t\t\tfor ( i = 0; i < out.o.length; i++ ) {\n\t\t\t\t\tstr += \"<del>\" + out.o[i] + oSpace[i] + \"</del>\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( out.n[0].text == null ) {\n\t\t\t\t\tfor ( n = 0; n < out.o.length && out.o[n].text == null; n++ ) {\n\t\t\t\t\t\tstr += \"<del>\" + out.o[n] + oSpace[n] + \"</del>\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tfor ( i = 0; i < out.n.length; i++ ) {\n\t\t\t\t\tif (out.n[i].text == null) {\n\t\t\t\t\t\tstr += \"<ins>\" + out.n[i] + nSpace[i] + \"</ins>\";\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// `pre` initialized at top of scope\n\t\t\t\t\t\tpre = \"\";\n\t\n\t\t\t\t\t\tfor ( n = out.n[i].row + 1; n < out.o.length && out.o[n].text == null; n++ ) {\n\t\t\t\t\t\t\tpre += \"<del>\" + out.o[n] + oSpace[n] + \"</del>\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstr += \" \" + out.n[i].text + nSpace[i] + pre;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn str;\n\t\t};\n\t}());\n\t\n\t// For browser, export only select globals\n\tif ( typeof window !== \"undefined\" ) {\n\t\textend( window, QUnit.constructor.prototype );\n\t\twindow.QUnit = QUnit;\n\t}\n\t\n\t// For CommonJS environments, export everything\n\tif ( typeof module !== \"undefined\" && module.exports ) {\n\t\tmodule.exports = QUnit;\n\t}\n\t\n\t\n\t// Get a reference to the global object, like window in browsers\n\t}( (function() {\n\t\treturn this;\n\t})() ));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n\t * QUnit-TAP - A TAP Output Producer Plugin for QUnit\n\t *\n\t * https://github.com/twada/qunit-tap\n\t * version: 1.5.0\n\t *\n\t * Copyright (c) 2010-2014 Takuto Wada\n\t * Dual licensed under the MIT and GPLv2 licenses.\n\t *   https://raw.github.com/twada/qunit-tap/master/MIT-LICENSE.txt\n\t *   https://raw.github.com/twada/qunit-tap/master/GPL-LICENSE.txt\n\t *\n\t * A part of extend function is:\n\t *   Copyright 2012 jQuery Foundation and other contributors\n\t *   Released under the MIT license.\n\t *   http://jquery.org/license\n\t */\n\t(function (root, factory) {\n\t    'use strict';\n\t\n\t    // using returnExports UMD pattern\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        module.exports = factory();\n\t    } else {\n\t        root.qunitTap = factory();\n\t    }\n\t}(this, function () {\n\t    'use strict';\n\t\n\t    var qunitTapVersion = '1.5.0',\n\t        slice = Array.prototype.slice;\n\t\n\t    // borrowed from qunit.js\n\t    function extend (a, b) {\n\t        var prop;\n\t        for (prop in b) {\n\t            if (b.hasOwnProperty(prop)) {\n\t                if (typeof b[prop] === 'undefined') {\n\t                    delete a[prop];\n\t                } else {\n\t                    a[prop] = b[prop];\n\t                }\n\t            }\n\t        }\n\t        return a;\n\t    }\n\t\n\t    function indexOf (ary, element) {\n\t        var i;\n\t        for (i = 0; i < ary.length; i += 1) {\n\t            if (ary[i] === element) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t\n\t    function removeElement (ary, element) {\n\t        var index = indexOf(ary, element);\n\t        if (index !== -1) {\n\t            return ary.splice(index, 1);\n\t        } else {\n\t            return [];\n\t        }\n\t    }\n\t\n\t    function isPlanRequired (conf) {\n\t        return (typeof conf !== 'undefined' && typeof conf.requireExpects !== 'undefined' && conf.requireExpects);\n\t    }\n\t\n\t    function isPassed (details) {\n\t        return !!(details.result);\n\t    }\n\t\n\t    function isFailed (details) {\n\t        return !(isPassed(details));\n\t    }\n\t\n\t    function isAssertOkFailed (details) {\n\t        return isFailed(details) && typeof details.expected === 'undefined' && typeof details.actual === 'undefined';\n\t    }\n\t\n\t    function escapeLineEndings (str) {\n\t        return str.replace(/(\\r?\\n)/g, '$&# ');\n\t    }\n\t\n\t    function ltrim (str) {\n\t        return str.replace(/^\\s+/, '');\n\t    }\n\t\n\t    function noop (obj) {\n\t        return obj;\n\t    }\n\t\n\t    function render (desc, fieldName, fieldValue, formatter) {\n\t        desc.push(fieldName + ': ' + formatter(fieldValue));\n\t    }\n\t\n\t    function renderIf (shouldRender, desc, fieldName, fieldValue, formatter) {\n\t        if (!shouldRender || typeof fieldValue === 'undefined') {\n\t            return;\n\t        }\n\t        render(desc, fieldName, fieldValue, formatter);\n\t    }\n\t\n\t    function formatTestLine (testLine, rest) {\n\t        if (!rest) {\n\t            return testLine;\n\t        }\n\t        return testLine + ' - ' + escapeLineEndings(rest);\n\t    }\n\t\n\t    var createCallbackAppenderFor = function (qu) {\n\t        return function (subject, observer, event) {\n\t            var originalLoggingCallback = subject[event],\n\t                callback = function () {\n\t                    // make listener methods (moduleStart,testStart,log, ...) overridable.\n\t                    observer[event].apply(observer, slice.apply(arguments));\n\t                };\n\t            originalLoggingCallback(callback);\n\t            return callback;\n\t        };\n\t    };\n\t\n\t\n\t    /**\n\t     * QUnit-TAP - A TAP Output Producer Plugin for QUnit\n\t     * @param qunitObject QUnit object reference.\n\t     * @param printLikeFunction print-like function for TAP output (assumes line-separator is added by this function for each call).\n\t     * @param options configuration options to customize default behavior.\n\t     * @return object to provide QUnit-TAP API and customization subject.\n\t     */\n\t    function qunitTap(qunitObject, printLikeFunction, options) {\n\t        if (!qunitObject) {\n\t            throw new Error('should pass QUnit object reference. Please check QUnit\\'s \"require\" path if you are using Node.js (or any CommonJS env).');\n\t        } else if (typeof printLikeFunction !== 'function') {\n\t            throw new Error('should pass print-like function');\n\t        }\n\t\n\t        var qu = qunitObject,\n\t            tap = {},\n\t            jsDumpExists = (typeof qu.jsDump !== 'undefined' && typeof qu.jsDump.parse === 'function'),\n\t            explain = (jsDumpExists ? function explain (obj) { return qu.jsDump.parse(obj); } : noop),\n\t            deprecateOption = function deprecateOption (optionName, fallback) {\n\t                // option deprecation and fallback function\n\t                if (!options || typeof options !== 'object') {\n\t                    return;\n\t                }\n\t                if (typeof options[optionName] === 'undefined') {\n\t                    return;\n\t                }\n\t                printLikeFunction('# WARNING: Option \"' + optionName + '\" is deprecated and will be removed in future version.');\n\t                fallback(options[optionName]);\n\t            },\n\t            targetEvents = [\n\t                'moduleStart',\n\t                'testStart',\n\t                'log',\n\t                'testDone',\n\t                'done'\n\t            ],\n\t            registeredCallbacks = {};\n\t\n\t\n\t        tap.config = extend(\n\t            {\n\t                initialCount: 1,\n\t                showModuleNameOnFailure: true,\n\t                showTestNameOnFailure: true,\n\t                showExpectationOnFailure: true,\n\t                showSourceOnFailure: true\n\t            },\n\t            options\n\t        );\n\t        deprecateOption('noPlan', function (flag) {\n\t            printLikeFunction('# Now QUnit-TAP works as with \"noPlan: true\" by default. If you want to delare plan explicitly, please use \"QUnit.config.requireExpects\" option instead.');\n\t            tap.config.noPlan = flag;\n\t        });\n\t        deprecateOption('count', function (count) {\n\t            tap.config.initialCount = (count + 1);\n\t        });\n\t        deprecateOption('showDetailsOnFailure', function (flag) {\n\t            tap.config.showModuleNameOnFailure = flag;\n\t            tap.config.showTestNameOnFailure = flag;\n\t            tap.config.showExpectationOnFailure = flag;\n\t            tap.config.showSourceOnFailure = flag;\n\t        });\n\t        tap.VERSION = qunitTapVersion;\n\t        tap.puts = printLikeFunction;\n\t        tap.count = tap.config.initialCount - 1;\n\t        tap.expectedCount = tap.config.initialCount - 1;\n\t\n\t        function isEnabled (configName) {\n\t            return tap.config[configName];\n\t        }\n\t\n\t        function formatDetails (details) {\n\t            if (isPassed(details)) {\n\t                return details.message;\n\t            }\n\t            var desc = [];\n\t            if (details.message) {\n\t                desc.push(details.message);\n\t            }\n\t            if (isEnabled('showExpectationOnFailure') && !(isAssertOkFailed(details))) {\n\t                render(desc, 'expected', details.expected, explain);\n\t                render(desc, 'got', details.actual, explain);\n\t            }\n\t            renderIf(isEnabled('showTestNameOnFailure'), desc, 'test', details.name, noop);\n\t            renderIf(isEnabled('showModuleNameOnFailure'), desc, 'module', details.module, noop);\n\t            renderIf(isEnabled('showSourceOnFailure'), desc, 'source', details.source, ltrim);\n\t            return desc.join(', ');\n\t        }\n\t\n\t        function printPlanLine (toCount) {\n\t            tap.puts(tap.config.initialCount + '..' + toCount);\n\t        }\n\t\n\t        function unsubscribeEvent (eventName) {\n\t            var listeners;\n\t            if (indexOf(targetEvents, eventName) === -1) {\n\t                return;\n\t            }\n\t            listeners = qu.config[eventName];\n\t            if (typeof listeners === 'undefined') {\n\t                return;\n\t            }\n\t            removeElement(listeners, registeredCallbacks[eventName]);\n\t        }\n\t\n\t        function unsubscribeEvents (eventNames) {\n\t            var i;\n\t            for (i = 0; i < eventNames.length; i += 1) {\n\t                unsubscribeEvent(eventNames[i]);\n\t            }\n\t        }\n\t\n\t        tap.explain = explain;\n\t\n\t        tap.note = function note (obj) {\n\t            tap.puts(escapeLineEndings('# ' + obj));\n\t        };\n\t\n\t        tap.diag = function diag (obj) {\n\t            tap.note(obj);\n\t            return false;\n\t        };\n\t\n\t        tap.moduleStart = function moduleStart (arg) {\n\t            var name = (typeof arg === 'string') ? arg : arg.name;\n\t            tap.note('module: ' + name);\n\t        };\n\t\n\t        tap.testStart = function testStart (arg) {\n\t            var name = (typeof arg === 'string') ? arg : arg.name;\n\t            tap.note('test: ' + name);\n\t        };\n\t\n\t        tap.log = function log (details) {\n\t            var testLine = '';\n\t            tap.count += 1;\n\t            if (isFailed(details)) {\n\t                testLine += 'not ';\n\t            }\n\t            testLine += ('ok ' + tap.count);\n\t            tap.puts(formatTestLine(testLine, formatDetails(details)));\n\t        };\n\t\n\t        tap.testDone = function testDone () {\n\t            if (isPlanRequired(qu.config)) {\n\t                tap.expectedCount += qu.config.current.expected;\n\t            }\n\t        };\n\t\n\t        tap.done = function done () {\n\t            if (typeof tap.config.noPlan !== 'undefined' && !(tap.config.noPlan)) {\n\t                // Do nothing until removal of 'noPlan' option.\n\t            } else if (isPlanRequired(qu.config)) {\n\t                printPlanLine(tap.expectedCount);\n\t            } else {\n\t                printPlanLine(tap.count);\n\t            }\n\t        };\n\t\n\t        tap.unsubscribe = function unsubscribe () {\n\t            if (typeof qu.config === 'undefined') {\n\t                return;\n\t            }\n\t            if (arguments.length === 0) {\n\t                unsubscribeEvents(targetEvents);\n\t            } else {\n\t                unsubscribeEvents(slice.apply(arguments));\n\t            }\n\t        };\n\t\n\t        (function () {\n\t            var appendCallback = createCallbackAppenderFor(qu),\n\t                eventName, i, callback;\n\t            for (i = 0; i < targetEvents.length; i += 1) {\n\t                eventName = targetEvents[i];\n\t                callback = appendCallback(qu, tap, eventName);\n\t                registeredCallbacks[eventName] = callback;\n\t            }\n\t        })();\n\t\n\t        return tap;\n\t    }\n\t\n\t    qunitTap.qunitTap = function () {\n\t        throw new Error('[BC BREAK] Since 1.4.0, QUnit-TAP exports single qunitTap function as module.exports. Therefore, require(\"qunit-tap\") returns qunitTap function itself. Please fix your code if you are using Node.js (or any CommonJS env).');\n\t    };\n\t\n\t    // using substack pattern (export single function)\n\t    return qunitTap;\n\t}));\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(module) {'use strict';\n\t\n\t/* global QUnit, qunitTap */\n\t\n\tvar qunit_started = false;\n\t\n\t/* Always use explicit start */\n\tQUnit.config.autostart = false;\n\t\n\t/*\n\t * HACK: phantomjs doesn't handle uncaught exceptions as it should if\n\t * window.onerror is non-null, even when that handler returns false\n\t * (expecting that the browser default behavior will occur).\n\t *\n\t * So remove the qunit window.onerror handler until the tests actually\n\t * start, and any errors become part of the test suite results.\n\t */\n\tvar qunit_onerror = window.onerror;\n\twindow.onerror = null;\n\tQUnit.begin(function() {\n\t    window.onerror = function(error, file, line) {\n\t        var ret = false;\n\t        if (qunit_onerror)\n\t            ret = qunit_onerror(error, file, line);\n\t\n\t        /*\n\t         * If a global exception happens during an async test\n\t         * then that test won't be able to call the start() function\n\t         * to move to the next test, so call it here.\n\t         */\n\t        if (QUnit.config.current && QUnit.config.current.async)\n\t            QUnit.start();\n\t\n\t        return ret;\n\t    };\n\t});\n\t\n\tQUnit.moduleStart(function() {\n\t    qunit_started = true;\n\t});\n\t\n\tQUnit.done(function() {\n\t    console.log(\"phantom-tap-done\");\n\t    window.onerror = null;\n\t});\n\t/*\n\t * Now initialize qunit-tap\n\t *\n\t * When not running under tap-phantom this stuff will just show up in\n\t * the console. We print out a special canary at the end of the tests\n\t * so that tap-phantom can know when the testing is done.\n\t *\n\t * In addition double check for a test file that doesn't properly call\n\t * QUnit.start() after its done setting up its tests.\n\t *\n\t * We also want to insert the current test name into all tap lines.\n\t */\n\tvar tap_regex = /^((not )?ok [0-9]+ (- )?)(.*)$/;\n\tqunitTap(QUnit, function() {\n\t    if (arguments.length == 1 && QUnit.config.current) {\n\t        var match = tap_regex.exec(arguments[0]);\n\t        if (match) {\n\t            console.log(match[1] + QUnit.config.current.testName + \": \" + match[4]);\n\t            return;\n\t        }\n\t    }\n\t    console.log.apply(console, arguments);\n\t});\n\t\n\twindow.setTimeout(function() {\n\t    if (!qunit_started) {\n\t        console.log(\"QUnit not started by test\");\n\t        console.log(\"phantom-tap-error\");\n\t    }\n\t}, 20000);\n\t\n\twindow.tests_included = true;\n\t\n\tif (module && module.exports)\n\t    module.exports = QUnit;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(27)(module)))\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\n\t\tif(!module.webpackPolyfill) {\n\t\t\tmodule.deprecate = function() {};\n\t\t\tmodule.paths = [];\n\t\t\t// module.parent = undefined by default\n\t\t\tmodule.children = [];\n\t\t\tmodule.webpackPolyfill = 1;\n\t\t}\n\t\treturn module;\n\t}\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// networkmanager/test-utils.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6a4a1d5384330b946f46","'use strict';\n\n/*\n * This file is part of Cockpit.\n *\n * Copyright (C) 2014 Red Hat, Inc.\n *\n * Cockpit is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * Cockpit is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n */\n\nvar utils = require(\"./utils\");\nvar cockpit = require(\"cockpit\");\nvar QUnit = require(\"qunit-tests\");\nvar assert = QUnit;\n\nfunction assert_throws(func, checks) {\n    assert.expect(checks.length);\n\n    checks.forEach(function(c) {\n        assert.throws(function() {\n            func(c);\n        });\n    });\n}\n\nQUnit.test(\"ip_prefix_from_text\", function() {\n    var checks = [\n        [ \"0\",      0 ],\n        [ \"12\",    12 ],\n        [ \" 12  \", 12 ]\n    ];\n\n    assert.expect(checks.length);\n\n    checks.forEach(function(c) {\n        assert.strictEqual(utils.ip_prefix_from_text(c[0]), c[1]);\n    });\n});\n\nQUnit.test(\"ip_prefix_from_text invalids\", function() {\n    var checks = [\n        \"\",\n        \"-1\",\n        \"foo\",\n        \"1foo\",\n        \"1.5\",\n        \"1 2 3\"\n    ];\n\n    assert_throws(utils.ip_prefix_from_text, checks);\n});\n\nQUnit.test(\"ip_metric_from_text\", function() {\n    var checks = [\n        [ \"\",       0 ],\n        [ \"0\",      0 ],\n        [ \"12\",    12 ],\n        [ \" 12  \", 12 ]\n    ];\n\n    assert.expect(checks.length);\n\n    checks.forEach(function(c) {\n        assert.strictEqual(utils.ip_metric_from_text(c[0]), c[1]);\n    });\n});\n\nQUnit.test(\"ip_metric_from_text invalids\", function() {\n    var checks = [\n        \"-1\",\n        \"foo\",\n        \"1foo\",\n        \"1.5\",\n        \"1 2 3\"\n    ];\n\n    assert_throws(utils.ip_metric_from_text, checks);\n});\n\nQUnit.test(\"ip4_to/from_text be\", function() {\n    var checks = [\n        [ \"0.0.0.0\",           0x00000000 ],\n        [ \"255.255.255.255\",   0xFFFFFFFF ],\n        [ \"1.2.3.4\",           0x01020304 ],\n        [ \" 1.2.3.4 \",         0x01020304 ],\n        [ \" 1 . 2 . 3. 4 \",    0x01020304 ]\n    ];\n\n    assert.expect(2*checks.length);\n\n    utils.set_byteorder(\"be\");\n    checks.forEach(function(c) {\n        assert.strictEqual(utils.ip4_to_text(c[1]), c[0].replace(/ /g, \"\"));\n        assert.strictEqual(utils.ip4_from_text(c[0]), c[1]);\n    });\n});\n\nQUnit.test(\"ip4_to/from_text le\", function() {\n    var checks = [\n        [ \"0.0.0.0\",           0x00000000 ],\n        [ \"255.255.255.255\",   0xFFFFFFFF ],\n        [ \"1.2.3.4\",           0x04030201 ],\n        [ \" 1.2.3.4 \",         0x04030201 ],\n        [ \" 1 . 2 . 3. 4 \",    0x04030201 ]\n    ];\n\n    assert.expect(2*checks.length);\n\n    utils.set_byteorder(\"le\");\n    checks.forEach(function(c) {\n        assert.strictEqual(utils.ip4_to_text(c[1]), c[0].replace(/ /g, \"\"));\n        assert.strictEqual(utils.ip4_from_text(c[0]), c[1]);\n    });\n});\n\nQUnit.test(\"ip4_from_text invalids\", function() {\n    var checks = [\n        \"\",\n        \"0\",\n        \"0.0\",\n        \"0.0.0\",\n        \"0.0.0.0.0\",\n        \"-1.2.3.4\",\n        \"foo\",\n        \"1.foo.3.4\",\n        \"1foo.2.3.4\",\n        \"1.2.3.400\",\n        \"1,2,3,4\",\n        \"1 1.2.3 3.4\"\n    ];\n\n    assert_throws(utils.ip4_from_text, checks);\n});\n\nQUnit.test(\"ip4_to_text zero\", function() {\n    utils.set_byteorder(\"be\");\n    assert.strictEqual(utils.ip4_to_text(0, true), \"\");\n});\n\nQUnit.test(\"ip4_from_text empty\", function() {\n    utils.set_byteorder(\"be\");\n    assert.strictEqual(utils.ip4_from_text(\"\", true), 0);\n});\n\nQUnit.test(\"ip4_prefix_from_text\", function() {\n    var checks = [\n        \"0.0.0.0\",\n\n        \" 128.0.0.0\",\n        \"192.0.0.0 \",\n        \"224. 0. 0.0\",\n        \"240. 0.0 .0\",\n        \"248.0.0.0\",\n        \"252. 0.0.0\",\n        \"254.0.0.0\",\n        \"255.0.0.0\",\n\n        \"255.128.0.0\",\n        \"255.192.0.0\",\n        \"255.224.0.0\",\n        \"255.240.0.0\",\n        \"255.248.0.0\",\n        \"255.252.0.0\",\n        \"255.254.0.0\",\n        \"255.255.0.0\",\n\n        \"255.255.128.0\",\n        \"255.255.192.0\",\n        \"255.255.224.0\",\n        \"255.255.240.0\",\n        \"255.255.248.0\",\n        \"255.255.252.0\",\n        \"255.255.254.0\",\n        \"255.255.255.0\",\n\n        \"255.255.255.128\",\n        \"255.255.255.192\",\n        \"255.255.255.224\",\n        \"255.255.255.240\",\n        \"255.255.255.248\",\n        \"255.255.255.252\",\n        \"255.255.255.254\",\n        \"255.255.255.255\"\n    ];\n\n    assert.expect(checks.length);\n\n    checks.forEach(function(c, i) {\n        assert.strictEqual(utils.ip4_prefix_from_text(c), i);\n    });\n});\n\nQUnit.test(\"ip4_prefix_from_text invalids\", function() {\n    var checks = [\n        \"\",\n        \"-1\",\n        \"foo\",\n        \"1foo\",\n        \"1.5\",\n\n        \"0.0\",\n        \"0.0.0\",\n        \"0.0.0.0.0\",\n        \"1.2.3.4\",\n        \"255.255.255.8\",\n        \"255.192.0.10\"\n    ];\n\n    assert_throws(utils.ip4_prefix_from_text, checks);\n});\n\nQUnit.test(\"ip6_to/from_text\", function() {\n    var checks = [\n        [ [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ],\n          \"0:0:0:0:0:0:0:0\"\n        ],\n        [ [ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F ],\n          \"1:203:405:607:809:a0b:c0d:e0f\"\n        ],\n        [ [ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F ],\n          \" 1: 203 :  405: 607: 809:a0b :c0d:e0f\"\n        ],\n    ];\n\n    assert.expect(2*checks.length);\n\n    checks.forEach(function(c) {\n        assert.strictEqual(utils.ip6_to_text(cockpit.base64_encode(c[0])), c[1].replace(/ /g, \"\"));\n        assert.deepEqual(cockpit.base64_decode(utils.ip6_from_text(c[1])), c[0]);\n    });\n});\n\nQUnit.test(\"ip6_from_text abbrevs\", function() {\n    var checks = [\n        [ \"::\",\n          [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ],\n        ],\n        [ \"::1\",\n          [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 ],\n        ],\n        [ \"1::\",\n          [ 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ],\n        ],\n        [ \"1:2:3::2:1\",\n          [ 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01 ],\n        ],\n        [ \"2001::1\",\n          [ 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 ],\n        ],\n    ];\n\n    checks.forEach(function(c) {\n        assert.deepEqual(cockpit.base64_decode(utils.ip6_from_text(c[0])), c[1]);\n    });\n});\n\nQUnit.test(\"ip6_from_text invalids\", function() {\n    var checks = [\n        \"\",\n        \"0\",\n        \"0:0\",\n        \"0:0:0\",\n        \"0:0:0:0\",\n        \"0:0:0:0:0\",\n        \"0:0:0:0:0:0\",\n        \"0:0:0:0:0:0:0\",\n        \"0:0:0:0:0:0:0:0:0\",\n        \"foo\",\n        \"1:2:3:four:5:6:7:8\",\n        \"1:2:3:-4:5:6:7:8\",\n        \"1:2:3:4.0:5:6:7:8\",\n        \"1:2:3:4foo:5:6:7:8\",\n        \"1:2:3:10000:5:6:7:8\",\n        \"1::4::8\",\n        \"::8::\",\n        \"1:2:3:4 4:5:6:7:8\",\n    ];\n\n    assert_throws(utils.ip6_from_text, checks);\n});\n\nQUnit.test(\"ip6_to_text zero\", function() {\n    var zero = [ 0, 0, 0, 0, 0, 0, 0, 0,\n                 0, 0, 0, 0, 0, 0, 0, 0\n               ];\n    assert.strictEqual(utils.ip6_to_text(cockpit.base64_encode(zero), true), \"\");\n});\n\nQUnit.test(\"ip6_from_text empty\", function() {\n    var zero = [ 0, 0, 0, 0, 0, 0, 0, 0,\n                 0, 0, 0, 0, 0, 0, 0, 0\n               ];\n    assert.deepEqual(cockpit.base64_decode(utils.ip6_from_text(\"\", true)), zero);\n});\n\nQUnit.start();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../pkg/networkmanager/test-utils.js\n// module id = 0\n// module chunks = 1","module.exports = cockpit;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"cockpit\"\n// module id = 3\n// module chunks = 0 1","'use strict';\n\n/*\n * This file is part of Cockpit.\n *\n * Copyright (C) 2016 Red Hat, Inc.\n *\n * Cockpit is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * Cockpit is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n */\n\n(function() {\n    \"use strict\";\n\n    var cockpit = require(\"cockpit\");\n\n    var _ = cockpit.gettext;\n\n    /* NetworkManager specific data conversions and utility functions.\n     */\n\n    var byteorder;\n\n    function set_byteorder(bo) {\n        byteorder = bo;\n    }\n\n    function ip_prefix_to_text(num) {\n        return num.toString();\n    }\n\n    function ip_prefix_from_text(text) {\n        if (/^[0-9]+$/.test(text.trim()))\n            return parseInt(text, 10);\n\n        throw cockpit.format(_(\"Invalid prefix $0\"), text);\n    }\n\n    function ip_metric_to_text(num) {\n        return num.toString();\n    }\n\n    function ip_metric_from_text(text) {\n        if (text === \"\")\n            return 0;\n\n        if (/^[0-9]+$/.test(text.trim()))\n            return parseInt(text, 10);\n\n        throw cockpit.format(_(\"Invalid metric $0\"), text);\n    }\n\n    function toDec(n) {\n        return n.toString(10);\n    }\n\n    function bytes_from_nm32(num) {\n        var bytes = [], i;\n        if (byteorder == \"be\") {\n            for (i = 3; i >= 0; i--) {\n                bytes[i] = num & 0xFF;\n                num = num >>> 8;\n            }\n        } else {\n            for (i = 0; i < 4; i++) {\n                bytes[i] = num & 0xFF;\n                num = num >>> 8;\n            }\n        }\n        return bytes;\n    }\n\n    function ip4_to_text(num, zero_is_empty) {\n        if (num === 0 && zero_is_empty)\n            return \"\";\n        return bytes_from_nm32(num).map(toDec).join('.');\n    }\n\n    function ip4_from_text(text, empty_is_zero) {\n        function invalid() {\n            throw cockpit.format(_(\"Invalid address $0\"), text);\n        }\n\n        if (text === \"\" && empty_is_zero)\n            return 0;\n\n        var parts = text.split('.');\n        if (parts.length != 4)\n            invalid();\n\n        var bytes = parts.map(function(s) {\n            if (/^[0-9]+$/.test(s.trim()))\n                return parseInt(s, 10);\n            else\n                invalid();\n        });\n\n        var num = 0;\n        function shift(b) {\n            if (isNaN(b) || b < 0 || b > 0xFF)\n                invalid();\n            num = 0x100*num + b;\n        }\n\n        var i;\n        if (byteorder == \"be\") {\n            for (i = 0; i < 4; i++) {\n                shift(bytes[i]);\n            }\n        } else {\n            for (i = 3; i >= 0; i--) {\n                shift(bytes[i]);\n            }\n        }\n\n        return num;\n    }\n\n    var text_to_prefix_bits = {\n        \"255\": 8, \"254\": 7, \"252\": 6, \"248\": 5, \"240\": 4, \"224\": 3, \"192\": 2, \"128\": 1, \"0\": 0\n    };\n\n    function ip4_prefix_from_text(text) {\n        function invalid() {\n            throw cockpit.format(_(\"Invalid prefix or netmask $0\"), text);\n        }\n\n        if (/^[0-9]+$/.test(text.trim()))\n            return parseInt(text, 10);\n        var parts = text.split('.');\n        if (parts.length != 4)\n            invalid();\n        var prefix = 0;\n        var i;\n        for (i = 0; i < 4; i++) {\n            var p = text_to_prefix_bits[parts[i].trim()];\n            if (p !== undefined) {\n                prefix += p;\n                if (p < 8)\n                    break;\n            } else\n                invalid();\n        }\n        for (i += 1; i < 4; i++) {\n            if (/^0+$/.test(parts[i].trim()) === false)\n                invalid();\n        }\n        return prefix;\n    }\n\n    function ip6_to_text(data, zero_is_empty) {\n        var parts = [];\n        var bytes = cockpit.base64_decode(data);\n        for (var i = 0; i < 8; i++)\n            parts[i] = ((bytes[2*i] << 8) + bytes[2*i+1]).toString(16);\n        var result = parts.join(':');\n        if (result == \"0:0:0:0:0:0:0:0\" && zero_is_empty)\n            return \"\";\n        return result;\n    }\n\n    function ip6_from_text(text, empty_is_zero) {\n        function invalid() {\n            throw cockpit.format(_(\"Invalid address $0\"), text);\n        }\n\n        if (text === \"\" && empty_is_zero)\n            return cockpit.base64_encode([ 0, 0, 0, 0, 0, 0, 0, 0,\n                                           0, 0, 0, 0, 0, 0, 0, 0,\n                                         ]);\n\n        var parts = text.split(':');\n        if (parts.length < 1 || parts.length > 8)\n            invalid();\n\n        if (parts[0] === \"\")\n            parts[0] = \"0\";\n        if (parts[parts.length-1] === \"\")\n            parts[parts.length-1] = \"0\";\n\n        var bytes = [], n, i, j;\n        var empty_seen = false;\n        for (i = 0, j = 0; i < parts.length; i++, j++) {\n            if (parts[i] === \"\") {\n                if (empty_seen)\n                    invalid();\n                empty_seen = true;\n                while (j < i + (8 - parts.length)) {\n                    bytes[2*j] = bytes[2*j+1] = 0;\n                    j++;\n                }\n            } else {\n                if (!/^[0-9a-fA-F]+$/.test(parts[i].trim()))\n                    invalid();\n                n = parseInt(parts[i], 16);\n                if (isNaN(n) || n < 0 || n > 0xFFFF)\n                    invalid();\n                bytes[2*j] = n >> 8;\n                bytes[2*j+1] = n & 0xFF;\n            }\n        }\n        if (j != 8)\n            invalid();\n\n        return cockpit.base64_encode(bytes);\n    }\n\n    module.exports = {\n        set_byteorder: set_byteorder,\n\n        ip_prefix_to_text: ip_prefix_to_text,\n        ip_prefix_from_text: ip_prefix_from_text,\n        ip_metric_to_text: ip_metric_to_text,\n        ip_metric_from_text: ip_metric_from_text,\n\n        ip4_to_text: ip4_to_text,\n        ip4_from_text: ip4_from_text,\n        ip4_prefix_from_text: ip4_prefix_from_text,\n\n        ip6_to_text: ip6_to_text,\n        ip6_from_text: ip6_from_text\n    };\n\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../pkg/networkmanager/utils.js\n// module id = 4\n// module chunks = 0 1","'use strict';\n\n/*\n * This file is part of Cockpit.\n *\n * Copyright (C) 2014 Red Hat, Inc.\n *\n * Cockpit is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * Cockpit is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n */\n\n(function() {\n    \"use strict\";\n\n    /* QUnit needs to have 'window' as 'this' in order to load */\n    window.QUnit = require(\"qunit/qunit/qunit.js\");\n    window.qunitTap = require(\"qunit-tap/lib/qunit-tap.js\");\n\n    require(\"./qunit-config.js\");\n\n    require(\"qunit/qunit/qunit.css\");\n\n    module.exports = window.QUnit;\n\n}());\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../pkg/lib/qunit-tests.js\n// module id = 22\n// module chunks = 1","/*!\n * QUnit 1.14.0\n * http://qunitjs.com/\n *\n * Copyright 2013 jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-01-31T16:40Z\n */\n\n(function( window ) {\n\nvar QUnit,\n\tassert,\n\tconfig,\n\tonErrorFnPrev,\n\ttestId = 0,\n\tfileName = (sourceFromStacktrace( 0 ) || \"\" ).replace(/(:\\d+)+\\)?/, \"\").replace(/.+\\//, \"\"),\n\ttoString = Object.prototype.toString,\n\thasOwn = Object.prototype.hasOwnProperty,\n\t// Keep a local reference to Date (GH-283)\n\tDate = window.Date,\n\tsetTimeout = window.setTimeout,\n\tclearTimeout = window.clearTimeout,\n\tdefined = {\n\t\tdocument: typeof window.document !== \"undefined\",\n\t\tsetTimeout: typeof window.setTimeout !== \"undefined\",\n\t\tsessionStorage: (function() {\n\t\t\tvar x = \"qunit-test-string\";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\treturn true;\n\t\t\t} catch( e ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}())\n\t},\n\t/**\n\t * Provides a normalized error string, correcting an issue\n\t * with IE 7 (and prior) where Error.prototype.toString is\n\t * not properly implemented\n\t *\n\t * Based on http://es5.github.com/#x15.11.4.4\n\t *\n\t * @param {String|Error} error\n\t * @return {String} error message\n\t */\n\terrorString = function( error ) {\n\t\tvar name, message,\n\t\t\terrorString = error.toString();\n\t\tif ( errorString.substring( 0, 7 ) === \"[object\" ) {\n\t\t\tname = error.name ? error.name.toString() : \"Error\";\n\t\t\tmessage = error.message ? error.message.toString() : \"\";\n\t\t\tif ( name && message ) {\n\t\t\t\treturn name + \": \" + message;\n\t\t\t} else if ( name ) {\n\t\t\t\treturn name;\n\t\t\t} else if ( message ) {\n\t\t\t\treturn message;\n\t\t\t} else {\n\t\t\t\treturn \"Error\";\n\t\t\t}\n\t\t} else {\n\t\t\treturn errorString;\n\t\t}\n\t},\n\t/**\n\t * Makes a clone of an object using only Array or Object as base,\n\t * and copies over the own enumerable properties.\n\t *\n\t * @param {Object} obj\n\t * @return {Object} New object with only the own properties (recursively).\n\t */\n\tobjectValues = function( obj ) {\n\t\t// Grunt 0.3.x uses an older version of jshint that still has jshint/jshint#392.\n\t\t/*jshint newcap: false */\n\t\tvar key, val,\n\t\t\tvals = QUnit.is( \"array\", obj ) ? [] : {};\n\t\tfor ( key in obj ) {\n\t\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\t\tval = obj[key];\n\t\t\t\tvals[key] = val === Object(val) ? objectValues(val) : val;\n\t\t\t}\n\t\t}\n\t\treturn vals;\n\t};\n\n\n// Root QUnit object.\n// `QUnit` initialized at top of scope\nQUnit = {\n\n\t// call on start of module test to prepend name to all tests\n\tmodule: function( name, testEnvironment ) {\n\t\tconfig.currentModule = name;\n\t\tconfig.currentModuleTestEnvironment = testEnvironment;\n\t\tconfig.modules[name] = true;\n\t},\n\n\tasyncTest: function( testName, expected, callback ) {\n\t\tif ( arguments.length === 2 ) {\n\t\t\tcallback = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tQUnit.test( testName, expected, callback, true );\n\t},\n\n\ttest: function( testName, expected, callback, async ) {\n\t\tvar test,\n\t\t\tnameHtml = \"<span class='test-name'>\" + escapeText( testName ) + \"</span>\";\n\n\t\tif ( arguments.length === 2 ) {\n\t\t\tcallback = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tif ( config.currentModule ) {\n\t\t\tnameHtml = \"<span class='module-name'>\" + escapeText( config.currentModule ) + \"</span>: \" + nameHtml;\n\t\t}\n\n\t\ttest = new Test({\n\t\t\tnameHtml: nameHtml,\n\t\t\ttestName: testName,\n\t\t\texpected: expected,\n\t\t\tasync: async,\n\t\t\tcallback: callback,\n\t\t\tmodule: config.currentModule,\n\t\t\tmoduleTestEnvironment: config.currentModuleTestEnvironment,\n\t\t\tstack: sourceFromStacktrace( 2 )\n\t\t});\n\n\t\tif ( !validTest( test ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\ttest.queue();\n\t},\n\n\t// Specify the number of expected assertions to guarantee that failed test (no assertions are run at all) don't slip through.\n\texpect: function( asserts ) {\n\t\tif (arguments.length === 1) {\n\t\t\tconfig.current.expected = asserts;\n\t\t} else {\n\t\t\treturn config.current.expected;\n\t\t}\n\t},\n\n\tstart: function( count ) {\n\t\t// QUnit hasn't been initialized yet.\n\t\t// Note: RequireJS (et al) may delay onLoad\n\t\tif ( config.semaphore === undefined ) {\n\t\t\tQUnit.begin(function() {\n\t\t\t\t// This is triggered at the top of QUnit.load, push start() to the event loop, to allow QUnit.load to finish first\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tQUnit.start( count );\n\t\t\t\t});\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tconfig.semaphore -= count || 1;\n\t\t// don't start until equal number of stop-calls\n\t\tif ( config.semaphore > 0 ) {\n\t\t\treturn;\n\t\t}\n\t\t// ignore if start is called more often then stop\n\t\tif ( config.semaphore < 0 ) {\n\t\t\tconfig.semaphore = 0;\n\t\t\tQUnit.pushFailure( \"Called start() while already started (QUnit.config.semaphore was 0 already)\", null, sourceFromStacktrace(2) );\n\t\t\treturn;\n\t\t}\n\t\t// A slight delay, to avoid any current callbacks\n\t\tif ( defined.setTimeout ) {\n\t\t\tsetTimeout(function() {\n\t\t\t\tif ( config.semaphore > 0 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( config.timeout ) {\n\t\t\t\t\tclearTimeout( config.timeout );\n\t\t\t\t}\n\n\t\t\t\tconfig.blocking = false;\n\t\t\t\tprocess( true );\n\t\t\t}, 13);\n\t\t} else {\n\t\t\tconfig.blocking = false;\n\t\t\tprocess( true );\n\t\t}\n\t},\n\n\tstop: function( count ) {\n\t\tconfig.semaphore += count || 1;\n\t\tconfig.blocking = true;\n\n\t\tif ( config.testTimeout && defined.setTimeout ) {\n\t\t\tclearTimeout( config.timeout );\n\t\t\tconfig.timeout = setTimeout(function() {\n\t\t\t\tQUnit.ok( false, \"Test timed out\" );\n\t\t\t\tconfig.semaphore = 1;\n\t\t\t\tQUnit.start();\n\t\t\t}, config.testTimeout );\n\t\t}\n\t}\n};\n\n// We use the prototype to distinguish between properties that should\n// be exposed as globals (and in exports) and those that shouldn't\n(function() {\n\tfunction F() {}\n\tF.prototype = QUnit;\n\tQUnit = new F();\n\t// Make F QUnit's constructor so that we can add to the prototype later\n\tQUnit.constructor = F;\n}());\n\n/**\n * Config object: Maintain internal state\n * Later exposed as QUnit.config\n * `config` initialized at top of scope\n */\nconfig = {\n\t// The queue of tests to run\n\tqueue: [],\n\n\t// block until document ready\n\tblocking: true,\n\n\t// when enabled, show only failing tests\n\t// gets persisted through sessionStorage and can be changed in UI via checkbox\n\thidepassed: false,\n\n\t// by default, run previously failed tests first\n\t// very useful in combination with \"Hide passed tests\" checked\n\treorder: true,\n\n\t// by default, modify document.title when suite is done\n\taltertitle: true,\n\n\t// by default, scroll to top of the page when suite is done\n\tscrolltop: true,\n\n\t// when enabled, all tests must call expect()\n\trequireExpects: false,\n\n\t// add checkboxes that are persisted in the query-string\n\t// when enabled, the id is set to `true` as a `QUnit.config` property\n\turlConfig: [\n\t\t{\n\t\t\tid: \"noglobals\",\n\t\t\tlabel: \"Check for Globals\",\n\t\t\ttooltip: \"Enabling this will test if any test introduces new properties on the `window` object. Stored as query-strings.\"\n\t\t},\n\t\t{\n\t\t\tid: \"notrycatch\",\n\t\t\tlabel: \"No try-catch\",\n\t\t\ttooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging exceptions in IE reasonable. Stored as query-strings.\"\n\t\t}\n\t],\n\n\t// Set of all modules.\n\tmodules: {},\n\n\t// logging callback queues\n\tbegin: [],\n\tdone: [],\n\tlog: [],\n\ttestStart: [],\n\ttestDone: [],\n\tmoduleStart: [],\n\tmoduleDone: []\n};\n\n// Initialize more QUnit.config and QUnit.urlParams\n(function() {\n\tvar i, current,\n\t\tlocation = window.location || { search: \"\", protocol: \"file:\" },\n\t\tparams = location.search.slice( 1 ).split( \"&\" ),\n\t\tlength = params.length,\n\t\turlParams = {};\n\n\tif ( params[ 0 ] ) {\n\t\tfor ( i = 0; i < length; i++ ) {\n\t\t\tcurrent = params[ i ].split( \"=\" );\n\t\t\tcurrent[ 0 ] = decodeURIComponent( current[ 0 ] );\n\n\t\t\t// allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\tcurrent[ 1 ] = current[ 1 ] ? decodeURIComponent( current[ 1 ] ) : true;\n\t\t\tif ( urlParams[ current[ 0 ] ] ) {\n\t\t\t\turlParams[ current[ 0 ] ] = [].concat( urlParams[ current[ 0 ] ], current[ 1 ] );\n\t\t\t} else {\n\t\t\t\turlParams[ current[ 0 ] ] = current[ 1 ];\n\t\t\t}\n\t\t}\n\t}\n\n\tQUnit.urlParams = urlParams;\n\n\t// String search anywhere in moduleName+testName\n\tconfig.filter = urlParams.filter;\n\n\t// Exact match of the module name\n\tconfig.module = urlParams.module;\n\n\tconfig.testNumber = [];\n\tif ( urlParams.testNumber ) {\n\n\t\t// Ensure that urlParams.testNumber is an array\n\t\turlParams.testNumber = [].concat( urlParams.testNumber );\n\t\tfor ( i = 0; i < urlParams.testNumber.length; i++ ) {\n\t\t\tcurrent = urlParams.testNumber[ i ];\n\t\t\tconfig.testNumber.push( parseInt( current, 10 ) );\n\t\t}\n\t}\n\n\t// Figure out if we're running the tests from a server or not\n\tQUnit.isLocal = location.protocol === \"file:\";\n}());\n\nextend( QUnit, {\n\n\tconfig: config,\n\n\t// Initialize the configuration options\n\tinit: function() {\n\t\textend( config, {\n\t\t\tstats: { all: 0, bad: 0 },\n\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\tstarted: +new Date(),\n\t\t\tupdateRate: 1000,\n\t\t\tblocking: false,\n\t\t\tautostart: true,\n\t\t\tautorun: false,\n\t\t\tfilter: \"\",\n\t\t\tqueue: [],\n\t\t\tsemaphore: 1\n\t\t});\n\n\t\tvar tests, banner, result,\n\t\t\tqunit = id( \"qunit\" );\n\n\t\tif ( qunit ) {\n\t\t\tqunit.innerHTML =\n\t\t\t\t\"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +\n\t\t\t\t\"<h2 id='qunit-banner'></h2>\" +\n\t\t\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +\n\t\t\t\t\"<h2 id='qunit-userAgent'></h2>\" +\n\t\t\t\t\"<ol id='qunit-tests'></ol>\";\n\t\t}\n\n\t\ttests = id( \"qunit-tests\" );\n\t\tbanner = id( \"qunit-banner\" );\n\t\tresult = id( \"qunit-testresult\" );\n\n\t\tif ( tests ) {\n\t\t\ttests.innerHTML = \"\";\n\t\t}\n\n\t\tif ( banner ) {\n\t\t\tbanner.className = \"\";\n\t\t}\n\n\t\tif ( result ) {\n\t\t\tresult.parentNode.removeChild( result );\n\t\t}\n\n\t\tif ( tests ) {\n\t\t\tresult = document.createElement( \"p\" );\n\t\t\tresult.id = \"qunit-testresult\";\n\t\t\tresult.className = \"result\";\n\t\t\ttests.parentNode.insertBefore( result, tests );\n\t\t\tresult.innerHTML = \"Running...<br/>&nbsp;\";\n\t\t}\n\t},\n\n\t// Resets the test setup. Useful for tests that modify the DOM.\n\t/*\n\tDEPRECATED: Use multiple tests instead of resetting inside a test.\n\tUse testStart or testDone for custom cleanup.\n\tThis method will throw an error in 2.0, and will be removed in 2.1\n\t*/\n\treset: function() {\n\t\tvar fixture = id( \"qunit-fixture\" );\n\t\tif ( fixture ) {\n\t\t\tfixture.innerHTML = config.fixture;\n\t\t}\n\t},\n\n\t// Safe object type checking\n\tis: function( type, obj ) {\n\t\treturn QUnit.objectType( obj ) === type;\n\t},\n\n\tobjectType: function( obj ) {\n\t\tif ( typeof obj === \"undefined\" ) {\n\t\t\treturn \"undefined\";\n\t\t}\n\n\t\t// Consider: typeof null === object\n\t\tif ( obj === null ) {\n\t\t\treturn \"null\";\n\t\t}\n\n\t\tvar match = toString.call( obj ).match(/^\\[object\\s(.*)\\]$/),\n\t\t\ttype = match && match[1] || \"\";\n\n\t\tswitch ( type ) {\n\t\t\tcase \"Number\":\n\t\t\t\tif ( isNaN(obj) ) {\n\t\t\t\t\treturn \"nan\";\n\t\t\t\t}\n\t\t\t\treturn \"number\";\n\t\t\tcase \"String\":\n\t\t\tcase \"Boolean\":\n\t\t\tcase \"Array\":\n\t\t\tcase \"Date\":\n\t\t\tcase \"RegExp\":\n\t\t\tcase \"Function\":\n\t\t\t\treturn type.toLowerCase();\n\t\t}\n\t\tif ( typeof obj === \"object\" ) {\n\t\t\treturn \"object\";\n\t\t}\n\t\treturn undefined;\n\t},\n\n\tpush: function( result, actual, expected, message ) {\n\t\tif ( !config.current ) {\n\t\t\tthrow new Error( \"assertion outside test context, was \" + sourceFromStacktrace() );\n\t\t}\n\n\t\tvar output, source,\n\t\t\tdetails = {\n\t\t\t\tmodule: config.current.module,\n\t\t\t\tname: config.current.testName,\n\t\t\t\tresult: result,\n\t\t\t\tmessage: message,\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected\n\t\t\t};\n\n\t\tmessage = escapeText( message ) || ( result ? \"okay\" : \"failed\" );\n\t\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\n\t\toutput = message;\n\n\t\tif ( !result ) {\n\t\t\texpected = escapeText( QUnit.jsDump.parse(expected) );\n\t\t\tactual = escapeText( QUnit.jsDump.parse(actual) );\n\t\t\toutput += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" + expected + \"</pre></td></tr>\";\n\n\t\t\tif ( actual !== expected ) {\n\t\t\t\toutput += \"<tr class='test-actual'><th>Result: </th><td><pre>\" + actual + \"</pre></td></tr>\";\n\t\t\t\toutput += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" + QUnit.diff( expected, actual ) + \"</pre></td></tr>\";\n\t\t\t}\n\n\t\t\tsource = sourceFromStacktrace();\n\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t\toutput += \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText( source ) + \"</pre></td></tr>\";\n\t\t\t}\n\n\t\t\toutput += \"</table>\";\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", QUnit, details );\n\n\t\tconfig.current.assertions.push({\n\t\t\tresult: !!result,\n\t\t\tmessage: output\n\t\t});\n\t},\n\n\tpushFailure: function( message, source, actual ) {\n\t\tif ( !config.current ) {\n\t\t\tthrow new Error( \"pushFailure() assertion outside test context, was \" + sourceFromStacktrace(2) );\n\t\t}\n\n\t\tvar output,\n\t\t\tdetails = {\n\t\t\t\tmodule: config.current.module,\n\t\t\t\tname: config.current.testName,\n\t\t\t\tresult: false,\n\t\t\t\tmessage: message\n\t\t\t};\n\n\t\tmessage = escapeText( message ) || \"error\";\n\t\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\n\t\toutput = message;\n\n\t\toutput += \"<table>\";\n\n\t\tif ( actual ) {\n\t\t\toutput += \"<tr class='test-actual'><th>Result: </th><td><pre>\" + escapeText( actual ) + \"</pre></td></tr>\";\n\t\t}\n\n\t\tif ( source ) {\n\t\t\tdetails.source = source;\n\t\t\toutput += \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText( source ) + \"</pre></td></tr>\";\n\t\t}\n\n\t\toutput += \"</table>\";\n\n\t\trunLoggingCallbacks( \"log\", QUnit, details );\n\n\t\tconfig.current.assertions.push({\n\t\t\tresult: false,\n\t\t\tmessage: output\n\t\t});\n\t},\n\n\turl: function( params ) {\n\t\tparams = extend( extend( {}, QUnit.urlParams ), params );\n\t\tvar key,\n\t\t\tquerystring = \"?\";\n\n\t\tfor ( key in params ) {\n\t\t\tif ( hasOwn.call( params, key ) ) {\n\t\t\t\tquerystring += encodeURIComponent( key ) + \"=\" +\n\t\t\t\t\tencodeURIComponent( params[ key ] ) + \"&\";\n\t\t\t}\n\t\t}\n\t\treturn window.location.protocol + \"//\" + window.location.host +\n\t\t\twindow.location.pathname + querystring.slice( 0, -1 );\n\t},\n\n\textend: extend,\n\tid: id,\n\taddEvent: addEvent,\n\taddClass: addClass,\n\thasClass: hasClass,\n\tremoveClass: removeClass\n\t// load, equiv, jsDump, diff: Attached later\n});\n\n/**\n * @deprecated: Created for backwards compatibility with test runner that set the hook function\n * into QUnit.{hook}, instead of invoking it and passing the hook function.\n * QUnit.constructor is set to the empty F() above so that we can add to it's prototype here.\n * Doing this allows us to tell if the following methods have been overwritten on the actual\n * QUnit object.\n */\nextend( QUnit.constructor.prototype, {\n\n\t// Logging callbacks; all receive a single argument with the listed properties\n\t// run test/logs.html for any related changes\n\tbegin: registerLoggingCallback( \"begin\" ),\n\n\t// done: { failed, passed, total, runtime }\n\tdone: registerLoggingCallback( \"done\" ),\n\n\t// log: { result, actual, expected, message }\n\tlog: registerLoggingCallback( \"log\" ),\n\n\t// testStart: { name }\n\ttestStart: registerLoggingCallback( \"testStart\" ),\n\n\t// testDone: { name, failed, passed, total, runtime }\n\ttestDone: registerLoggingCallback( \"testDone\" ),\n\n\t// moduleStart: { name }\n\tmoduleStart: registerLoggingCallback( \"moduleStart\" ),\n\n\t// moduleDone: { name, failed, passed, total }\n\tmoduleDone: registerLoggingCallback( \"moduleDone\" )\n});\n\nif ( !defined.document || document.readyState === \"complete\" ) {\n\tconfig.autorun = true;\n}\n\nQUnit.load = function() {\n\trunLoggingCallbacks( \"begin\", QUnit, {} );\n\n\t// Initialize the config, saving the execution queue\n\tvar banner, filter, i, j, label, len, main, ol, toolbar, val, selection,\n\t\turlConfigContainer, moduleFilter, userAgent,\n\t\tnumModules = 0,\n\t\tmoduleNames = [],\n\t\tmoduleFilterHtml = \"\",\n\t\turlConfigHtml = \"\",\n\t\toldconfig = extend( {}, config );\n\n\tQUnit.init();\n\textend(config, oldconfig);\n\n\tconfig.blocking = false;\n\n\tlen = config.urlConfig.length;\n\n\tfor ( i = 0; i < len; i++ ) {\n\t\tval = config.urlConfig[i];\n\t\tif ( typeof val === \"string\" ) {\n\t\t\tval = {\n\t\t\t\tid: val,\n\t\t\t\tlabel: val\n\t\t\t};\n\t\t}\n\t\tconfig[ val.id ] = QUnit.urlParams[ val.id ];\n\t\tif ( !val.value || typeof val.value === \"string\" ) {\n\t\t\turlConfigHtml += \"<input id='qunit-urlconfig-\" + escapeText( val.id ) +\n\t\t\t\t\"' name='\" + escapeText( val.id ) +\n\t\t\t\t\"' type='checkbox'\" +\n\t\t\t\t( val.value ? \" value='\" + escapeText( val.value ) + \"'\" : \"\" ) +\n\t\t\t\t( config[ val.id ] ? \" checked='checked'\" : \"\" ) +\n\t\t\t\t\" title='\" + escapeText( val.tooltip ) +\n\t\t\t\t\"'><label for='qunit-urlconfig-\" + escapeText( val.id ) +\n\t\t\t\t\"' title='\" + escapeText( val.tooltip ) + \"'>\" + val.label + \"</label>\";\n\t\t} else {\n\t\t\turlConfigHtml += \"<label for='qunit-urlconfig-\" + escapeText( val.id ) +\n\t\t\t\t\"' title='\" + escapeText( val.tooltip ) +\n\t\t\t\t\"'>\" + val.label +\n\t\t\t\t\": </label><select id='qunit-urlconfig-\" + escapeText( val.id ) +\n\t\t\t\t\"' name='\" + escapeText( val.id ) +\n\t\t\t\t\"' title='\" + escapeText( val.tooltip ) +\n\t\t\t\t\"'><option></option>\";\n\t\t\tselection = false;\n\t\t\tif ( QUnit.is( \"array\", val.value ) ) {\n\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {\n\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( val.value[j] ) + \"'\" +\n\t\t\t\t\t\t( config[ val.id ] === val.value[j] ?\n\t\t\t\t\t\t\t(selection = true) && \" selected='selected'\" :\n\t\t\t\t\t\t\t\"\" ) +\n\t\t\t\t\t\t\">\" + escapeText( val.value[j] ) + \"</option>\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( j in val.value ) {\n\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {\n\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( j ) + \"'\" +\n\t\t\t\t\t\t\t( config[ val.id ] === j ?\n\t\t\t\t\t\t\t\t(selection = true) && \" selected='selected'\" :\n\t\t\t\t\t\t\t\t\"\" ) +\n\t\t\t\t\t\t\t\">\" + escapeText( val.value[j] ) + \"</option>\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( config[ val.id ] && !selection ) {\n\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( config[ val.id ] ) +\n\t\t\t\t\t\"' selected='selected' disabled='disabled'>\" +\n\t\t\t\t\tescapeText( config[ val.id ] ) +\n\t\t\t\t\t\"</option>\";\n\t\t\t}\n\t\t\turlConfigHtml += \"</select>\";\n\t\t}\n\t}\n\tfor ( i in config.modules ) {\n\t\tif ( config.modules.hasOwnProperty( i ) ) {\n\t\t\tmoduleNames.push(i);\n\t\t}\n\t}\n\tnumModules = moduleNames.length;\n\tmoduleNames.sort( function( a, b ) {\n\t\treturn a.localeCompare( b );\n\t});\n\tmoduleFilterHtml += \"<label for='qunit-modulefilter'>Module: </label><select id='qunit-modulefilter' name='modulefilter'><option value='' \" +\n\t\t( config.module === undefined  ? \"selected='selected'\" : \"\" ) +\n\t\t\">< All Modules ></option>\";\n\n\n\tfor ( i = 0; i < numModules; i++) {\n\t\t\tmoduleFilterHtml += \"<option value='\" + escapeText( encodeURIComponent(moduleNames[i]) ) + \"' \" +\n\t\t\t\t( config.module === moduleNames[i] ? \"selected='selected'\" : \"\" ) +\n\t\t\t\t\">\" + escapeText(moduleNames[i]) + \"</option>\";\n\t}\n\tmoduleFilterHtml += \"</select>\";\n\n\t// `userAgent` initialized at top of scope\n\tuserAgent = id( \"qunit-userAgent\" );\n\tif ( userAgent ) {\n\t\tuserAgent.innerHTML = navigator.userAgent;\n\t}\n\n\t// `banner` initialized at top of scope\n\tbanner = id( \"qunit-header\" );\n\tif ( banner ) {\n\t\tbanner.innerHTML = \"<a href='\" + QUnit.url({ filter: undefined, module: undefined, testNumber: undefined }) + \"'>\" + banner.innerHTML + \"</a> \";\n\t}\n\n\t// `toolbar` initialized at top of scope\n\ttoolbar = id( \"qunit-testrunner-toolbar\" );\n\tif ( toolbar ) {\n\t\t// `filter` initialized at top of scope\n\t\tfilter = document.createElement( \"input\" );\n\t\tfilter.type = \"checkbox\";\n\t\tfilter.id = \"qunit-filter-pass\";\n\n\t\taddEvent( filter, \"click\", function() {\n\t\t\tvar tmp,\n\t\t\t\tol = id( \"qunit-tests\" );\n\n\t\t\tif ( filter.checked ) {\n\t\t\t\tol.className = ol.className + \" hidepass\";\n\t\t\t} else {\n\t\t\t\ttmp = \" \" + ol.className.replace( /[\\n\\t\\r]/g, \" \" ) + \" \";\n\t\t\t\tol.className = tmp.replace( / hidepass /, \" \" );\n\t\t\t}\n\t\t\tif ( defined.sessionStorage ) {\n\t\t\t\tif (filter.checked) {\n\t\t\t\t\tsessionStorage.setItem( \"qunit-filter-passed-tests\", \"true\" );\n\t\t\t\t} else {\n\t\t\t\t\tsessionStorage.removeItem( \"qunit-filter-passed-tests\" );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif ( config.hidepassed || defined.sessionStorage && sessionStorage.getItem( \"qunit-filter-passed-tests\" ) ) {\n\t\t\tfilter.checked = true;\n\t\t\t// `ol` initialized at top of scope\n\t\t\tol = id( \"qunit-tests\" );\n\t\t\tol.className = ol.className + \" hidepass\";\n\t\t}\n\t\ttoolbar.appendChild( filter );\n\n\t\t// `label` initialized at top of scope\n\t\tlabel = document.createElement( \"label\" );\n\t\tlabel.setAttribute( \"for\", \"qunit-filter-pass\" );\n\t\tlabel.setAttribute( \"title\", \"Only show tests and assertions that fail. Stored in sessionStorage.\" );\n\t\tlabel.innerHTML = \"Hide passed tests\";\n\t\ttoolbar.appendChild( label );\n\n\t\turlConfigContainer = document.createElement(\"span\");\n\t\turlConfigContainer.innerHTML = urlConfigHtml;\n\t\t// For oldIE support:\n\t\t// * Add handlers to the individual elements instead of the container\n\t\t// * Use \"click\" instead of \"change\" for checkboxes\n\t\t// * Fallback from event.target to event.srcElement\n\t\taddEvents( urlConfigContainer.getElementsByTagName(\"input\"), \"click\", function( event ) {\n\t\t\tvar params = {},\n\t\t\t\ttarget = event.target || event.srcElement;\n\t\t\tparams[ target.name ] = target.checked ?\n\t\t\t\ttarget.defaultValue || true :\n\t\t\t\tundefined;\n\t\t\twindow.location = QUnit.url( params );\n\t\t});\n\t\taddEvents( urlConfigContainer.getElementsByTagName(\"select\"), \"change\", function( event ) {\n\t\t\tvar params = {},\n\t\t\t\ttarget = event.target || event.srcElement;\n\t\t\tparams[ target.name ] = target.options[ target.selectedIndex ].value || undefined;\n\t\t\twindow.location = QUnit.url( params );\n\t\t});\n\t\ttoolbar.appendChild( urlConfigContainer );\n\n\t\tif (numModules > 1) {\n\t\t\tmoduleFilter = document.createElement( \"span\" );\n\t\t\tmoduleFilter.setAttribute( \"id\", \"qunit-modulefilter-container\" );\n\t\t\tmoduleFilter.innerHTML = moduleFilterHtml;\n\t\t\taddEvent( moduleFilter.lastChild, \"change\", function() {\n\t\t\t\tvar selectBox = moduleFilter.getElementsByTagName(\"select\")[0],\n\t\t\t\t\tselectedModule = decodeURIComponent(selectBox.options[selectBox.selectedIndex].value);\n\n\t\t\t\twindow.location = QUnit.url({\n\t\t\t\t\tmodule: ( selectedModule === \"\" ) ? undefined : selectedModule,\n\t\t\t\t\t// Remove any existing filters\n\t\t\t\t\tfilter: undefined,\n\t\t\t\t\ttestNumber: undefined\n\t\t\t\t});\n\t\t\t});\n\t\t\ttoolbar.appendChild(moduleFilter);\n\t\t}\n\t}\n\n\t// `main` initialized at top of scope\n\tmain = id( \"qunit-fixture\" );\n\tif ( main ) {\n\t\tconfig.fixture = main.innerHTML;\n\t}\n\n\tif ( config.autostart ) {\n\t\tQUnit.start();\n\t}\n};\n\nif ( defined.document ) {\n\taddEvent( window, \"load\", QUnit.load );\n}\n\n// `onErrorFnPrev` initialized at top of scope\n// Preserve other handlers\nonErrorFnPrev = window.onerror;\n\n// Cover uncaught exceptions\n// Returning true will suppress the default browser handler,\n// returning false will let it run.\nwindow.onerror = function ( error, filePath, linerNr ) {\n\tvar ret = false;\n\tif ( onErrorFnPrev ) {\n\t\tret = onErrorFnPrev( error, filePath, linerNr );\n\t}\n\n\t// Treat return value as window.onerror itself does,\n\t// Only do our handling if not suppressed.\n\tif ( ret !== true ) {\n\t\tif ( QUnit.config.current ) {\n\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t} else {\n\t\t\tQUnit.test( \"global failure\", extend( function() {\n\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t}, { validTest: validTest } ) );\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn ret;\n};\n\nfunction done() {\n\tconfig.autorun = true;\n\n\t// Log the last module results\n\tif ( config.previousModule ) {\n\t\trunLoggingCallbacks( \"moduleDone\", QUnit, {\n\t\t\tname: config.previousModule,\n\t\t\tfailed: config.moduleStats.bad,\n\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\ttotal: config.moduleStats.all\n\t\t});\n\t}\n\tdelete config.previousModule;\n\n\tvar i, key,\n\t\tbanner = id( \"qunit-banner\" ),\n\t\ttests = id( \"qunit-tests\" ),\n\t\truntime = +new Date() - config.started,\n\t\tpassed = config.stats.all - config.stats.bad,\n\t\thtml = [\n\t\t\t\"Tests completed in \",\n\t\t\truntime,\n\t\t\t\" milliseconds.<br/>\",\n\t\t\t\"<span class='passed'>\",\n\t\t\tpassed,\n\t\t\t\"</span> assertions of <span class='total'>\",\n\t\t\tconfig.stats.all,\n\t\t\t\"</span> passed, <span class='failed'>\",\n\t\t\tconfig.stats.bad,\n\t\t\t\"</span> failed.\"\n\t\t].join( \"\" );\n\n\tif ( banner ) {\n\t\tbanner.className = ( config.stats.bad ? \"qunit-fail\" : \"qunit-pass\" );\n\t}\n\n\tif ( tests ) {\n\t\tid( \"qunit-testresult\" ).innerHTML = html;\n\t}\n\n\tif ( config.altertitle && defined.document && document.title ) {\n\t\t// show ✖ for good, ✔ for bad suite result in title\n\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\tdocument.title = [\n\t\t\t( config.stats.bad ? \"\\u2716\" : \"\\u2714\" ),\n\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, \"\" )\n\t\t].join( \" \" );\n\t}\n\n\t// clear own sessionStorage items if all tests passed\n\tif ( config.reorder && defined.sessionStorage && config.stats.bad === 0 ) {\n\t\t// `key` & `i` initialized at top of scope\n\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\n\t\t\tkey = sessionStorage.key( i++ );\n\t\t\tif ( key.indexOf( \"qunit-test-\" ) === 0 ) {\n\t\t\t\tsessionStorage.removeItem( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t// scroll back to top to show results\n\tif ( config.scrolltop && window.scrollTo ) {\n\t\twindow.scrollTo(0, 0);\n\t}\n\n\trunLoggingCallbacks( \"done\", QUnit, {\n\t\tfailed: config.stats.bad,\n\t\tpassed: passed,\n\t\ttotal: config.stats.all,\n\t\truntime: runtime\n\t});\n}\n\n/** @return Boolean: true if this test should be ran */\nfunction validTest( test ) {\n\tvar include,\n\t\tfilter = config.filter && config.filter.toLowerCase(),\n\t\tmodule = config.module && config.module.toLowerCase(),\n\t\tfullName = ( test.module + \": \" + test.testName ).toLowerCase();\n\n\t// Internally-generated tests are always valid\n\tif ( test.callback && test.callback.validTest === validTest ) {\n\t\tdelete test.callback.validTest;\n\t\treturn true;\n\t}\n\n\tif ( config.testNumber.length > 0 ) {\n\t\tif ( inArray( test.testNumber, config.testNumber ) < 0 ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif ( module && ( !test.module || test.module.toLowerCase() !== module ) ) {\n\t\treturn false;\n\t}\n\n\tif ( !filter ) {\n\t\treturn true;\n\t}\n\n\tinclude = filter.charAt( 0 ) !== \"!\";\n\tif ( !include ) {\n\t\tfilter = filter.slice( 1 );\n\t}\n\n\t// If the filter matches, we need to honour include\n\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\treturn include;\n\t}\n\n\t// Otherwise, do the opposite\n\treturn !include;\n}\n\n// so far supports only Firefox, Chrome and Opera (buggy), Safari (for real exceptions)\n// Later Safari and IE10 are supposed to support error.stack as well\n// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\nfunction extractStacktrace( e, offset ) {\n\toffset = offset === undefined ? 3 : offset;\n\n\tvar stack, include, i;\n\n\tif ( e.stacktrace ) {\n\t\t// Opera\n\t\treturn e.stacktrace.split( \"\\n\" )[ offset + 3 ];\n\t} else if ( e.stack ) {\n\t\t// Firefox, Chrome\n\t\tstack = e.stack.split( \"\\n\" );\n\t\tif (/^error$/i.test( stack[0] ) ) {\n\t\t\tstack.shift();\n\t\t}\n\t\tif ( fileName ) {\n\t\t\tinclude = [];\n\t\t\tfor ( i = offset; i < stack.length; i++ ) {\n\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinclude.push( stack[ i ] );\n\t\t\t}\n\t\t\tif ( include.length ) {\n\t\t\t\treturn include.join( \"\\n\" );\n\t\t\t}\n\t\t}\n\t\treturn stack[ offset ];\n\t} else if ( e.sourceURL ) {\n\t\t// Safari, PhantomJS\n\t\t// hopefully one day Safari provides actual stacktraces\n\t\t// exclude useless self-reference for generated Error objects\n\t\tif ( /qunit.js$/.test( e.sourceURL ) ) {\n\t\t\treturn;\n\t\t}\n\t\t// for actual exceptions, this is useful\n\t\treturn e.sourceURL + \":\" + e.line;\n\t}\n}\nfunction sourceFromStacktrace( offset ) {\n\ttry {\n\t\tthrow new Error();\n\t} catch ( e ) {\n\t\treturn extractStacktrace( e, offset );\n\t}\n}\n\n/**\n * Escape text for attribute or text content.\n */\nfunction escapeText( s ) {\n\tif ( !s ) {\n\t\treturn \"\";\n\t}\n\ts = s + \"\";\n\t// Both single quotes and double quotes (for attributes)\n\treturn s.replace( /['\"<>&]/g, function( s ) {\n\t\tswitch( s ) {\n\t\t\tcase \"'\":\n\t\t\t\treturn \"&#039;\";\n\t\t\tcase \"\\\"\":\n\t\t\t\treturn \"&quot;\";\n\t\t\tcase \"<\":\n\t\t\t\treturn \"&lt;\";\n\t\t\tcase \">\":\n\t\t\t\treturn \"&gt;\";\n\t\t\tcase \"&\":\n\t\t\t\treturn \"&amp;\";\n\t\t}\n\t});\n}\n\nfunction synchronize( callback, last ) {\n\tconfig.queue.push( callback );\n\n\tif ( config.autorun && !config.blocking ) {\n\t\tprocess( last );\n\t}\n}\n\nfunction process( last ) {\n\tfunction next() {\n\t\tprocess( last );\n\t}\n\tvar start = new Date().getTime();\n\tconfig.depth = config.depth ? config.depth + 1 : 1;\n\n\twhile ( config.queue.length && !config.blocking ) {\n\t\tif ( !defined.setTimeout || config.updateRate <= 0 || ( ( new Date().getTime() - start ) < config.updateRate ) ) {\n\t\t\tconfig.queue.shift()();\n\t\t} else {\n\t\t\tsetTimeout( next, 13 );\n\t\t\tbreak;\n\t\t}\n\t}\n\tconfig.depth--;\n\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\tdone();\n\t}\n}\n\nfunction saveGlobal() {\n\tconfig.pollution = [];\n\n\tif ( config.noglobals ) {\n\t\tfor ( var key in window ) {\n\t\t\tif ( hasOwn.call( window, key ) ) {\n\t\t\t\t// in Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconfig.pollution.push( key );\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction checkPollution() {\n\tvar newGlobals,\n\t\tdeletedGlobals,\n\t\told = config.pollution;\n\n\tsaveGlobal();\n\n\tnewGlobals = diff( config.pollution, old );\n\tif ( newGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Introduced global variable(s): \" + newGlobals.join(\", \") );\n\t}\n\n\tdeletedGlobals = diff( old, config.pollution );\n\tif ( deletedGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Deleted global variable(s): \" + deletedGlobals.join(\", \") );\n\t}\n}\n\n// returns a new Array with the elements that are in a but not in b\nfunction diff( a, b ) {\n\tvar i, j,\n\t\tresult = a.slice();\n\n\tfor ( i = 0; i < result.length; i++ ) {\n\t\tfor ( j = 0; j < b.length; j++ ) {\n\t\t\tif ( result[i] === b[j] ) {\n\t\t\t\tresult.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction extend( a, b ) {\n\tfor ( var prop in b ) {\n\t\tif ( hasOwn.call( b, prop ) ) {\n\t\t\t// Avoid \"Member not found\" error in IE8 caused by messing with window.constructor\n\t\t\tif ( !( prop === \"constructor\" && a === window ) ) {\n\t\t\t\tif ( b[ prop ] === undefined ) {\n\t\t\t\t\tdelete a[ prop ];\n\t\t\t\t} else {\n\t\t\t\t\ta[ prop ] = b[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a;\n}\n\n/**\n * @param {HTMLElement} elem\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvent( elem, type, fn ) {\n\tif ( elem.addEventListener ) {\n\n\t\t// Standards-based browsers\n\t\telem.addEventListener( type, fn, false );\n\t} else if ( elem.attachEvent ) {\n\n\t\t// support: IE <9\n\t\telem.attachEvent( \"on\" + type, fn );\n\t} else {\n\n\t\t// Caller must ensure support for event listeners is present\n\t\tthrow new Error( \"addEvent() was called in a context without event listener support\" );\n\t}\n}\n\n/**\n * @param {Array|NodeList} elems\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvents( elems, type, fn ) {\n\tvar i = elems.length;\n\twhile ( i-- ) {\n\t\taddEvent( elems[i], type, fn );\n\t}\n}\n\nfunction hasClass( elem, name ) {\n\treturn (\" \" + elem.className + \" \").indexOf(\" \" + name + \" \") > -1;\n}\n\nfunction addClass( elem, name ) {\n\tif ( !hasClass( elem, name ) ) {\n\t\telem.className += (elem.className ? \" \" : \"\") + name;\n\t}\n}\n\nfunction removeClass( elem, name ) {\n\tvar set = \" \" + elem.className + \" \";\n\t// Class name may appear multiple times\n\twhile ( set.indexOf(\" \" + name + \" \") > -1 ) {\n\t\tset = set.replace(\" \" + name + \" \" , \" \");\n\t}\n\t// If possible, trim it for prettiness, but not necessarily\n\telem.className = typeof set.trim === \"function\" ? set.trim() : set.replace(/^\\s+|\\s+$/g, \"\");\n}\n\nfunction id( name ) {\n\treturn defined.document && document.getElementById && document.getElementById( name );\n}\n\nfunction registerLoggingCallback( key ) {\n\treturn function( callback ) {\n\t\tconfig[key].push( callback );\n\t};\n}\n\n// Supports deprecated method of completely overwriting logging callbacks\nfunction runLoggingCallbacks( key, scope, args ) {\n\tvar i, callbacks;\n\tif ( QUnit.hasOwnProperty( key ) ) {\n\t\tQUnit[ key ].call(scope, args );\n\t} else {\n\t\tcallbacks = config[ key ];\n\t\tfor ( i = 0; i < callbacks.length; i++ ) {\n\t\t\tcallbacks[ i ].call( scope, args );\n\t\t}\n\t}\n}\n\n// from jquery.js\nfunction inArray( elem, array ) {\n\tif ( array.indexOf ) {\n\t\treturn array.indexOf( elem );\n\t}\n\n\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\tif ( array[ i ] === elem ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nfunction Test( settings ) {\n\textend( this, settings );\n\tthis.assertions = [];\n\tthis.testNumber = ++Test.count;\n}\n\nTest.count = 0;\n\nTest.prototype = {\n\tinit: function() {\n\t\tvar a, b, li,\n\t\t\ttests = id( \"qunit-tests\" );\n\n\t\tif ( tests ) {\n\t\t\tb = document.createElement( \"strong\" );\n\t\t\tb.innerHTML = this.nameHtml;\n\n\t\t\t// `a` initialized at top of scope\n\t\t\ta = document.createElement( \"a\" );\n\t\t\ta.innerHTML = \"Rerun\";\n\t\t\ta.href = QUnit.url({ testNumber: this.testNumber });\n\n\t\t\tli = document.createElement( \"li\" );\n\t\t\tli.appendChild( b );\n\t\t\tli.appendChild( a );\n\t\t\tli.className = \"running\";\n\t\t\tli.id = this.id = \"qunit-test-output\" + testId++;\n\n\t\t\ttests.appendChild( li );\n\t\t}\n\t},\n\tsetup: function() {\n\t\tif (\n\t\t\t// Emit moduleStart when we're switching from one module to another\n\t\t\tthis.module !== config.previousModule ||\n\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn't\n\t\t\t\t// yet exist it means this is the first test in a suite that isn't wrapped in a\n\t\t\t\t// module, in which case we'll just emit a moduleStart event for 'undefined'.\n\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t!hasOwn.call( config, \"previousModule\" )\n\t\t) {\n\t\t\tif ( hasOwn.call( config, \"previousModule\" ) ) {\n\t\t\t\trunLoggingCallbacks( \"moduleDone\", QUnit, {\n\t\t\t\t\tname: config.previousModule,\n\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\ttotal: config.moduleStats.all\n\t\t\t\t});\n\t\t\t}\n\t\t\tconfig.previousModule = this.module;\n\t\t\tconfig.moduleStats = { all: 0, bad: 0 };\n\t\t\trunLoggingCallbacks( \"moduleStart\", QUnit, {\n\t\t\t\tname: this.module\n\t\t\t});\n\t\t}\n\n\t\tconfig.current = this;\n\n\t\tthis.testEnvironment = extend({\n\t\t\tsetup: function() {},\n\t\t\tteardown: function() {}\n\t\t}, this.moduleTestEnvironment );\n\n\t\tthis.started = +new Date();\n\t\trunLoggingCallbacks( \"testStart\", QUnit, {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module\n\t\t});\n\n\t\t/*jshint camelcase:false */\n\n\n\t\t/**\n\t\t * Expose the current test environment.\n\t\t *\n\t\t * @deprecated since 1.12.0: Use QUnit.config.current.testEnvironment instead.\n\t\t */\n\t\tQUnit.current_testEnvironment = this.testEnvironment;\n\n\t\t/*jshint camelcase:true */\n\n\t\tif ( !config.pollution ) {\n\t\t\tsaveGlobal();\n\t\t}\n\t\tif ( config.notrycatch ) {\n\t\t\tthis.testEnvironment.setup.call( this.testEnvironment, QUnit.assert );\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tthis.testEnvironment.setup.call( this.testEnvironment, QUnit.assert );\n\t\t} catch( e ) {\n\t\t\tQUnit.pushFailure( \"Setup failed on \" + this.testName + \": \" + ( e.message || e ), extractStacktrace( e, 1 ) );\n\t\t}\n\t},\n\trun: function() {\n\t\tconfig.current = this;\n\n\t\tvar running = id( \"qunit-testresult\" );\n\n\t\tif ( running ) {\n\t\t\trunning.innerHTML = \"Running: <br/>\" + this.nameHtml;\n\t\t}\n\n\t\tif ( this.async ) {\n\t\t\tQUnit.stop();\n\t\t}\n\n\t\tthis.callbackStarted = +new Date();\n\n\t\tif ( config.notrycatch ) {\n\t\t\tthis.callback.call( this.testEnvironment, QUnit.assert );\n\t\t\tthis.callbackRuntime = +new Date() - this.callbackStarted;\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tthis.callback.call( this.testEnvironment, QUnit.assert );\n\t\t\tthis.callbackRuntime = +new Date() - this.callbackStarted;\n\t\t} catch( e ) {\n\t\t\tthis.callbackRuntime = +new Date() - this.callbackStarted;\n\n\t\t\tQUnit.pushFailure( \"Died on test #\" + (this.assertions.length + 1) + \" \" + this.stack + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );\n\t\t\t// else next test will carry the responsibility\n\t\t\tsaveGlobal();\n\n\t\t\t// Restart the tests if they're blocking\n\t\t\tif ( config.blocking ) {\n\t\t\t\tQUnit.start();\n\t\t\t}\n\t\t}\n\t},\n\tteardown: function() {\n\t\tconfig.current = this;\n\t\tif ( config.notrycatch ) {\n\t\t\tif ( typeof this.callbackRuntime === \"undefined\" ) {\n\t\t\t\tthis.callbackRuntime = +new Date() - this.callbackStarted;\n\t\t\t}\n\t\t\tthis.testEnvironment.teardown.call( this.testEnvironment, QUnit.assert );\n\t\t\treturn;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tthis.testEnvironment.teardown.call( this.testEnvironment, QUnit.assert );\n\t\t\t} catch( e ) {\n\t\t\t\tQUnit.pushFailure( \"Teardown failed on \" + this.testName + \": \" + ( e.message || e ), extractStacktrace( e, 1 ) );\n\t\t\t}\n\t\t}\n\t\tcheckPollution();\n\t},\n\tfinish: function() {\n\t\tconfig.current = this;\n\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\tQUnit.pushFailure( \"Expected number of assertions to be defined, but expect() was not called.\", this.stack );\n\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\tQUnit.pushFailure( \"Expected \" + this.expected + \" assertions, but \" + this.assertions.length + \" were run\", this.stack );\n\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\tQUnit.pushFailure( \"Expected at least one assertion, but none were run - call expect(0) to accept zero assertions.\", this.stack );\n\t\t}\n\n\t\tvar i, assertion, a, b, time, li, ol,\n\t\t\ttest = this,\n\t\t\tgood = 0,\n\t\t\tbad = 0,\n\t\t\ttests = id( \"qunit-tests\" );\n\n\t\tthis.runtime = +new Date() - this.started;\n\t\tconfig.stats.all += this.assertions.length;\n\t\tconfig.moduleStats.all += this.assertions.length;\n\n\t\tif ( tests ) {\n\t\t\tol = document.createElement( \"ol\" );\n\t\t\tol.className = \"qunit-assert-list\";\n\n\t\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\t\tassertion = this.assertions[i];\n\n\t\t\t\tli = document.createElement( \"li\" );\n\t\t\t\tli.className = assertion.result ? \"pass\" : \"fail\";\n\t\t\t\tli.innerHTML = assertion.message || ( assertion.result ? \"okay\" : \"failed\" );\n\t\t\t\tol.appendChild( li );\n\n\t\t\t\tif ( assertion.result ) {\n\t\t\t\t\tgood++;\n\t\t\t\t} else {\n\t\t\t\t\tbad++;\n\t\t\t\t\tconfig.stats.bad++;\n\t\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// store result when possible\n\t\t\tif ( QUnit.config.reorder && defined.sessionStorage ) {\n\t\t\t\tif ( bad ) {\n\t\t\t\t\tsessionStorage.setItem( \"qunit-test-\" + this.module + \"-\" + this.testName, bad );\n\t\t\t\t} else {\n\t\t\t\t\tsessionStorage.removeItem( \"qunit-test-\" + this.module + \"-\" + this.testName );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( bad === 0 ) {\n\t\t\t\taddClass( ol, \"qunit-collapsed\" );\n\t\t\t}\n\n\t\t\t// `b` initialized at top of scope\n\t\t\tb = document.createElement( \"strong\" );\n\t\t\tb.innerHTML = this.nameHtml + \" <b class='counts'>(<b class='failed'>\" + bad + \"</b>, <b class='passed'>\" + good + \"</b>, \" + this.assertions.length + \")</b>\";\n\n\t\t\taddEvent(b, \"click\", function() {\n\t\t\t\tvar next = b.parentNode.lastChild,\n\t\t\t\t\tcollapsed = hasClass( next, \"qunit-collapsed\" );\n\t\t\t\t( collapsed ? removeClass : addClass )( next, \"qunit-collapsed\" );\n\t\t\t});\n\n\t\t\taddEvent(b, \"dblclick\", function( e ) {\n\t\t\t\tvar target = e && e.target ? e.target : window.event.srcElement;\n\t\t\t\tif ( target.nodeName.toLowerCase() === \"span\" || target.nodeName.toLowerCase() === \"b\" ) {\n\t\t\t\t\ttarget = target.parentNode;\n\t\t\t\t}\n\t\t\t\tif ( window.location && target.nodeName.toLowerCase() === \"strong\" ) {\n\t\t\t\t\twindow.location = QUnit.url({ testNumber: test.testNumber });\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// `time` initialized at top of scope\n\t\t\ttime = document.createElement( \"span\" );\n\t\t\ttime.className = \"runtime\";\n\t\t\ttime.innerHTML = this.runtime + \" ms\";\n\n\t\t\t// `li` initialized at top of scope\n\t\t\tli = id( this.id );\n\t\t\tli.className = bad ? \"fail\" : \"pass\";\n\t\t\tli.removeChild( li.firstChild );\n\t\t\ta = li.firstChild;\n\t\t\tli.appendChild( b );\n\t\t\tli.appendChild( a );\n\t\t\tli.appendChild( time );\n\t\t\tli.appendChild( ol );\n\n\t\t} else {\n\t\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\t\tif ( !this.assertions[i].result ) {\n\t\t\t\t\tbad++;\n\t\t\t\t\tconfig.stats.bad++;\n\t\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( \"testDone\", QUnit, {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module,\n\t\t\tfailed: bad,\n\t\t\tpassed: this.assertions.length - bad,\n\t\t\ttotal: this.assertions.length,\n\t\t\truntime: this.runtime,\n\t\t\t// DEPRECATED: this property will be removed in 2.0.0, use runtime instead\n\t\t\tduration: this.runtime\n\t\t});\n\n\t\tQUnit.reset();\n\n\t\tconfig.current = undefined;\n\t},\n\n\tqueue: function() {\n\t\tvar bad,\n\t\t\ttest = this;\n\n\t\tsynchronize(function() {\n\t\t\ttest.init();\n\t\t});\n\t\tfunction run() {\n\t\t\t// each of these can by async\n\t\t\tsynchronize(function() {\n\t\t\t\ttest.setup();\n\t\t\t});\n\t\t\tsynchronize(function() {\n\t\t\t\ttest.run();\n\t\t\t});\n\t\t\tsynchronize(function() {\n\t\t\t\ttest.teardown();\n\t\t\t});\n\t\t\tsynchronize(function() {\n\t\t\t\ttest.finish();\n\t\t\t});\n\t\t}\n\n\t\t// `bad` initialized at top of scope\n\t\t// defer when previous test run passed, if storage is available\n\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t\t\t+sessionStorage.getItem( \"qunit-test-\" + this.module + \"-\" + this.testName );\n\n\t\tif ( bad ) {\n\t\t\trun();\n\t\t} else {\n\t\t\tsynchronize( run, true );\n\t\t}\n\t}\n};\n\n// `assert` initialized at top of scope\n// Assert helpers\n// All of these must either call QUnit.push() or manually do:\n// - runLoggingCallbacks( \"log\", .. );\n// - config.current.assertions.push({ .. });\nassert = QUnit.assert = {\n\t/**\n\t * Asserts rough true-ish result.\n\t * @name ok\n\t * @function\n\t * @example ok( \"asdfasdf\".length > 5, \"There must be at least 5 chars\" );\n\t */\n\tok: function( result, msg ) {\n\t\tif ( !config.current ) {\n\t\t\tthrow new Error( \"ok() assertion outside test context, was \" + sourceFromStacktrace(2) );\n\t\t}\n\t\tresult = !!result;\n\t\tmsg = msg || ( result ? \"okay\" : \"failed\" );\n\n\t\tvar source,\n\t\t\tdetails = {\n\t\t\t\tmodule: config.current.module,\n\t\t\t\tname: config.current.testName,\n\t\t\t\tresult: result,\n\t\t\t\tmessage: msg\n\t\t\t};\n\n\t\tmsg = \"<span class='test-message'>\" + escapeText( msg ) + \"</span>\";\n\n\t\tif ( !result ) {\n\t\t\tsource = sourceFromStacktrace( 2 );\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t\tmsg += \"<table><tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\t\t\tescapeText( source ) +\n\t\t\t\t\t\"</pre></td></tr></table>\";\n\t\t\t}\n\t\t}\n\t\trunLoggingCallbacks( \"log\", QUnit, details );\n\t\tconfig.current.assertions.push({\n\t\t\tresult: result,\n\t\t\tmessage: msg\n\t\t});\n\t},\n\n\t/**\n\t * Assert that the first two arguments are equal, with an optional message.\n\t * Prints out both actual and expected values.\n\t * @name equal\n\t * @function\n\t * @example equal( format( \"Received {0} bytes.\", 2), \"Received 2 bytes.\", \"format() replaces {0} with next argument\" );\n\t */\n\tequal: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tQUnit.push( expected == actual, actual, expected, message );\n\t},\n\n\t/**\n\t * @name notEqual\n\t * @function\n\t */\n\tnotEqual: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tQUnit.push( expected != actual, actual, expected, message );\n\t},\n\n\t/**\n\t * @name propEqual\n\t * @function\n\t */\n\tpropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues(actual);\n\t\texpected = objectValues(expected);\n\t\tQUnit.push( QUnit.equiv(actual, expected), actual, expected, message );\n\t},\n\n\t/**\n\t * @name notPropEqual\n\t * @function\n\t */\n\tnotPropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues(actual);\n\t\texpected = objectValues(expected);\n\t\tQUnit.push( !QUnit.equiv(actual, expected), actual, expected, message );\n\t},\n\n\t/**\n\t * @name deepEqual\n\t * @function\n\t */\n\tdeepEqual: function( actual, expected, message ) {\n\t\tQUnit.push( QUnit.equiv(actual, expected), actual, expected, message );\n\t},\n\n\t/**\n\t * @name notDeepEqual\n\t * @function\n\t */\n\tnotDeepEqual: function( actual, expected, message ) {\n\t\tQUnit.push( !QUnit.equiv(actual, expected), actual, expected, message );\n\t},\n\n\t/**\n\t * @name strictEqual\n\t * @function\n\t */\n\tstrictEqual: function( actual, expected, message ) {\n\t\tQUnit.push( expected === actual, actual, expected, message );\n\t},\n\n\t/**\n\t * @name notStrictEqual\n\t * @function\n\t */\n\tnotStrictEqual: function( actual, expected, message ) {\n\t\tQUnit.push( expected !== actual, actual, expected, message );\n\t},\n\n\t\"throws\": function( block, expected, message ) {\n\t\tvar actual,\n\t\t\texpectedOutput = expected,\n\t\t\tok = false;\n\n\t\t// 'expected' is optional\n\t\tif ( !message && typeof expected === \"string\" ) {\n\t\t\tmessage = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tconfig.current.ignoreGlobalErrors = true;\n\t\ttry {\n\t\t\tblock.call( config.current.testEnvironment );\n\t\t} catch (e) {\n\t\t\tactual = e;\n\t\t}\n\t\tconfig.current.ignoreGlobalErrors = false;\n\n\t\tif ( actual ) {\n\n\t\t\t// we don't want to validate thrown error\n\t\t\tif ( !expected ) {\n\t\t\t\tok = true;\n\t\t\t\texpectedOutput = null;\n\n\t\t\t// expected is an Error object\n\t\t\t} else if ( expected instanceof Error ) {\n\t\t\t\tok = actual instanceof Error &&\n\t\t\t\t\t actual.name === expected.name &&\n\t\t\t\t\t actual.message === expected.message;\n\n\t\t\t// expected is a regexp\n\t\t\t} else if ( QUnit.objectType( expected ) === \"regexp\" ) {\n\t\t\t\tok = expected.test( errorString( actual ) );\n\n\t\t\t// expected is a string\n\t\t\t} else if ( QUnit.objectType( expected ) === \"string\" ) {\n\t\t\t\tok = expected === errorString( actual );\n\n\t\t\t// expected is a constructor\n\t\t\t} else if ( actual instanceof expected ) {\n\t\t\t\tok = true;\n\n\t\t\t// expected is a validation function which returns true is validation passed\n\t\t\t} else if ( expected.call( {}, actual ) === true ) {\n\t\t\t\texpectedOutput = null;\n\t\t\t\tok = true;\n\t\t\t}\n\n\t\t\tQUnit.push( ok, actual, expectedOutput, message );\n\t\t} else {\n\t\t\tQUnit.pushFailure( message, null, \"No exception was thrown.\" );\n\t\t}\n\t}\n};\n\n/**\n * @deprecated since 1.8.0\n * Kept assertion helpers in root for backwards compatibility.\n */\nextend( QUnit.constructor.prototype, assert );\n\n/**\n * @deprecated since 1.9.0\n * Kept to avoid TypeErrors for undefined methods.\n */\nQUnit.constructor.prototype.raises = function() {\n\tQUnit.push( false, false, false, \"QUnit.raises has been deprecated since 2012 (fad3c1ea), use QUnit.throws instead\" );\n};\n\n/**\n * @deprecated since 1.0.0, replaced with error pushes since 1.3.0\n * Kept to avoid TypeErrors for undefined methods.\n */\nQUnit.constructor.prototype.equals = function() {\n\tQUnit.push( false, false, false, \"QUnit.equals has been deprecated since 2009 (e88049a0), use QUnit.equal instead\" );\n};\nQUnit.constructor.prototype.same = function() {\n\tQUnit.push( false, false, false, \"QUnit.same has been deprecated since 2009 (e88049a0), use QUnit.deepEqual instead\" );\n};\n\n// Test for equality any JavaScript type.\n// Author: Philippe Rathé <prathe@gmail.com>\nQUnit.equiv = (function() {\n\n\t// Call the o related callback with the given arguments.\n\tfunction bindCallbacks( o, callbacks, args ) {\n\t\tvar prop = QUnit.objectType( o );\n\t\tif ( prop ) {\n\t\t\tif ( QUnit.objectType( callbacks[ prop ] ) === \"function\" ) {\n\t\t\t\treturn callbacks[ prop ].apply( callbacks, args );\n\t\t\t} else {\n\t\t\t\treturn callbacks[ prop ]; // or undefined\n\t\t\t}\n\t\t}\n\t}\n\n\t// the real equiv function\n\tvar innerEquiv,\n\t\t// stack to decide between skip/abort functions\n\t\tcallers = [],\n\t\t// stack to avoiding loops from circular referencing\n\t\tparents = [],\n\t\tparentsB = [],\n\n\t\tgetProto = Object.getPrototypeOf || function ( obj ) {\n\t\t\t/*jshint camelcase:false */\n\t\t\treturn obj.__proto__;\n\t\t},\n\t\tcallbacks = (function () {\n\n\t\t\t// for string, boolean, number and null\n\t\t\tfunction useStrictEquality( b, a ) {\n\t\t\t\t/*jshint eqeqeq:false */\n\t\t\t\tif ( b instanceof a.constructor || a instanceof b.constructor ) {\n\t\t\t\t\t// to catch short annotation VS 'new' annotation of a\n\t\t\t\t\t// declaration\n\t\t\t\t\t// e.g. var i = 1;\n\t\t\t\t\t// var j = new Number(1);\n\t\t\t\t\treturn a == b;\n\t\t\t\t} else {\n\t\t\t\t\treturn a === b;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t\"string\": useStrictEquality,\n\t\t\t\t\"boolean\": useStrictEquality,\n\t\t\t\t\"number\": useStrictEquality,\n\t\t\t\t\"null\": useStrictEquality,\n\t\t\t\t\"undefined\": useStrictEquality,\n\n\t\t\t\t\"nan\": function( b ) {\n\t\t\t\t\treturn isNaN( b );\n\t\t\t\t},\n\n\t\t\t\t\"date\": function( b, a ) {\n\t\t\t\t\treturn QUnit.objectType( b ) === \"date\" && a.valueOf() === b.valueOf();\n\t\t\t\t},\n\n\t\t\t\t\"regexp\": function( b, a ) {\n\t\t\t\t\treturn QUnit.objectType( b ) === \"regexp\" &&\n\t\t\t\t\t\t// the regex itself\n\t\t\t\t\t\ta.source === b.source &&\n\t\t\t\t\t\t// and its modifiers\n\t\t\t\t\t\ta.global === b.global &&\n\t\t\t\t\t\t// (gmi) ...\n\t\t\t\t\t\ta.ignoreCase === b.ignoreCase &&\n\t\t\t\t\t\ta.multiline === b.multiline &&\n\t\t\t\t\t\ta.sticky === b.sticky;\n\t\t\t\t},\n\n\t\t\t\t// - skip when the property is a method of an instance (OOP)\n\t\t\t\t// - abort otherwise,\n\t\t\t\t// initial === would have catch identical references anyway\n\t\t\t\t\"function\": function() {\n\t\t\t\t\tvar caller = callers[callers.length - 1];\n\t\t\t\t\treturn caller !== Object && typeof caller !== \"undefined\";\n\t\t\t\t},\n\n\t\t\t\t\"array\": function( b, a ) {\n\t\t\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\n\t\t\t\t\t// b could be an object literal here\n\t\t\t\t\tif ( QUnit.objectType( b ) !== \"array\" ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tlen = a.length;\n\t\t\t\t\tif ( len !== b.length ) {\n\t\t\t\t\t\t// safe and faster\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// track reference to avoid circular references\n\t\t\t\t\tparents.push( a );\n\t\t\t\t\tparentsB.push( b );\n\t\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\t\tloop = false;\n\t\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\t\t\taCircular = parents[j] === a[i];\n\t\t\t\t\t\t\tbCircular = parentsB[j] === b[i];\n\t\t\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\t\t\tif ( a[i] === b[i] || aCircular && bCircular ) {\n\t\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( !loop && !innerEquiv(a[i], b[i]) ) {\n\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\t\"object\": function( b, a ) {\n\t\t\t\t\t/*jshint forin:false */\n\t\t\t\t\tvar i, j, loop, aCircular, bCircular,\n\t\t\t\t\t\t// Default to true\n\t\t\t\t\t\teq = true,\n\t\t\t\t\t\taProperties = [],\n\t\t\t\t\t\tbProperties = [];\n\n\t\t\t\t\t// comparing constructors is more strict than using\n\t\t\t\t\t// instanceof\n\t\t\t\t\tif ( a.constructor !== b.constructor ) {\n\t\t\t\t\t\t// Allow objects with no prototype to be equivalent to\n\t\t\t\t\t\t// objects with Object as their constructor.\n\t\t\t\t\t\tif ( !(( getProto(a) === null && getProto(b) === Object.prototype ) ||\n\t\t\t\t\t\t\t( getProto(b) === null && getProto(a) === Object.prototype ) ) ) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// stack constructor before traversing properties\n\t\t\t\t\tcallers.push( a.constructor );\n\n\t\t\t\t\t// track reference to avoid circular references\n\t\t\t\t\tparents.push( a );\n\t\t\t\t\tparentsB.push( b );\n\n\t\t\t\t\t// be strict: don't ensure hasOwnProperty and go deep\n\t\t\t\t\tfor ( i in a ) {\n\t\t\t\t\t\tloop = false;\n\t\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\t\t\taCircular = parents[j] === a[i];\n\t\t\t\t\t\t\tbCircular = parentsB[j] === b[i];\n\t\t\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\t\t\tif ( a[i] === b[i] || aCircular && bCircular ) {\n\t\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\taProperties.push(i);\n\t\t\t\t\t\tif ( !loop && !innerEquiv(a[i], b[i]) ) {\n\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\tcallers.pop(); // unstack, we are done\n\n\t\t\t\t\tfor ( i in b ) {\n\t\t\t\t\t\tbProperties.push( i ); // collect b's properties\n\t\t\t\t\t}\n\n\t\t\t\t\t// Ensures identical properties name\n\t\t\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t\t\t}\n\t\t\t};\n\t\t}());\n\n\tinnerEquiv = function() { // can take multiple arguments\n\t\tvar args = [].slice.apply( arguments );\n\t\tif ( args.length < 2 ) {\n\t\t\treturn true; // end transition\n\t\t}\n\n\t\treturn (function( a, b ) {\n\t\t\tif ( a === b ) {\n\t\t\t\treturn true; // catch the most you can\n\t\t\t} else if ( a === null || b === null || typeof a === \"undefined\" ||\n\t\t\t\t\ttypeof b === \"undefined\" ||\n\t\t\t\t\tQUnit.objectType(a) !== QUnit.objectType(b) ) {\n\t\t\t\treturn false; // don't lose time with error prone cases\n\t\t\t} else {\n\t\t\t\treturn bindCallbacks(a, callbacks, [ b, a ]);\n\t\t\t}\n\n\t\t\t// apply transition with (1..n) arguments\n\t\t}( args[0], args[1] ) && innerEquiv.apply( this, args.splice(1, args.length - 1 )) );\n\t};\n\n\treturn innerEquiv;\n}());\n\n/**\n * jsDump Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com |\n * http://flesler.blogspot.com Licensed under BSD\n * (http://www.opensource.org/licenses/bsd-license.php) Date: 5/15/2008\n *\n * @projectDescription Advanced and extensible data dumping for Javascript.\n * @version 1.0.0\n * @author Ariel Flesler\n * @link {http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html}\n */\nQUnit.jsDump = (function() {\n\tfunction quote( str ) {\n\t\treturn \"\\\"\" + str.toString().replace( /\"/g, \"\\\\\\\"\" ) + \"\\\"\";\n\t}\n\tfunction literal( o ) {\n\t\treturn o + \"\";\n\t}\n\tfunction join( pre, arr, post ) {\n\t\tvar s = jsDump.separator(),\n\t\t\tbase = jsDump.indent(),\n\t\t\tinner = jsDump.indent(1);\n\t\tif ( arr.join ) {\n\t\t\tarr = arr.join( \",\" + s + inner );\n\t\t}\n\t\tif ( !arr ) {\n\t\t\treturn pre + post;\n\t\t}\n\t\treturn [ pre, inner + arr, base + post ].join(s);\n\t}\n\tfunction array( arr, stack ) {\n\t\tvar i = arr.length, ret = new Array(i);\n\t\tthis.up();\n\t\twhile ( i-- ) {\n\t\t\tret[i] = this.parse( arr[i] , undefined , stack);\n\t\t}\n\t\tthis.down();\n\t\treturn join( \"[\", ret, \"]\" );\n\t}\n\n\tvar reName = /^function (\\w+)/,\n\t\tjsDump = {\n\t\t\t// type is used mostly internally, you can fix a (custom)type in advance\n\t\t\tparse: function( obj, type, stack ) {\n\t\t\t\tstack = stack || [ ];\n\t\t\t\tvar inStack, res,\n\t\t\t\t\tparser = this.parsers[ type || this.typeOf(obj) ];\n\n\t\t\t\ttype = typeof parser;\n\t\t\t\tinStack = inArray( obj, stack );\n\n\t\t\t\tif ( inStack !== -1 ) {\n\t\t\t\t\treturn \"recursion(\" + (inStack - stack.length) + \")\";\n\t\t\t\t}\n\t\t\t\tif ( type === \"function\" )  {\n\t\t\t\t\tstack.push( obj );\n\t\t\t\t\tres = parser.call( this, obj, stack );\n\t\t\t\t\tstack.pop();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\treturn ( type === \"string\" ) ? parser : this.parsers.error;\n\t\t\t},\n\t\t\ttypeOf: function( obj ) {\n\t\t\t\tvar type;\n\t\t\t\tif ( obj === null ) {\n\t\t\t\t\ttype = \"null\";\n\t\t\t\t} else if ( typeof obj === \"undefined\" ) {\n\t\t\t\t\ttype = \"undefined\";\n\t\t\t\t} else if ( QUnit.is( \"regexp\", obj) ) {\n\t\t\t\t\ttype = \"regexp\";\n\t\t\t\t} else if ( QUnit.is( \"date\", obj) ) {\n\t\t\t\t\ttype = \"date\";\n\t\t\t\t} else if ( QUnit.is( \"function\", obj) ) {\n\t\t\t\t\ttype = \"function\";\n\t\t\t\t} else if ( typeof obj.setInterval !== undefined && typeof obj.document !== \"undefined\" && typeof obj.nodeType === \"undefined\" ) {\n\t\t\t\t\ttype = \"window\";\n\t\t\t\t} else if ( obj.nodeType === 9 ) {\n\t\t\t\t\ttype = \"document\";\n\t\t\t\t} else if ( obj.nodeType ) {\n\t\t\t\t\ttype = \"node\";\n\t\t\t\t} else if (\n\t\t\t\t\t// native arrays\n\t\t\t\t\ttoString.call( obj ) === \"[object Array]\" ||\n\t\t\t\t\t// NodeList objects\n\t\t\t\t\t( typeof obj.length === \"number\" && typeof obj.item !== \"undefined\" && ( obj.length ? obj.item(0) === obj[0] : ( obj.item( 0 ) === null && typeof obj[0] === \"undefined\" ) ) )\n\t\t\t\t) {\n\t\t\t\t\ttype = \"array\";\n\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {\n\t\t\t\t\ttype = \"error\";\n\t\t\t\t} else {\n\t\t\t\t\ttype = typeof obj;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\t\t\tseparator: function() {\n\t\t\t\treturn this.multiline ?\tthis.HTML ? \"<br />\" : \"\\n\" : this.HTML ? \"&nbsp;\" : \" \";\n\t\t\t},\n\t\t\t// extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\tindent: function( extra ) {\n\t\t\t\tif ( !this.multiline ) {\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\t\t\t\tvar chr = this.indentChar;\n\t\t\t\tif ( this.HTML ) {\n\t\t\t\t\tchr = chr.replace( /\\t/g, \"   \" ).replace( / /g, \"&nbsp;\" );\n\t\t\t\t}\n\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join(chr);\n\t\t\t},\n\t\t\tup: function( a ) {\n\t\t\t\tthis.depth += a || 1;\n\t\t\t},\n\t\t\tdown: function( a ) {\n\t\t\t\tthis.depth -= a || 1;\n\t\t\t},\n\t\t\tsetParser: function( name, parser ) {\n\t\t\t\tthis.parsers[name] = parser;\n\t\t\t},\n\t\t\t// The next 3 are exposed so you can use them\n\t\t\tquote: quote,\n\t\t\tliteral: literal,\n\t\t\tjoin: join,\n\t\t\t//\n\t\t\tdepth: 1,\n\t\t\t// This is the list of parsers, to modify them, use jsDump.setParser\n\t\t\tparsers: {\n\t\t\t\twindow: \"[Window]\",\n\t\t\t\tdocument: \"[Document]\",\n\t\t\t\terror: function(error) {\n\t\t\t\t\treturn \"Error(\\\"\" + error.message + \"\\\")\";\n\t\t\t\t},\n\t\t\t\tunknown: \"[Unknown]\",\n\t\t\t\t\"null\": \"null\",\n\t\t\t\t\"undefined\": \"undefined\",\n\t\t\t\t\"function\": function( fn ) {\n\t\t\t\t\tvar ret = \"function\",\n\t\t\t\t\t\t// functions never have name in IE\n\t\t\t\t\t\tname = \"name\" in fn ? fn.name : (reName.exec(fn) || [])[1];\n\n\t\t\t\t\tif ( name ) {\n\t\t\t\t\t\tret += \" \" + name;\n\t\t\t\t\t}\n\t\t\t\t\tret += \"( \";\n\n\t\t\t\t\tret = [ ret, QUnit.jsDump.parse( fn, \"functionArgs\" ), \"){\" ].join( \"\" );\n\t\t\t\t\treturn join( ret, QUnit.jsDump.parse(fn,\"functionCode\" ), \"}\" );\n\t\t\t\t},\n\t\t\t\tarray: array,\n\t\t\t\tnodelist: array,\n\t\t\t\t\"arguments\": array,\n\t\t\t\tobject: function( map, stack ) {\n\t\t\t\t\t/*jshint forin:false */\n\t\t\t\t\tvar ret = [ ], keys, key, val, i;\n\t\t\t\t\tQUnit.jsDump.up();\n\t\t\t\t\tkeys = [];\n\t\t\t\t\tfor ( key in map ) {\n\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t}\n\t\t\t\t\tkeys.sort();\n\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\n\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\tval = map[ key ];\n\t\t\t\t\t\tret.push( QUnit.jsDump.parse( key, \"key\" ) + \": \" + QUnit.jsDump.parse( val, undefined, stack ) );\n\t\t\t\t\t}\n\t\t\t\t\tQUnit.jsDump.down();\n\t\t\t\t\treturn join( \"{\", ret, \"}\" );\n\t\t\t\t},\n\t\t\t\tnode: function( node ) {\n\t\t\t\t\tvar len, i, val,\n\t\t\t\t\t\topen = QUnit.jsDump.HTML ? \"&lt;\" : \"<\",\n\t\t\t\t\t\tclose = QUnit.jsDump.HTML ? \"&gt;\" : \">\",\n\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\n\t\t\t\t\t\tret = open + tag,\n\t\t\t\t\t\tattrs = node.attributes;\n\n\t\t\t\t\tif ( attrs ) {\n\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {\n\t\t\t\t\t\t\tval = attrs[i].nodeValue;\n\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly set.\n\t\t\t\t\t\t\t// Those have values like undefined, null, 0, false, \"\" or \"inherit\".\n\t\t\t\t\t\t\tif ( val && val !== \"inherit\" ) {\n\t\t\t\t\t\t\t\tret += \" \" + attrs[i].nodeName + \"=\" + QUnit.jsDump.parse( val, \"attribute\" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret += close;\n\n\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {\n\t\t\t\t\t\tret += node.nodeValue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret + open + \"/\" + tag + close;\n\t\t\t\t},\n\t\t\t\t// function calls it internally, it's the arguments part of the function\n\t\t\t\tfunctionArgs: function( fn ) {\n\t\t\t\t\tvar args,\n\t\t\t\t\t\tl = fn.length;\n\n\t\t\t\t\tif ( !l ) {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\n\t\t\t\t\targs = new Array(l);\n\t\t\t\t\twhile ( l-- ) {\n\t\t\t\t\t\t// 97 is 'a'\n\t\t\t\t\t\targs[l] = String.fromCharCode(97+l);\n\t\t\t\t\t}\n\t\t\t\t\treturn \" \" + args.join( \", \" ) + \" \";\n\t\t\t\t},\n\t\t\t\t// object calls it internally, the key part of an item in a map\n\t\t\t\tkey: quote,\n\t\t\t\t// function calls it internally, it's the content of the function\n\t\t\t\tfunctionCode: \"[code]\",\n\t\t\t\t// node calls it internally, it's an html attribute value\n\t\t\t\tattribute: quote,\n\t\t\t\tstring: quote,\n\t\t\t\tdate: quote,\n\t\t\t\tregexp: literal,\n\t\t\t\tnumber: literal,\n\t\t\t\t\"boolean\": literal\n\t\t\t},\n\t\t\t// if true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\tHTML: false,\n\t\t\t// indentation unit\n\t\t\tindentChar: \"  \",\n\t\t\t// if true, items in a collection, are separated by a \\n, else just a space.\n\t\t\tmultiline: true\n\t\t};\n\n\treturn jsDump;\n}());\n\n/*\n * Javascript Diff Algorithm\n *  By John Resig (http://ejohn.org/)\n *  Modified by Chu Alan \"sprite\"\n *\n * Released under the MIT license.\n *\n * More Info:\n *  http://ejohn.org/projects/javascript-diff-algorithm/\n *\n * Usage: QUnit.diff(expected, actual)\n *\n * QUnit.diff( \"the quick brown fox jumped over\", \"the quick fox jumps over\" ) == \"the  quick <del>brown </del> fox <del>jumped </del><ins>jumps </ins> over\"\n */\nQUnit.diff = (function() {\n\t/*jshint eqeqeq:false, eqnull:true */\n\tfunction diff( o, n ) {\n\t\tvar i,\n\t\t\tns = {},\n\t\t\tos = {};\n\n\t\tfor ( i = 0; i < n.length; i++ ) {\n\t\t\tif ( !hasOwn.call( ns, n[i] ) ) {\n\t\t\t\tns[ n[i] ] = {\n\t\t\t\t\trows: [],\n\t\t\t\t\to: null\n\t\t\t\t};\n\t\t\t}\n\t\t\tns[ n[i] ].rows.push( i );\n\t\t}\n\n\t\tfor ( i = 0; i < o.length; i++ ) {\n\t\t\tif ( !hasOwn.call( os, o[i] ) ) {\n\t\t\t\tos[ o[i] ] = {\n\t\t\t\t\trows: [],\n\t\t\t\t\tn: null\n\t\t\t\t};\n\t\t\t}\n\t\t\tos[ o[i] ].rows.push( i );\n\t\t}\n\n\t\tfor ( i in ns ) {\n\t\t\tif ( hasOwn.call( ns, i ) ) {\n\t\t\t\tif ( ns[i].rows.length === 1 && hasOwn.call( os, i ) && os[i].rows.length === 1 ) {\n\t\t\t\t\tn[ ns[i].rows[0] ] = {\n\t\t\t\t\t\ttext: n[ ns[i].rows[0] ],\n\t\t\t\t\t\trow: os[i].rows[0]\n\t\t\t\t\t};\n\t\t\t\t\to[ os[i].rows[0] ] = {\n\t\t\t\t\t\ttext: o[ os[i].rows[0] ],\n\t\t\t\t\t\trow: ns[i].rows[0]\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor ( i = 0; i < n.length - 1; i++ ) {\n\t\t\tif ( n[i].text != null && n[ i + 1 ].text == null && n[i].row + 1 < o.length && o[ n[i].row + 1 ].text == null &&\n\t\t\t\t\t\tn[ i + 1 ] == o[ n[i].row + 1 ] ) {\n\n\t\t\t\tn[ i + 1 ] = {\n\t\t\t\t\ttext: n[ i + 1 ],\n\t\t\t\t\trow: n[i].row + 1\n\t\t\t\t};\n\t\t\t\to[ n[i].row + 1 ] = {\n\t\t\t\t\ttext: o[ n[i].row + 1 ],\n\t\t\t\t\trow: i + 1\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tfor ( i = n.length - 1; i > 0; i-- ) {\n\t\t\tif ( n[i].text != null && n[ i - 1 ].text == null && n[i].row > 0 && o[ n[i].row - 1 ].text == null &&\n\t\t\t\t\t\tn[ i - 1 ] == o[ n[i].row - 1 ]) {\n\n\t\t\t\tn[ i - 1 ] = {\n\t\t\t\t\ttext: n[ i - 1 ],\n\t\t\t\t\trow: n[i].row - 1\n\t\t\t\t};\n\t\t\t\to[ n[i].row - 1 ] = {\n\t\t\t\t\ttext: o[ n[i].row - 1 ],\n\t\t\t\t\trow: i - 1\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\to: o,\n\t\t\tn: n\n\t\t};\n\t}\n\n\treturn function( o, n ) {\n\t\to = o.replace( /\\s+$/, \"\" );\n\t\tn = n.replace( /\\s+$/, \"\" );\n\n\t\tvar i, pre,\n\t\t\tstr = \"\",\n\t\t\tout = diff( o === \"\" ? [] : o.split(/\\s+/), n === \"\" ? [] : n.split(/\\s+/) ),\n\t\t\toSpace = o.match(/\\s+/g),\n\t\t\tnSpace = n.match(/\\s+/g);\n\n\t\tif ( oSpace == null ) {\n\t\t\toSpace = [ \" \" ];\n\t\t}\n\t\telse {\n\t\t\toSpace.push( \" \" );\n\t\t}\n\n\t\tif ( nSpace == null ) {\n\t\t\tnSpace = [ \" \" ];\n\t\t}\n\t\telse {\n\t\t\tnSpace.push( \" \" );\n\t\t}\n\n\t\tif ( out.n.length === 0 ) {\n\t\t\tfor ( i = 0; i < out.o.length; i++ ) {\n\t\t\t\tstr += \"<del>\" + out.o[i] + oSpace[i] + \"</del>\";\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( out.n[0].text == null ) {\n\t\t\t\tfor ( n = 0; n < out.o.length && out.o[n].text == null; n++ ) {\n\t\t\t\t\tstr += \"<del>\" + out.o[n] + oSpace[n] + \"</del>\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < out.n.length; i++ ) {\n\t\t\t\tif (out.n[i].text == null) {\n\t\t\t\t\tstr += \"<ins>\" + out.n[i] + nSpace[i] + \"</ins>\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// `pre` initialized at top of scope\n\t\t\t\t\tpre = \"\";\n\n\t\t\t\t\tfor ( n = out.n[i].row + 1; n < out.o.length && out.o[n].text == null; n++ ) {\n\t\t\t\t\t\tpre += \"<del>\" + out.o[n] + oSpace[n] + \"</del>\";\n\t\t\t\t\t}\n\t\t\t\t\tstr += \" \" + out.n[i].text + nSpace[i] + pre;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn str;\n\t};\n}());\n\n// For browser, export only select globals\nif ( typeof window !== \"undefined\" ) {\n\textend( window, QUnit.constructor.prototype );\n\twindow.QUnit = QUnit;\n}\n\n// For CommonJS environments, export everything\nif ( typeof module !== \"undefined\" && module.exports ) {\n\tmodule.exports = QUnit;\n}\n\n\n// Get a reference to the global object, like window in browsers\n}( (function() {\n\treturn this;\n})() ));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../bower_components/qunit/qunit/qunit.js\n// module id = 23\n// module chunks = 1","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/process/browser.js\n// module id = 24\n// module chunks = 1","/**\n * QUnit-TAP - A TAP Output Producer Plugin for QUnit\n *\n * https://github.com/twada/qunit-tap\n * version: 1.5.0\n *\n * Copyright (c) 2010-2014 Takuto Wada\n * Dual licensed under the MIT and GPLv2 licenses.\n *   https://raw.github.com/twada/qunit-tap/master/MIT-LICENSE.txt\n *   https://raw.github.com/twada/qunit-tap/master/GPL-LICENSE.txt\n *\n * A part of extend function is:\n *   Copyright 2012 jQuery Foundation and other contributors\n *   Released under the MIT license.\n *   http://jquery.org/license\n */\n(function (root, factory) {\n    'use strict';\n\n    // using returnExports UMD pattern\n    if (typeof define === 'function' && define.amd) {\n        define(factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.qunitTap = factory();\n    }\n}(this, function () {\n    'use strict';\n\n    var qunitTapVersion = '1.5.0',\n        slice = Array.prototype.slice;\n\n    // borrowed from qunit.js\n    function extend (a, b) {\n        var prop;\n        for (prop in b) {\n            if (b.hasOwnProperty(prop)) {\n                if (typeof b[prop] === 'undefined') {\n                    delete a[prop];\n                } else {\n                    a[prop] = b[prop];\n                }\n            }\n        }\n        return a;\n    }\n\n    function indexOf (ary, element) {\n        var i;\n        for (i = 0; i < ary.length; i += 1) {\n            if (ary[i] === element) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    function removeElement (ary, element) {\n        var index = indexOf(ary, element);\n        if (index !== -1) {\n            return ary.splice(index, 1);\n        } else {\n            return [];\n        }\n    }\n\n    function isPlanRequired (conf) {\n        return (typeof conf !== 'undefined' && typeof conf.requireExpects !== 'undefined' && conf.requireExpects);\n    }\n\n    function isPassed (details) {\n        return !!(details.result);\n    }\n\n    function isFailed (details) {\n        return !(isPassed(details));\n    }\n\n    function isAssertOkFailed (details) {\n        return isFailed(details) && typeof details.expected === 'undefined' && typeof details.actual === 'undefined';\n    }\n\n    function escapeLineEndings (str) {\n        return str.replace(/(\\r?\\n)/g, '$&# ');\n    }\n\n    function ltrim (str) {\n        return str.replace(/^\\s+/, '');\n    }\n\n    function noop (obj) {\n        return obj;\n    }\n\n    function render (desc, fieldName, fieldValue, formatter) {\n        desc.push(fieldName + ': ' + formatter(fieldValue));\n    }\n\n    function renderIf (shouldRender, desc, fieldName, fieldValue, formatter) {\n        if (!shouldRender || typeof fieldValue === 'undefined') {\n            return;\n        }\n        render(desc, fieldName, fieldValue, formatter);\n    }\n\n    function formatTestLine (testLine, rest) {\n        if (!rest) {\n            return testLine;\n        }\n        return testLine + ' - ' + escapeLineEndings(rest);\n    }\n\n    var createCallbackAppenderFor = function (qu) {\n        return function (subject, observer, event) {\n            var originalLoggingCallback = subject[event],\n                callback = function () {\n                    // make listener methods (moduleStart,testStart,log, ...) overridable.\n                    observer[event].apply(observer, slice.apply(arguments));\n                };\n            originalLoggingCallback(callback);\n            return callback;\n        };\n    };\n\n\n    /**\n     * QUnit-TAP - A TAP Output Producer Plugin for QUnit\n     * @param qunitObject QUnit object reference.\n     * @param printLikeFunction print-like function for TAP output (assumes line-separator is added by this function for each call).\n     * @param options configuration options to customize default behavior.\n     * @return object to provide QUnit-TAP API and customization subject.\n     */\n    function qunitTap(qunitObject, printLikeFunction, options) {\n        if (!qunitObject) {\n            throw new Error('should pass QUnit object reference. Please check QUnit\\'s \"require\" path if you are using Node.js (or any CommonJS env).');\n        } else if (typeof printLikeFunction !== 'function') {\n            throw new Error('should pass print-like function');\n        }\n\n        var qu = qunitObject,\n            tap = {},\n            jsDumpExists = (typeof qu.jsDump !== 'undefined' && typeof qu.jsDump.parse === 'function'),\n            explain = (jsDumpExists ? function explain (obj) { return qu.jsDump.parse(obj); } : noop),\n            deprecateOption = function deprecateOption (optionName, fallback) {\n                // option deprecation and fallback function\n                if (!options || typeof options !== 'object') {\n                    return;\n                }\n                if (typeof options[optionName] === 'undefined') {\n                    return;\n                }\n                printLikeFunction('# WARNING: Option \"' + optionName + '\" is deprecated and will be removed in future version.');\n                fallback(options[optionName]);\n            },\n            targetEvents = [\n                'moduleStart',\n                'testStart',\n                'log',\n                'testDone',\n                'done'\n            ],\n            registeredCallbacks = {};\n\n\n        tap.config = extend(\n            {\n                initialCount: 1,\n                showModuleNameOnFailure: true,\n                showTestNameOnFailure: true,\n                showExpectationOnFailure: true,\n                showSourceOnFailure: true\n            },\n            options\n        );\n        deprecateOption('noPlan', function (flag) {\n            printLikeFunction('# Now QUnit-TAP works as with \"noPlan: true\" by default. If you want to delare plan explicitly, please use \"QUnit.config.requireExpects\" option instead.');\n            tap.config.noPlan = flag;\n        });\n        deprecateOption('count', function (count) {\n            tap.config.initialCount = (count + 1);\n        });\n        deprecateOption('showDetailsOnFailure', function (flag) {\n            tap.config.showModuleNameOnFailure = flag;\n            tap.config.showTestNameOnFailure = flag;\n            tap.config.showExpectationOnFailure = flag;\n            tap.config.showSourceOnFailure = flag;\n        });\n        tap.VERSION = qunitTapVersion;\n        tap.puts = printLikeFunction;\n        tap.count = tap.config.initialCount - 1;\n        tap.expectedCount = tap.config.initialCount - 1;\n\n        function isEnabled (configName) {\n            return tap.config[configName];\n        }\n\n        function formatDetails (details) {\n            if (isPassed(details)) {\n                return details.message;\n            }\n            var desc = [];\n            if (details.message) {\n                desc.push(details.message);\n            }\n            if (isEnabled('showExpectationOnFailure') && !(isAssertOkFailed(details))) {\n                render(desc, 'expected', details.expected, explain);\n                render(desc, 'got', details.actual, explain);\n            }\n            renderIf(isEnabled('showTestNameOnFailure'), desc, 'test', details.name, noop);\n            renderIf(isEnabled('showModuleNameOnFailure'), desc, 'module', details.module, noop);\n            renderIf(isEnabled('showSourceOnFailure'), desc, 'source', details.source, ltrim);\n            return desc.join(', ');\n        }\n\n        function printPlanLine (toCount) {\n            tap.puts(tap.config.initialCount + '..' + toCount);\n        }\n\n        function unsubscribeEvent (eventName) {\n            var listeners;\n            if (indexOf(targetEvents, eventName) === -1) {\n                return;\n            }\n            listeners = qu.config[eventName];\n            if (typeof listeners === 'undefined') {\n                return;\n            }\n            removeElement(listeners, registeredCallbacks[eventName]);\n        }\n\n        function unsubscribeEvents (eventNames) {\n            var i;\n            for (i = 0; i < eventNames.length; i += 1) {\n                unsubscribeEvent(eventNames[i]);\n            }\n        }\n\n        tap.explain = explain;\n\n        tap.note = function note (obj) {\n            tap.puts(escapeLineEndings('# ' + obj));\n        };\n\n        tap.diag = function diag (obj) {\n            tap.note(obj);\n            return false;\n        };\n\n        tap.moduleStart = function moduleStart (arg) {\n            var name = (typeof arg === 'string') ? arg : arg.name;\n            tap.note('module: ' + name);\n        };\n\n        tap.testStart = function testStart (arg) {\n            var name = (typeof arg === 'string') ? arg : arg.name;\n            tap.note('test: ' + name);\n        };\n\n        tap.log = function log (details) {\n            var testLine = '';\n            tap.count += 1;\n            if (isFailed(details)) {\n                testLine += 'not ';\n            }\n            testLine += ('ok ' + tap.count);\n            tap.puts(formatTestLine(testLine, formatDetails(details)));\n        };\n\n        tap.testDone = function testDone () {\n            if (isPlanRequired(qu.config)) {\n                tap.expectedCount += qu.config.current.expected;\n            }\n        };\n\n        tap.done = function done () {\n            if (typeof tap.config.noPlan !== 'undefined' && !(tap.config.noPlan)) {\n                // Do nothing until removal of 'noPlan' option.\n            } else if (isPlanRequired(qu.config)) {\n                printPlanLine(tap.expectedCount);\n            } else {\n                printPlanLine(tap.count);\n            }\n        };\n\n        tap.unsubscribe = function unsubscribe () {\n            if (typeof qu.config === 'undefined') {\n                return;\n            }\n            if (arguments.length === 0) {\n                unsubscribeEvents(targetEvents);\n            } else {\n                unsubscribeEvents(slice.apply(arguments));\n            }\n        };\n\n        (function () {\n            var appendCallback = createCallbackAppenderFor(qu),\n                eventName, i, callback;\n            for (i = 0; i < targetEvents.length; i += 1) {\n                eventName = targetEvents[i];\n                callback = appendCallback(qu, tap, eventName);\n                registeredCallbacks[eventName] = callback;\n            }\n        })();\n\n        return tap;\n    }\n\n    qunitTap.qunitTap = function () {\n        throw new Error('[BC BREAK] Since 1.4.0, QUnit-TAP exports single qunitTap function as module.exports. Therefore, require(\"qunit-tap\") returns qunitTap function itself. Please fix your code if you are using Node.js (or any CommonJS env).');\n    };\n\n    // using substack pattern (export single function)\n    return qunitTap;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../bower_components/qunit-tap/lib/qunit-tap.js\n// module id = 25\n// module chunks = 1","'use strict';\n\n/* global QUnit, qunitTap */\n\nvar qunit_started = false;\n\n/* Always use explicit start */\nQUnit.config.autostart = false;\n\n/*\n * HACK: phantomjs doesn't handle uncaught exceptions as it should if\n * window.onerror is non-null, even when that handler returns false\n * (expecting that the browser default behavior will occur).\n *\n * So remove the qunit window.onerror handler until the tests actually\n * start, and any errors become part of the test suite results.\n */\nvar qunit_onerror = window.onerror;\nwindow.onerror = null;\nQUnit.begin(function() {\n    window.onerror = function(error, file, line) {\n        var ret = false;\n        if (qunit_onerror)\n            ret = qunit_onerror(error, file, line);\n\n        /*\n         * If a global exception happens during an async test\n         * then that test won't be able to call the start() function\n         * to move to the next test, so call it here.\n         */\n        if (QUnit.config.current && QUnit.config.current.async)\n            QUnit.start();\n\n        return ret;\n    };\n});\n\nQUnit.moduleStart(function() {\n    qunit_started = true;\n});\n\nQUnit.done(function() {\n    console.log(\"phantom-tap-done\");\n    window.onerror = null;\n});\n/*\n * Now initialize qunit-tap\n *\n * When not running under tap-phantom this stuff will just show up in\n * the console. We print out a special canary at the end of the tests\n * so that tap-phantom can know when the testing is done.\n *\n * In addition double check for a test file that doesn't properly call\n * QUnit.start() after its done setting up its tests.\n *\n * We also want to insert the current test name into all tap lines.\n */\nvar tap_regex = /^((not )?ok [0-9]+ (- )?)(.*)$/;\nqunitTap(QUnit, function() {\n    if (arguments.length == 1 && QUnit.config.current) {\n        var match = tap_regex.exec(arguments[0]);\n        if (match) {\n            console.log(match[1] + QUnit.config.current.testName + \": \" + match[4]);\n            return;\n        }\n    }\n    console.log.apply(console, arguments);\n});\n\nwindow.setTimeout(function() {\n    if (!qunit_started) {\n        console.log(\"QUnit not started by test\");\n        console.log(\"phantom-tap-error\");\n    }\n}, 20000);\n\nwindow.tests_included = true;\n\nif (module && module.exports)\n    module.exports = QUnit;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../pkg/lib/qunit-config.js\n// module id = 26\n// module chunks = 1","module.exports = function(module) {\n\tif(!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tmodule.children = [];\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/webpack/buildin/module.js\n// module id = 27\n// module chunks = 1"],"sourceRoot":""}